import { createClient, createServiceClient } from '@/lib/supabase/server'
import { requireStaffAuth } from '@/lib/auth'
import { logBlacklistMatches, screenAgainstBlacklist } from '@/lib/compliance/blacklist'
import { NextRequest, NextResponse } from 'next/server'

export const dynamic = 'force-dynamic'

export async function POST(request: NextRequest) {
  try {
    const user = await requireStaffAuth()
    const supabase = await createClient()

    const body = await request.json()
    const {
      investor_id,
      vehicle_id,
      commitment,
      currency,
      status,
      effective_date,
      funding_due_at,
      units,
      acknowledgement_notes,
    } = body

    // Validate required fields
    if (!investor_id || !vehicle_id || !commitment) {
      return NextResponse.json(
        { error: 'investor_id, vehicle_id, and commitment are required' },
        { status: 400 }
      )
    }

    // Create the subscription
    // Note: subscription_number is auto-generated by database sequence (subscription_number_seq)
    // This eliminates the race condition from the previous SELECT max() + 1 pattern
    const { data: newSubscription, error: createError } = await supabase
      .from('subscriptions')
      .insert({
        investor_id,
        vehicle_id,
        // subscription_number is auto-generated by DB sequence
        commitment,
        currency: currency || 'USD',
        status: status || 'pending',
        effective_date: effective_date || null,
        funding_due_at: funding_due_at || null,
        units: units || null,
        acknowledgement_notes: acknowledgement_notes || null,
      })
      .select(`
        *,
        investor:investors (
          id,
          legal_name,
          type,
          country
        ),
        vehicle:vehicles (
          id,
          name,
          type,
          currency,
          entity_code
        )
      `)
      .single()

    if (createError) {
      console.error('[Create Subscription] Error creating subscription:', createError)
      return NextResponse.json(
        { error: 'Failed to create subscription', details: createError.message },
        { status: 500 }
      )
    }

    // Screen investor against blacklist (alert only, do not block)
    try {
      const serviceSupabase = createServiceClient()
      const { data: investorRecord } = await serviceSupabase
        .from('investors')
        .select('id, legal_name, display_name, type, email, phone, phone_mobile, phone_office, tax_id_number, entity_identifier')
        .eq('id', investor_id)
        .maybeSingle()

      if (investorRecord) {
        const isEntity = investorRecord.type && investorRecord.type !== 'individual'
        const fullName = isEntity
          ? null
          : (investorRecord.display_name || investorRecord.legal_name)
        const entityName = isEntity
          ? (investorRecord.legal_name || investorRecord.display_name)
          : null
        const phone = investorRecord.phone || investorRecord.phone_mobile || investorRecord.phone_office
        const taxId = investorRecord.tax_id_number || investorRecord.entity_identifier

        const matches = await screenAgainstBlacklist(serviceSupabase, {
          email: investorRecord.email,
          fullName,
          entityName,
          phone,
          taxId
        })

        const subjectLabel = fullName || entityName || investorRecord.legal_name || investorRecord.display_name || 'Investor'

        await logBlacklistMatches({
          supabase: serviceSupabase,
          matches,
          context: 'subscription_create',
          input: {
            email: investorRecord.email,
            fullName,
            entityName,
            phone,
            taxId
          },
          subjectLabel,
          matchedInvestorId: investorRecord.id,
          relatedInvestorId: investorRecord.id,
          actorId: user.id,
          actionLabel: 'alerted_on_subscription_create'
        })
      }
    } catch (error) {
      console.error('[subscription blacklist] Screening failed:', error)
    }

    return NextResponse.json({
      success: true,
      subscription: newSubscription,
    })
  } catch (error) {
    console.error('[Create Subscription] Exception:', error)
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}
