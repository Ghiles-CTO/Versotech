{"version":3,"sources":["../../../../versotech-portal/src/lib/signature/config.ts","../../../../versotech-portal/src/lib/signature/token.ts","../../../../versotech-portal/src/lib/fees/subscription-fee-calculator.ts","../../../../versotech-portal/src/lib/signature/helpers.ts","../../../../versotech-portal/src/lib/signature/anchor-detector.ts","../../../../versotech-portal/src/lib/signature/storage.ts"],"sourcesContent":["/**\r\n * Centralized configuration for signature system\r\n */\r\n\r\nexport const SIGNATURE_CONFIG = {\r\n  storage: {\r\n    bucket: process.env.SIGNATURES_BUCKET || 'signatures',\r\n    paths: {\r\n      unsigned: (investorId: string, token: string) =>\r\n        `${investorId}/${token}_unsigned.pdf`,\r\n      signed: (investorId: string, token: string) =>\r\n        `${investorId}/${token}_signed.pdf`\r\n    }\r\n  },\r\n  token: {\r\n    lengthBytes: 32,\r\n    expiryDays: 7\r\n  },\r\n  pdf: {\r\n    signature: {\r\n      // Reduced from 180x70 to fit better in subscription pack signature fields\r\n      // and prevent overlap with surrounding text\r\n      width: 150,\r\n      height: 50\r\n    },\r\n    table: {\r\n      // Y position calibrated from actual NDA template (Page 5, US Letter 612√ó792pt)\r\n      // Signature boxes: y=433 from bottom, height=112\r\n      // Formula: signatureY = bottom + height/2 - sigHeight/2\r\n      // Target Y = 433 + 56 - 35 = 454 (centered in 112pt box)\r\n      bottom: 433,\r\n      height: 112\r\n    },\r\n    positions: {\r\n      // X positions calibrated from actual NDA template (Page 5)\r\n      // Party A (Investor): left box x=53, width=252 ‚Üí center=179 ‚Üí 179/612=0.292\r\n      party_a: { xPercent: 0.292 },\r\n      // Party B (VERSO): right box x=305, width=252 ‚Üí center=431 ‚Üí 431/612=0.704\r\n      party_b: { xPercent: 0.704 }\r\n    },\r\n    metadata: {\r\n      timestampFontSize: 7,\r\n      // Reduced offsets to keep metadata closer to signature\r\n      // and prevent overlap with content below\r\n      timestampOffsetY: 12,  // was 15\r\n      signerNameOffsetY: 22, // was 27\r\n      textColor: { r: 0.3, g: 0.3, b: 0.3 }\r\n    }\r\n  },\r\n  email: {\r\n    fromAddress: 'signatures@versoholdings.com',\r\n    replyTo: 'support@versoholdings.com'\r\n  }\r\n} as const\r\n","/**\r\n * Token generation and validation utilities\r\n */\r\n\r\nimport crypto from 'crypto'\r\nimport { SIGNATURE_CONFIG } from './config'\r\n\r\n/**\r\n * Generate a cryptographically secure signing token\r\n */\r\nexport function generateSignatureToken(): string {\r\n  return crypto\r\n    .randomBytes(SIGNATURE_CONFIG.token.lengthBytes)\r\n    .toString('hex')\r\n}\r\n\r\n/**\r\n * Calculate token expiry date\r\n */\r\nexport function calculateTokenExpiry(days?: number): Date {\r\n  const expiry = new Date()\r\n  expiry.setDate(expiry.getDate() + (days || SIGNATURE_CONFIG.token.expiryDays))\r\n  return expiry\r\n}\r\n\r\n/**\r\n * Check if token has expired\r\n */\r\nexport function isTokenExpired(expiresAt: string | Date): boolean {\r\n  return new Date() > new Date(expiresAt)\r\n}\r\n\r\n/**\r\n * Get the application base URL with fallbacks for different environments\r\n * Always returns URL WITHOUT trailing slash to prevent double-slash issues\r\n */\r\nexport function getAppUrl(): string {\r\n  let url: string\r\n\r\n  // Priority order: NEXT_PUBLIC_APP_URL > VERCEL_URL > NEXT_PUBLIC_SITE_URL\r\n  if (process.env.NEXT_PUBLIC_APP_URL) {\r\n    url = process.env.NEXT_PUBLIC_APP_URL\r\n  } else if (process.env.VERCEL_URL) {\r\n    // Vercel automatically provides VERCEL_URL in production\r\n    url = `https://${process.env.VERCEL_URL}`\r\n  } else if (process.env.NEXT_PUBLIC_SITE_URL) {\r\n    url = process.env.NEXT_PUBLIC_SITE_URL\r\n  } else if (typeof window !== 'undefined') {\r\n    // Browser fallback (client-side only)\r\n    url = window.location.origin\r\n  } else if (process.env.NODE_ENV === 'production') {\r\n    // Server-side: NEVER use localhost in production\r\n    throw new Error('App URL must be configured in production. Set NEXT_PUBLIC_APP_URL, VERCEL_URL, or NEXT_PUBLIC_SITE_URL environment variable.')\r\n  } else {\r\n    // Development fallback only\r\n    url = 'http://localhost:3000'\r\n  }\r\n\r\n  // Remove trailing slash to prevent double-slash issues (e.g., https://app.com//path)\r\n  return url.replace(/\\/+$/, '')\r\n}\r\n\r\n/**\r\n * Generate signing URL from token\r\n */\r\nexport function generateSigningUrl(token: string): string {\r\n  const baseUrl = getAppUrl()\r\n  return `${baseUrl}/sign/${token}`\r\n}\r\n","/**\r\n * Subscription Fee Calculator\r\n * Calculates fee events from subscription data\r\n *\r\n * Source of Truth: Subscription table (amounts)\r\n * Frequency Source: Fee plan (if linked)\r\n */\r\n\r\nimport { SupabaseClient } from '@supabase/supabase-js';\r\n\r\ninterface SubscriptionFees {\r\n  subscription_fee_percent?: number | null;\r\n  subscription_fee_amount?: number | null;\r\n  spread_fee_amount?: number | null;\r\n  bd_fee_percent?: number | null;\r\n  bd_fee_amount?: number | null;\r\n  finra_fee_amount?: number | null;\r\n  management_fee_percent?: number | null;\r\n  management_fee_amount?: number | null;\r\n  management_fee_frequency?: string | null;\r\n  performance_fee_tier1_percent?: number | null;\r\n  performance_fee_tier1_threshold?: number | null;\r\n  performance_fee_tier2_percent?: number | null;\r\n  performance_fee_tier2_threshold?: number | null;\r\n}\r\n\r\ninterface FeeEvent {\r\n  fee_type: 'subscription' | 'management' | 'performance' | 'spread_markup' | 'bd_fee' | 'finra_fee' | 'flat' | 'other';\r\n  base_amount: number;\r\n  computed_amount: number;\r\n  rate_bps?: number | null;\r\n  frequency: 'one_time' | 'quarterly' | 'annual' | 'monthly' | 'on_exit';\r\n  payment_schedule: 'upfront' | 'recurring' | 'on_demand';\r\n  description: string;\r\n}\r\n\r\n/**\r\n * Calculate fee events for a subscription\r\n * @param supabase - Supabase client\r\n * @param subscriptionId - Subscription ID\r\n * @returns Array of fee events to be created\r\n */\r\nexport async function calculateSubscriptionFeeEvents(\r\n  supabase: SupabaseClient,\r\n  subscriptionId: string\r\n): Promise<{ success: boolean; feeEvents?: FeeEvent[]; error?: string }> {\r\n  try {\r\n    // Fetch subscription with fee plan and vehicle\r\n    const { data: subscription, error: subError } = await supabase\r\n      .from('subscriptions')\r\n      .select(`\r\n        *,\r\n        vehicle:vehicles (\r\n          id,\r\n          name\r\n        ),\r\n        fee_plan:fee_plans (\r\n          id,\r\n          components:fee_components (\r\n            kind,\r\n            frequency,\r\n            payment_schedule\r\n          )\r\n        )\r\n      `)\r\n      .eq('id', subscriptionId)\r\n      .single();\r\n\r\n    if (subError || !subscription) {\r\n      return { success: false, error: subError?.message || 'Subscription not found' };\r\n    }\r\n\r\n    const feeEvents: FeeEvent[] = [];\r\n    const fees = subscription as SubscriptionFees;\r\n    const feePlan = (subscription as any).fee_plan;\r\n\r\n    // Helper to get frequency/payment_schedule from fee plan\r\n    const getFrequencyInfo = (kind: string) => {\r\n      if (!feePlan || !feePlan.components) {\r\n        // No fee plan: default to one_time/upfront\r\n        return { frequency: 'one_time' as const, payment_schedule: 'upfront' as const };\r\n      }\r\n\r\n      const component = feePlan.components.find((c: any) => c.kind === kind);\r\n      return {\r\n        frequency: component?.frequency || 'one_time' as const,\r\n        payment_schedule: component?.payment_schedule || 'upfront' as const,\r\n      };\r\n    };\r\n\r\n    // 0. COMMITMENT AMOUNT (the investment itself)\r\n    // This is the primary payment - the investor's actual commitment to the vehicle\r\n    const commitmentAmount = subscription.commitment || 0;\r\n    if (commitmentAmount > 0) {\r\n      feeEvents.push({\r\n        fee_type: 'flat',\r\n        base_amount: commitmentAmount,\r\n        computed_amount: commitmentAmount,\r\n        rate_bps: null,\r\n        frequency: 'one_time',\r\n        payment_schedule: 'upfront',\r\n        description: `Investment commitment - ${(subscription as any).vehicle?.name || 'vehicle'}`,\r\n      });\r\n    }\r\n\r\n    // 1. Subscription Fee\r\n    // Note: Check for != null to properly handle explicit 0 values (0 means \"no fee\")\r\n    if (fees.subscription_fee_percent != null || fees.subscription_fee_amount != null) {\r\n      const baseAmount = subscription.commitment || 0;\r\n      const { frequency, payment_schedule } = getFrequencyInfo('subscription');\r\n\r\n      // Use explicit amount if provided (even if 0), otherwise calculate from percent\r\n      const computedAmount = fees.subscription_fee_amount != null\r\n        ? fees.subscription_fee_amount\r\n        : (baseAmount * (fees.subscription_fee_percent || 0) / 100);\r\n\r\n      feeEvents.push({\r\n        fee_type: 'subscription',\r\n        base_amount: baseAmount,\r\n        computed_amount: computedAmount,\r\n        rate_bps: fees.subscription_fee_percent ? Math.round(fees.subscription_fee_percent * 100) : null,\r\n        frequency,\r\n        payment_schedule,\r\n        description: `Subscription fee for ${subscription.commitment || 0} commitment`,\r\n      });\r\n    }\r\n\r\n    // 2. Management Fee\r\n    // Note: Check for != null to properly handle explicit 0 values (0 means \"no fee\")\r\n    if (fees.management_fee_percent != null || fees.management_fee_amount != null) {\r\n      const baseAmount = subscription.commitment || 0;\r\n      const { frequency, payment_schedule } = getFrequencyInfo('management');\r\n\r\n      // Use subscription's frequency if specified, otherwise use fee plan\r\n      const finalFrequency = fees.management_fee_frequency || frequency;\r\n\r\n      // Use explicit amount if provided (even if 0), otherwise calculate from percent\r\n      const computedAmount = fees.management_fee_amount != null\r\n        ? fees.management_fee_amount\r\n        : (baseAmount * (fees.management_fee_percent || 0) / 100);\r\n\r\n      feeEvents.push({\r\n        fee_type: 'management',\r\n        base_amount: baseAmount,\r\n        computed_amount: computedAmount,\r\n        rate_bps: fees.management_fee_percent ? Math.round(fees.management_fee_percent * 100) : null,\r\n        frequency: finalFrequency as any,\r\n        payment_schedule,\r\n        description: `Management fee for ${subscription.commitment || 0} commitment`,\r\n      });\r\n    }\r\n\r\n    // 3. BD Fee (Broker-Dealer)\r\n    // Note: Check for != null to properly handle explicit 0 values (0 means \"no fee\")\r\n    if (fees.bd_fee_percent != null || fees.bd_fee_amount != null) {\r\n      const baseAmount = subscription.commitment || 0;\r\n      const { frequency, payment_schedule } = getFrequencyInfo('bd_fee');\r\n\r\n      // Use explicit amount if provided (even if 0), otherwise calculate from percent\r\n      const computedAmount = fees.bd_fee_amount != null\r\n        ? fees.bd_fee_amount\r\n        : (baseAmount * (fees.bd_fee_percent || 0) / 100);\r\n\r\n      feeEvents.push({\r\n        fee_type: 'bd_fee',\r\n        base_amount: baseAmount,\r\n        computed_amount: computedAmount,\r\n        rate_bps: fees.bd_fee_percent ? Math.round(fees.bd_fee_percent * 100) : null,\r\n        frequency,\r\n        payment_schedule,\r\n        description: `Broker-dealer fee for ${subscription.commitment || 0} commitment`,\r\n      });\r\n    }\r\n\r\n    // 4. FINRA Fee\r\n    if (fees.finra_fee_amount) {\r\n      const { frequency, payment_schedule } = getFrequencyInfo('finra_fee');\r\n\r\n      feeEvents.push({\r\n        fee_type: 'finra_fee',\r\n        base_amount: fees.finra_fee_amount,\r\n        computed_amount: fees.finra_fee_amount,\r\n        rate_bps: null,\r\n        frequency,\r\n        payment_schedule,\r\n        description: 'FINRA regulatory fee',\r\n      });\r\n    }\r\n\r\n    // 5. Spread Fee\r\n    if (fees.spread_fee_amount) {\r\n      const { frequency, payment_schedule } = getFrequencyInfo('spread_markup');\r\n\r\n      feeEvents.push({\r\n        fee_type: 'spread_markup',\r\n        base_amount: fees.spread_fee_amount,\r\n        computed_amount: fees.spread_fee_amount,\r\n        rate_bps: null,\r\n        frequency,\r\n        payment_schedule,\r\n        description: 'Spread markup fee',\r\n      });\r\n    }\r\n\r\n    // 6. Performance Fee (Tier 1 and Tier 2)\r\n    if (fees.performance_fee_tier1_percent || fees.performance_fee_tier2_percent) {\r\n      const { frequency, payment_schedule } = getFrequencyInfo('performance');\r\n\r\n      // Calculate actual performance fee if NAV exists\r\n      const commitment = subscription.commitment || 0;\r\n      const nav = (subscription as any).current_nav || 0;\r\n      let performanceFee = 0;\r\n      const tier1Threshold = fees.performance_fee_tier1_threshold || 0;\r\n      const tier2Threshold = fees.performance_fee_tier2_threshold || 0;\r\n      const tier1Percent = fees.performance_fee_tier1_percent || 0;\r\n      const tier2Percent = fees.performance_fee_tier2_percent || 0;\r\n\r\n      // Calculate returns-based performance fee (same logic as overview page)\r\n      if (nav > 0 && commitment > 0) {\r\n        const returns = nav - commitment;\r\n        if (returns > 0) {\r\n          if (tier2Percent > 0 && returns > tier2Threshold) {\r\n            performanceFee = returns * (tier2Percent / 100);\r\n          } else if (tier1Percent > 0 && returns > tier1Threshold) {\r\n            performanceFee = returns * (tier1Percent / 100);\r\n          }\r\n        }\r\n      }\r\n\r\n      // Create description based on which tier applies\r\n      let description = 'Performance fee';\r\n      if (tier2Percent > 0 && tier2Threshold > 0) {\r\n        description = `Performance fee (Tier 2: ${tier2Percent}% above ${tier2Threshold} returns)`;\r\n      } else if (tier1Percent > 0) {\r\n        description = `Performance fee (Tier 1: ${tier1Percent}% above ${tier1Threshold || 0} returns)`;\r\n      }\r\n\r\n      feeEvents.push({\r\n        fee_type: 'performance',\r\n        base_amount: nav > 0 ? nav - commitment : 0,\r\n        computed_amount: performanceFee,\r\n        rate_bps: tier2Percent > 0 ? Math.round(tier2Percent * 100) : Math.round(tier1Percent * 100),\r\n        frequency,\r\n        payment_schedule,\r\n        description,\r\n      });\r\n    }\r\n\r\n    return { success: true, feeEvents };\r\n  } catch (error) {\r\n    console.error('Error calculating subscription fee events:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Unknown error',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Create fee event records in database\r\n * @param supabase - Supabase client\r\n * @param subscriptionId - Subscription ID\r\n * @param feeEvents - Calculated fee events\r\n * @returns Created fee event IDs\r\n */\r\nexport async function createFeeEvents(\r\n  supabase: SupabaseClient,\r\n  subscriptionId: string,\r\n  investorId: string,\r\n  dealId: string | null,\r\n  feePlanId: string | null,\r\n  feeEvents: FeeEvent[],\r\n  options?: { skipDeduplication?: boolean }\r\n): Promise<{ success: boolean; feeEventIds?: string[]; error?: string; skipped?: boolean }> {\r\n  try {\r\n    // Deduplication check: Skip if fee events already exist for this subscription\r\n    // This prevents double-charging if createFeeEvents is called multiple times\r\n    if (!options?.skipDeduplication) {\r\n      const { data: existingEvents, error: checkError } = await supabase\r\n        .from('fee_events')\r\n        .select('id')\r\n        .eq('allocation_id', subscriptionId)\r\n        .limit(1);\r\n\r\n      if (checkError) {\r\n        console.warn('[FEE EVENTS] Error checking existing fee events:', checkError.message);\r\n        // Continue anyway - better to risk duplicates than fail silently\r\n      } else if (existingEvents && existingEvents.length > 0) {\r\n        console.log(`[FEE EVENTS] Fee events already exist for subscription ${subscriptionId}, skipping creation`);\r\n        return { success: true, feeEventIds: [], skipped: true };\r\n      }\r\n    }\r\n\r\n    // Fetch subscription to get currency\r\n    const { data: subscription } = await supabase\r\n      .from('subscriptions')\r\n      .select('currency')\r\n      .eq('id', subscriptionId)\r\n      .single();\r\n\r\n    const currency = subscription?.currency || 'USD';\r\n\r\n    // Determine payee_arranger_id - first check fee_plan, then deal\r\n    let payeeArrangerId: string | null = null;\r\n\r\n    // Check if fee_plan was created by an arranger\r\n    if (feePlanId) {\r\n      const { data: feePlan } = await supabase\r\n        .from('fee_plans')\r\n        .select('created_by_arranger_id')\r\n        .eq('id', feePlanId)\r\n        .single();\r\n\r\n      if (feePlan?.created_by_arranger_id) {\r\n        payeeArrangerId = feePlan.created_by_arranger_id;\r\n      }\r\n    }\r\n\r\n    // If no arranger from fee_plan, check deal\r\n    if (!payeeArrangerId && dealId) {\r\n      const { data: deal } = await supabase\r\n        .from('deals')\r\n        .select('arranger_entity_id')\r\n        .eq('id', dealId)\r\n        .single();\r\n\r\n      if (deal?.arranger_entity_id) {\r\n        payeeArrangerId = deal.arranger_entity_id;\r\n      }\r\n    }\r\n\r\n    // If we have a fee plan, fetch its components to link properly\r\n    const componentMap: Record<string, string> = {};\r\n    if (feePlanId) {\r\n      const { data: components } = await supabase\r\n        .from('fee_components')\r\n        .select('id, kind')\r\n        .eq('fee_plan_id', feePlanId);\r\n\r\n      if (components) {\r\n        // Map fee_type to component_id\r\n        components.forEach((comp: any) => {\r\n          componentMap[comp.kind] = comp.id;\r\n        });\r\n      }\r\n    }\r\n\r\n    const inserts = feeEvents.map((fe) => {\r\n      // Match fee_type to fee_component_id\r\n      // fee_type 'flat' (commitment) doesn't get a component_id\r\n      const feeComponentId = fe.fee_type === 'flat' ? null : componentMap[fe.fee_type] || null;\r\n\r\n      // Warn if fee type expected a component but none found\r\n      if (fe.fee_type !== 'flat' && !feeComponentId && feePlanId) {\r\n        console.warn(\r\n          `‚ö†Ô∏è [FEE EVENTS] No component found for fee_type '${fe.fee_type}' in fee plan ${feePlanId}. ` +\r\n          `Fee event will be created without component link.`\r\n        );\r\n      }\r\n\r\n      return {\r\n        investor_id: investorId,\r\n        deal_id: dealId,\r\n        allocation_id: subscriptionId, // Link to subscription\r\n        fee_component_id: feeComponentId, // NOW PROPERLY LINKED!\r\n        fee_type: fe.fee_type,\r\n        event_date: new Date().toISOString(),\r\n        base_amount: fe.base_amount,\r\n        computed_amount: fe.computed_amount,\r\n        rate_bps: fe.rate_bps,\r\n        currency: currency, // Use subscription currency\r\n        status: 'accrued', // Ready to be invoiced\r\n        notes: fe.description,\r\n        payee_arranger_id: payeeArrangerId, // Link to arranger for payment requests\r\n      };\r\n    });\r\n\r\n    const { data, error } = await supabase\r\n      .from('fee_events')\r\n      .insert(inserts)\r\n      .select('id');\r\n\r\n    if (error) {\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return {\r\n      success: true,\r\n      feeEventIds: data?.map((d) => d.id) || [],\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating fee events:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Unknown error',\r\n    };\r\n  }\r\n}\r\n","/**\n * Signature Position Helpers\n *\n * Utilities for parsing and calculating signature positions\n * in multi-signatory documents (subscription packs, NDAs, etc.)\n *\n * For SUBSCRIPTION documents: Positions are stored at creation time in signature_placements JSONB\n * For NDA and other documents: Uses legacy hardcoded positions\n */\n\n/**\n * Parse a signature position string to extract party and index\n *\n * @example parseSignaturePosition('party_a') ‚Üí { party: 'a', index: 1 }\n * @example parseSignaturePosition('party_a_2') ‚Üí { party: 'a', index: 2 }\n * @example parseSignaturePosition('party_b') ‚Üí { party: 'b', index: 1 }\n * @example parseSignaturePosition('party_c') ‚Üí { party: 'c', index: 1 }\n */\nexport function parseSignaturePosition(position: string): {\n  party: 'a' | 'b' | 'c'\n  index: number\n} {\n  // Match patterns like 'party_a', 'party_a_2', 'party_b', 'party_c'\n  const match = position.match(/^party_([abc])(?:_(\\d+))?$/)\n\n  if (!match) {\n    // Default fallback for unknown positions\n    console.warn(`Unknown signature position format: ${position}, defaulting to party_a index 1`)\n    return { party: 'a', index: 1 }\n  }\n\n  const party = match[1] as 'a' | 'b' | 'c'\n  // If no index suffix, it's index 1 (party_a = party_a_1)\n  const index = match[2] ? parseInt(match[2], 10) : 1\n\n  return { party, index }\n}\n\n/**\n * Check if a signature position belongs to Party A (investor side)\n *\n * @example isPartyA('party_a') ‚Üí true\n * @example isPartyA('party_a_2') ‚Üí true\n * @example isPartyA('party_b') ‚Üí false\n */\nexport function isPartyA(position: string): boolean {\n  return position.startsWith('party_a')\n}\n\n/**\n * Check if a signature position belongs to Party B (countersigner side - CEO/Arranger)\n *\n * @example isPartyB('party_b') ‚Üí true\n * @example isPartyB('party_b_2') ‚Üí true\n * @example isPartyB('party_a') ‚Üí false\n */\nexport function isPartyB(position: string): boolean {\n  return position.startsWith('party_b')\n}\n\n/**\n * Calculate X and Y coordinates for a signature based on position and total signatories\n *\n * LEGACY FUNCTION - Used only for NDA and other non-subscription documents.\n * For subscription documents, positions are stored in signature_placements JSONB column.\n *\n * Layout: Side-by-side columns (Party A left, Party B right)\n *\n * @param position - Signature position (e.g., 'party_a', 'party_a_2', 'party_b')\n * @param totalPartyASignatories - Total number of Party A signatories (for Y spacing calculation)\n * @param documentType - Document type for position calculation (default: 'nda')\n * @returns { xPercent, yFromBottom } - X as percentage of page width, Y in points from bottom\n */\nexport function calculateSignaturePosition(\n  position: string,\n  totalPartyASignatories: number = 1,\n  documentType: string = 'nda'\n): { xPercent: number; yFromBottom: number } {\n  const { party, index } = parseSignaturePosition(position)\n\n  // SUBSCRIPTION PACK: No longer supported here - positions come from signature_placements JSONB\n  if (documentType === 'subscription') {\n    throw new Error(\n      'SIGNATURE_ERROR: Subscription documents use pre-calculated signature_placements. ' +\n      'This function should not be called for subscription documents.'\n    )\n  }\n\n  // NDA AND OTHER DOCUMENTS: Side-by-side columns (original behavior)\n  // Party B (CEO/Julien/Arranger): fixed position on RIGHT side\n  if (party === 'b') {\n    return {\n      xPercent: 0.704, // 70.4% from left (right column)\n      yFromBottom: 433  // Fixed Y position\n    }\n  }\n\n  // Party A (Investor signatories): LEFT column, stacked vertically\n  const xPercent = 0.292 // 29.2% from left (left column)\n\n  // Single signatory: use legacy position\n  if (totalPartyASignatories === 1) {\n    return {\n      xPercent,\n      yFromBottom: 433 // Same as Party B for single signer\n    }\n  }\n\n  // Multiple signatories: stack vertically (first at TOP, others below)\n  // Start higher when there are more signers to make room\n  const baseY = 520 + (totalPartyASignatories - 2) * 50\n  const spacing = 100 // 100pt between each signature\n\n  // Index 1 is at TOP, subsequent indices move DOWN (lower Y)\n  const yFromBottom = baseY - (index - 1) * spacing\n\n  return { xPercent, yFromBottom }\n}\n\n/**\n * Generate a signature position string for a given party and index\n *\n * @example getSignaturePositionString('a', 1) ‚Üí 'party_a'\n * @example getSignaturePositionString('a', 2) ‚Üí 'party_a_2'\n * @example getSignaturePositionString('b', 1) ‚Üí 'party_b'\n */\nexport function getSignaturePositionString(\n  party: 'a' | 'b',\n  index: number\n): string {\n  if (index === 1) {\n    return `party_${party}`\n  }\n  return `party_${party}_${index}`\n}\n\n/**\n * Get all Party A signature positions for a given number of signatories\n *\n * @example getPartyAPositions(1) ‚Üí ['party_a']\n * @example getPartyAPositions(3) ‚Üí ['party_a', 'party_a_2', 'party_a_3']\n */\nexport function getPartyAPositions(totalSignatories: number): string[] {\n  const positions: string[] = []\n  for (let i = 1; i <= totalSignatories; i++) {\n    positions.push(getSignaturePositionString('a', i))\n  }\n  return positions\n}\n","/**\n * Anchor Detection for Subscription Pack PDFs\n *\n * Scans a PDF for SIG_ANCHOR markers and returns their exact positions.\n * These positions are used to place signatures at the correct locations.\n *\n * ANCHOR NAMING CONVENTION (matches database signature_position):\n * - Subscribers: party_a, party_a_2, party_a_3, ... (first is 'party_a', NOT 'party_a_1')\n * - Issuer: party_b, party_b_form, party_b_wire, party_b_tcs\n * - Arranger: party_c, party_c_tcs\n * - Introducer agreements: party_a (VERSO/Arranger), party_b, party_b_2, ...\n */\n\nimport { existsSync } from 'fs'\nimport { fileURLToPath } from 'url'\nimport type { DocumentType, SignaturePlacementRecord } from './types'\nimport { SIGNATURE_CONFIG } from './config'\n\nexport interface DetectedAnchor {\n  anchorId: string       // e.g., 'party_a', 'party_b_tcs', 'party_a_2_form'\n  pageNumber: number     // 1-indexed page number\n  rawX: number           // X coordinate in points (from left of page)\n  rawY: number           // Y coordinate in points (from bottom of page - PDF native)\n  xPercent: number       // X as percentage of page width (0-1)\n  yFromBottom: number    // Y in points from bottom (same as rawY for PDF.js)\n  pageWidth: number      // Page width in points\n  pageHeight: number     // Page height in points\n}\n\n/**\n * Scan PDF for all SIG_ANCHOR markers\n *\n * The PDF.js library extracts text items with their transform matrices.\n * transform[4] = X position, transform[5] = Y position (from bottom of page)\n *\n * @param pdfBytes - Raw PDF bytes as Uint8Array\n * @returns Array of detected anchors with positions\n */\nexport async function detectAnchors(pdfBytes: Uint8Array): Promise<DetectedAnchor[]> {\n  // Dynamic import pdfjs-dist\n  const pdfjsLib = await import('pdfjs-dist/legacy/build/pdf.mjs')\n\n  // CRITICAL: Set worker path for Node.js/server-side usage\n  // Must be set BEFORE calling getDocument\n  const workerCandidates = [\n    process.env.PDFJS_WORKER_SRC,\n    new URL('pdfjs-dist/legacy/build/pdf.worker.mjs', import.meta.url).toString(),\n    new URL('../../../node_modules/pdfjs-dist/legacy/build/pdf.worker.mjs', import.meta.url).toString()\n  ].filter(Boolean) as string[]\n\n  const resolvedWorkerSrc = workerCandidates.find((candidate) => {\n    try {\n      const path = candidate.startsWith('file:')\n        ? fileURLToPath(candidate)\n        : candidate\n      return existsSync(path)\n    } catch {\n      return false\n    }\n  }) || workerCandidates[0]\n\n  pdfjsLib.GlobalWorkerOptions.workerSrc = resolvedWorkerSrc\n\n  const anchors: DetectedAnchor[] = []\n\n  try {\n    const loadingTask = pdfjsLib.getDocument({\n      data: pdfBytes,\n      useSystemFonts: true,\n      disableFontFace: true,\n    })\n\n    const pdf = await loadingTask.promise\n\n    console.log(`üîç [ANCHOR] Scanning ${pdf.numPages} pages for SIG_ANCHOR markers...`)\n\n    for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {\n      const page = await pdf.getPage(pageNum)\n      const textContent = await page.getTextContent()\n      const viewport = page.getViewport({ scale: 1.0 })\n\n      for (const item of textContent.items) {\n        if (!('str' in item)) continue\n\n        const text = item.str\n\n        // Check for both formats:\n        // 1. Normal: SIG_ANCHOR:party_b_wire\n        // 2. Space-corrupted: SIG ANCHOR:party b wire (HTML-to-PDF renderer sometimes breaks underscores)\n        const hasNormalAnchor = text.includes('SIG_ANCHOR:')\n        const hasSpaceAnchor = text.includes('SIG ANCHOR:')\n\n        if (!hasNormalAnchor && !hasSpaceAnchor) continue\n\n        // Try normal format first, then space-corrupted format\n        let anchorId: string | null = null\n\n        if (hasNormalAnchor) {\n          const match = text.match(/SIG_ANCHOR:(\\S+)/)\n          if (match) {\n            anchorId = match[1]\n          }\n        } else if (hasSpaceAnchor) {\n          // Match space-corrupted format: \"SIG ANCHOR:party b wire\" or \"SIG ANCHOR:party c\"\n          // Capture everything after the colon until end or next significant separator\n          const match = text.match(/SIG ANCHOR:([a-z0-9_ ]+)/i)\n          if (match) {\n            // Normalize: convert spaces to underscores, trim\n            anchorId = match[1].trim().replace(/ /g, '_')\n            console.log(`   üîß Normalized space-corrupted anchor: \"${match[1]}\" -> \"${anchorId}\"`)\n          }\n        }\n\n        if (!anchorId) continue\n\n        const rawX = item.transform[4]\n        const rawY = item.transform[5]\n\n        anchors.push({\n          anchorId,\n          pageNumber: pageNum,\n          rawX,\n          rawY,\n          xPercent: rawX / viewport.width,\n          yFromBottom: rawY,\n          pageWidth: viewport.width,\n          pageHeight: viewport.height\n        })\n\n        console.log(`   üìç Found ${anchorId} on page ${pageNum} at (${rawX.toFixed(1)}, ${rawY.toFixed(1)}) - ${(rawX / viewport.width * 100).toFixed(1)}% from left`)\n      }\n    }\n  } catch (error) {\n    console.error('‚ùå [ANCHOR] PDF parsing error:', error)\n    throw error\n  }\n\n  console.log(`‚úÖ [ANCHOR] Found ${anchors.length} anchor(s) total`)\n  return anchors\n}\n\n/**\n * Get a specific anchor by ID\n *\n * @param anchors - Array of detected anchors\n * @param anchorId - The anchor ID to find\n * @returns The anchor, or throws if not found\n */\nexport function getAnchorById(anchors: DetectedAnchor[], anchorId: string): DetectedAnchor {\n  const anchor = anchors.find(a => a.anchorId === anchorId)\n  if (!anchor) {\n    const available = anchors.map(a => a.anchorId).join(', ') || '(none)'\n    throw new Error(`ANCHOR_NOT_FOUND: ${anchorId}. Available anchors: ${available}`)\n  }\n  return anchor\n}\n\n/**\n * Validate that all required anchors exist in the detected set\n *\n * @param anchors - Array of detected anchors\n * @param required - Array of anchor IDs that must be present\n * @throws Error if any required anchor is missing\n */\nexport function validateRequiredAnchors(anchors: DetectedAnchor[], required: string[]): void {\n  const found = new Set(anchors.map(a => a.anchorId))\n  const missing = required.filter(r => !found.has(r))\n\n  if (missing.length > 0) {\n    const available = Array.from(found).join(', ') || '(none)'\n    throw new Error(`MISSING_ANCHORS: ${missing.join(', ')}. Found: ${available}`)\n  }\n}\n\n/**\n * Get anchor patterns for a given signature position\n *\n * NAMING CONVENTION:\n * - Database uses: party_a, party_a_2, party_a_3 (first is 'party_a', NOT 'party_a_1')\n * - Anchors match the database convention exactly\n *\n * WHICH PAGES EACH PARTY SIGNS:\n * - Subscribers (party_a*): Page 2 (form), Page 12 (main)\n * - Issuer (party_b): Page 2 (form), Page 3 (wire), Page 12 (main), Page 39 (T&Cs)\n * - Arranger (party_c): Page 12 (main), Page 39 (T&Cs)\n *\n * @param position - Database signature_position value\n * @returns Array of anchor patterns with their labels\n */\nfunction getAnchorPatternsForPosition(\n  position: string,\n  documentType: DocumentType = 'subscription'\n): { anchorId: string; label: string }[] {\n  if (documentType === 'introducer_agreement') {\n    return [\n      { anchorId: position, label: 'introducer_agreement' }\n    ]\n  }\n\n  // Subscribers sign on: Page 2 (form), Page 12 (main)\n  if (position.startsWith('party_a')) {\n    // position is 'party_a', 'party_a_2', 'party_a_3', etc.\n    // Anchors use SAME base: 'party_a', 'party_a_2', 'party_a_3'\n    const base = position\n    return [\n      { anchorId: `${base}_form`, label: 'subscription_form' },\n      { anchorId: base, label: 'main_agreement' }\n    ]\n  }\n\n  // Issuer signs on: Page 2 (form), Page 3 (wire), Page 12 (main), Page 39 (T&Cs)\n  if (position === 'party_b') {\n    return [\n      { anchorId: 'party_b_form', label: 'subscription_form' },\n      { anchorId: 'party_b_wire', label: 'wire_instructions' },\n      { anchorId: 'party_b', label: 'main_agreement' },\n      { anchorId: 'party_b_tcs', label: 'tcs' }\n    ]\n  }\n\n  // Arranger signs on: Page 12 (main), Page 39 (T&Cs)\n  if (position === 'party_c') {\n    return [\n      { anchorId: 'party_c', label: 'main_agreement' },\n      { anchorId: 'party_c_tcs', label: 'tcs' }\n    ]\n  }\n\n  console.warn(`‚ö†Ô∏è [ANCHOR] Unknown position: ${position}`)\n  return []\n}\n\n/**\n * Get fixed X position for signature based on party type and page label\n *\n * RATIONALE: The anchor's raw X coordinate represents where the anchor TEXT starts,\n * not where the signature should go. Since anchors are placed at the start of cells/blocks,\n * they always report X near the left margin. Instead, we use FIXED positions based on\n * the known column layout of the subscription pack template:\n *\n * COLUMN POSITIONS:\n * - Form page: Issuer left column, Subscriber right column\n * - Main agreement: All parties stacked on the left\n * - T&Cs: Issuer/Arranger centered on signature page\n *\n * @param signaturePosition - The database signature_position value (party_a, party_b, party_c)\n * @param label - The page/section label (subscription_form, main_agreement, etc.)\n * @returns X position as percentage of page width (0-1)\n */\nfunction getSignatureXPosition(\n  signaturePosition: string,\n  label: string,\n  documentType: DocumentType = 'subscription'\n): number {\n  // Party A (Subscribers): Right column on form page, stacked-left on main agreement\n  if (signaturePosition.startsWith('party_a')) {\n    if (label === 'subscription_form') return 0.63  // Right column (form table)\n    return 0.29  // Stacked left (main agreement)\n  }\n\n  // Party B (Issuer): Left on form/wire/main, centered on T&Cs signature page\n  if (signaturePosition === 'party_b') {\n    if (label === 'tcs') return 0.43\n    if (label === 'main_agreement') return 0.29\n    if (label === 'subscription_form') return 0.20\n    return 0.25\n  }\n\n  // Party C (Arranger): Stacked left on main, centered on T&Cs signature page\n  if (signaturePosition === 'party_c') {\n    if (label === 'tcs') return 0.43\n    return 0.29\n  }\n\n  return 0.29  // Default to stacked-left alignment\n}\n\n/**\n * Get signature Y position from the anchor position\n *\n * Anchors are now placed ON the signature line. This function shifts the signature\n * image ABOVE the line so that the metadata (timestamp + signer name) sits just\n * above the line and does not overlap Name/Title text below.\n *\n * @param anchor - Detected anchor with rawY (line position)\n * @param label - Page/section label (used for compact layout offsets)\n * @returns Signature Y position in points from bottom of page\n */\nfunction getSignatureYFromAnchor(\n  anchor: DetectedAnchor,\n  label: string,\n  documentType: DocumentType = 'subscription'\n): number {\n  const { metadata } = SIGNATURE_CONFIG.pdf\n\n  // Keep in sync with embedSignatureMultipleLocations() compact layout offsets\n  const compactSignerOffset = 14\n  const signerOffset = label === 'wire_instructions'\n    ? compactSignerOffset\n    : metadata.signerNameOffsetY\n\n  const lineGap = 4\n  return anchor.rawY + signerOffset + lineGap\n}\n\n/**\n * Convert detected anchors to signature placements for a specific signer\n *\n * This is the main function used during signature request creation to\n * calculate where signatures should be placed based on detected anchors.\n *\n * POSITIONING STRATEGY (v5 - ANCHOR-BASED Y):\n * - X: Uses FIXED column positions based on party type and page label\n * - Y: Uses anchor position + offset (anchor is on the signature line)\n *\n * WHY ANCHOR-BASED Y:\n * Anchors are placed directly on the signature line, so anchor.yFromBottom is the\n * line position. We then offset upward so the signature image sits above the line.\n *\n * X POSITIONING (VC215-aligned):\n * - Party A (Subscribers): 63% on form, 29% on main agreement\n * - Party B (Issuer): 20% on form, 25% on wire, 29% on main, 43% on T&Cs\n * - Party C (Arranger): 29% on main, 43% on T&Cs\n *\n * @param anchors - All detected anchors from PDF\n * @param signaturePosition - The signer's position (e.g., 'party_a', 'party_b')\n * @returns Array of placements for this signer\n */\nexport function getPlacementsFromAnchors(\n  anchors: DetectedAnchor[],\n  signaturePosition: string,\n  documentType: DocumentType = 'subscription'\n): SignaturePlacementRecord[] {\n  // Map signature positions to their anchor patterns\n  const anchorPatterns = getAnchorPatternsForPosition(signaturePosition, documentType)\n  const placements: SignaturePlacementRecord[] = []\n\n  console.log(`üìç [PLACEMENT] Calculating placements for ${signaturePosition} (${documentType}, anchor-based Y)...`)\n\n  for (const pattern of anchorPatterns) {\n    const anchor = anchors.find(a => a.anchorId === pattern.anchorId)\n    if (anchor) {\n      const fixedX = documentType === 'introducer_agreement'\n        ? anchor.xPercent\n        : getSignatureXPosition(signaturePosition, pattern.label, documentType)\n\n      // Get signature Y position based on anchor line + offset\n      const signatureY = getSignatureYFromAnchor(anchor, pattern.label, documentType)\n\n      // Debug logging\n      console.log(`   üîç [ANCHOR] ${pattern.anchorId} on page ${anchor.pageNumber}`)\n      console.log(`      Anchor position (for reference): (${anchor.rawX.toFixed(0)}pt, ${anchor.rawY.toFixed(0)}pt)`)\n      console.log(`   üìç [PLACEMENT] ${signaturePosition} -> page ${anchor.pageNumber}`)\n      console.log(`      FIXED X: ${(fixedX * 100).toFixed(0)}% | ANCHOR Y: ${signatureY.toFixed(0)}pt (${pattern.label})`)\n\n      placements.push({\n        page: anchor.pageNumber,\n        x: fixedX,  // FIXED X position based on party/page\n        y: signatureY,  // Anchor-based Y position\n        label: pattern.label\n      })\n\n      console.log(`   ‚úì ${pattern.anchorId} -> page ${anchor.pageNumber}, x=${(fixedX * 100).toFixed(0)}%, y=${signatureY.toFixed(0)}pt (${pattern.label})`)\n    } else {\n      console.warn(`   ‚ö†Ô∏è Anchor not found: ${pattern.anchorId} (expected for ${signaturePosition})`)\n    }\n  }\n\n  console.log(`‚úÖ [PLACEMENT] Created ${placements.length} placement(s) for ${signaturePosition}`)\n  return placements\n}\n\n/**\n * Get required anchors for a subscription pack based on signatory count\n *\n * @param subscriberCount - Number of investor signatories (1-10)\n * @returns Array of all anchor IDs that should be present in the PDF\n */\nexport function getRequiredAnchorsForSubscriptionPack(subscriberCount: number): string[] {\n  const required: string[] = []\n\n  // Subscriber anchors (party_a, party_a_2, party_a_3, ...)\n  for (let i = 1; i <= subscriberCount; i++) {\n    const base = i === 1 ? 'party_a' : `party_a_${i}`\n    required.push(`${base}_form`)   // Page 2\n    required.push(base)              // Page 12\n  }\n\n  // Issuer anchors (party_b)\n  required.push('party_b_form')  // Page 2\n  required.push('party_b_wire')  // Page 3\n  required.push('party_b')       // Page 12\n  required.push('party_b_tcs')   // Page 39\n\n  // Arranger anchors (party_c)\n  required.push('party_c')       // Page 12\n  required.push('party_c_tcs')   // Page 39\n\n  return required\n}\n\n/**\n * Get required anchors for an introducer agreement based on signatory count\n *\n * @param signatoryCount - Number of introducer signers\n * @returns Array of anchor IDs that should be present in the PDF\n */\nexport function getRequiredAnchorsForIntroducerAgreement(signatoryCount: number): string[] {\n  const required: string[] = ['party_a']\n\n  for (let i = 1; i <= signatoryCount; i++) {\n    const base = i === 1 ? 'party_b' : `party_b_${i}`\n    required.push(base)\n  }\n\n  return required\n}\n\n/**\n * Helper to generate anchor ID matching database convention\n * First subscriber is 'party_a', subsequent are 'party_a_2', 'party_a_3', etc.\n *\n * @param number - 1-based signatory number\n * @param suffix - Optional suffix like 'form'\n * @returns Anchor ID string\n */\nexport function getSignatoryAnchorId(number: number, suffix?: string): string {\n  const base = number === 1 ? 'party_a' : `party_a_${number}`\n  return suffix ? `${base}_${suffix}` : base\n}\n","/**\r\n * Storage management for signature PDFs\r\n */\r\n\r\nimport type { SupabaseClient } from '@supabase/supabase-js'\r\nimport { SIGNATURE_CONFIG } from './config'\r\n\r\nexport class SignatureStorageManager {\r\n  constructor(private supabase: SupabaseClient) {}\r\n\r\n  /**\r\n   * Upload unsigned PDF to storage\r\n   */\r\n  async uploadUnsignedPDF(\r\n    investorId: string,\r\n    token: string,\r\n    pdfBytes: Uint8Array,\r\n    metadata: Record<string, string>\r\n  ): Promise<string> {\r\n    const path = SIGNATURE_CONFIG.storage.paths.unsigned(investorId, token)\r\n\r\n    const { data, error } = await this.supabase.storage\r\n      .from(SIGNATURE_CONFIG.storage.bucket)\r\n      .upload(path, pdfBytes, {\r\n        contentType: 'application/pdf',\r\n        metadata\r\n      })\r\n\r\n    if (error) {\r\n      throw new Error(`Failed to upload unsigned PDF: ${error.message}`)\r\n    }\r\n\r\n    return data.path\r\n  }\r\n\r\n  /**\r\n   * Upload signed PDF to storage\r\n   */\r\n  async uploadSignedPDF(\r\n    investorId: string,\r\n    token: string,\r\n    pdfBytes: Uint8Array,\r\n    metadata: Record<string, string>\r\n  ): Promise<string> {\r\n    const path = SIGNATURE_CONFIG.storage.paths.signed(investorId, token)\r\n\r\n    const { data, error } = await this.supabase.storage\r\n      .from(SIGNATURE_CONFIG.storage.bucket)\r\n      .upload(path, pdfBytes, {\r\n        contentType: 'application/pdf',\r\n        metadata\r\n      })\r\n\r\n    if (error) {\r\n      throw new Error(`Failed to upload signed PDF: ${error.message}`)\r\n    }\r\n\r\n    return data.path\r\n  }\r\n\r\n  /**\r\n   * Download PDF from storage\r\n   *\r\n   * Handles files from both 'signatures' and 'deal-documents' buckets:\r\n   * - Paths starting with 'subscriptions/', 'introducer-agreements/', 'placement-agreements/' are in 'deal-documents'\r\n   * - All other paths are in 'signatures' bucket\r\n   */\r\n  async downloadPDF(path: string): Promise<Uint8Array> {\r\n    // Determine bucket based on path pattern\r\n    const bucket = (path.startsWith('subscriptions/') || path.startsWith('introducer-agreements/') || path.startsWith('placement-agreements/'))\r\n      ? 'deal-documents'\r\n      : SIGNATURE_CONFIG.storage.bucket\r\n\r\n    const { data, error } = await this.supabase.storage\r\n      .from(bucket)\r\n      .download(path)\r\n\r\n    if (error) {\r\n      throw new Error(`Failed to download PDF: ${error.message}`)\r\n    }\r\n\r\n    return new Uint8Array(await data.arrayBuffer())\r\n  }\r\n\r\n  /**\r\n   * Get signed URL for PDF\r\n   *\r\n   * Handles files from both 'signatures' and 'deal-documents' buckets:\r\n   * - Paths starting with 'subscriptions/' are in 'deal-documents' (certificates)\r\n   * - All other paths are in 'signatures' bucket\r\n   */\r\n  async getSignedUrl(path: string, expirySeconds: number = 3600): Promise<string> {\r\n    // Determine bucket based on path pattern\r\n    // Documents in deal-documents bucket: subscriptions/, introducer-agreements/, placement-agreements/\r\n    const bucket = (path.startsWith('subscriptions/') || path.startsWith('introducer-agreements/') || path.startsWith('placement-agreements/'))\r\n      ? 'deal-documents'\r\n      : SIGNATURE_CONFIG.storage.bucket\r\n\r\n    const { data, error } = await this.supabase.storage\r\n      .from(bucket)\r\n      .createSignedUrl(path, expirySeconds)\r\n\r\n    if (error) {\r\n      throw new Error(`Failed to create signed URL: ${error.message}`)\r\n    }\r\n\r\n    return data.signedUrl\r\n  }\r\n}\r\n\r\n/**\r\n * Download PDF from external URL (e.g., Google Drive)\r\n */\r\nexport async function downloadPDFFromUrl(url: string): Promise<Uint8Array> {\r\n  const response = await fetch(url)\r\n\r\n  if (!response.ok) {\r\n    throw new Error(`Failed to download PDF: ${response.statusText}`)\r\n  }\r\n\r\n  return new Uint8Array(await response.arrayBuffer())\r\n}\r\n"],"names":[],"mappings":"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"}