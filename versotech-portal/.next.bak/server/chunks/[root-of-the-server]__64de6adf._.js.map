{"version":3,"sources":["../../../../versotech-portal/src/lib/supabase/server.ts","../../../../versotech-portal/src/lib/trigger-workflow.ts","../../../../versotech-portal/src/lib/signature/config.ts","../../../../versotech-portal/src/lib/signature/anchor-detector.ts"],"sourcesContent":["import { createServerClient } from '@supabase/ssr'\nimport { createClient as createSupabaseClient } from '@supabase/supabase-js'\nimport { cookies } from 'next/headers'\n\nexport const createClient = async () => {\n  const cookieStore = await cookies()\n\n  return createServerClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n    {\n      cookies: {\n        getAll() {\n          return cookieStore.getAll()\n        },\n        setAll(cookiesToSet) {\n          try {\n            cookiesToSet.forEach(({ name, value, options }) => {\n              cookieStore.set(name, value, options)\n            })\n          } catch (error) {\n            // The `setAll` method was called from a Server Component.\n            // This can be ignored if you have middleware refreshing\n            // user sessions.\n          }\n        },\n      },\n    }\n  )\n}\n\n// Server client with service role for admin operations\n// Uses raw supabase-js client which properly bypasses RLS with service role\nexport const createServiceClient = () => {\n  return createSupabaseClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.SUPABASE_SERVICE_ROLE_KEY!,\n    {\n      auth: {\n        autoRefreshToken: false,\n        persistSession: false,\n      },\n    }\n  )\n}\n","import { createServiceClient } from '@/lib/supabase/server'\r\nimport crypto from 'crypto'\r\n\r\n/**\r\n * Extract filename from Content-Disposition header\r\n */\r\nfunction extractFilenameFromHeaders(headers: Headers): string | undefined {\r\n  const disposition = headers.get('content-disposition')\r\n  if (!disposition) return undefined\r\n\r\n  const filenameMatch = disposition.match(/filename[^;=\\n]*=((['\"]).*?\\2|[^;\\n]*)/)\r\n  if (filenameMatch && filenameMatch[1]) {\r\n    return filenameMatch[1].replace(/['\"]/g, '')\r\n  }\r\n  return undefined\r\n}\r\n\r\n/**\r\n * Check if Content-Type indicates binary response\r\n */\r\nfunction isBinaryContentType(contentType: string): boolean {\r\n  const binaryTypes = [\r\n    'application/octet-stream',\r\n    'application/vnd.openxmlformats-officedocument',\r\n    'application/msword',\r\n    'application/pdf',\r\n    'application/zip',\r\n    'image/',\r\n    'video/',\r\n    'audio/'\r\n  ]\r\n  return binaryTypes.some(type => contentType.includes(type))\r\n}\r\n\r\ninterface TriggerWorkflowParams {\r\n  workflowKey: string\r\n  payload: Record<string, any>\r\n  entityType?: string\r\n  entityId?: string\r\n  user: {\r\n    id: string\r\n    email: string\r\n    displayName?: string\r\n    role: string\r\n    title?: string\r\n  }\r\n}\r\n\r\nexport async function triggerWorkflow({\r\n  workflowKey,\r\n  payload,\r\n  entityType,\r\n  entityId,\r\n  user\r\n}: TriggerWorkflowParams): Promise<{\r\n  success: boolean\r\n  workflow_run_id?: string\r\n  n8n_response?: any\r\n  error?: string\r\n}> {\r\n  try {\r\n    const serviceSupabase = createServiceClient()\r\n\r\n    // Fetch workflow from database\r\n    const { data: workflow, error: workflowError } = await serviceSupabase\r\n      .from('workflows')\r\n      .select('*')\r\n      .eq('key', workflowKey)\r\n      .eq('is_active', true)\r\n      .single()\r\n\r\n    if (workflowError || !workflow) {\r\n      console.error('Workflow not found:', workflowKey)\r\n      return { success: false, error: 'Workflow not found' }\r\n    }\r\n\r\n    // Generate idempotency token\r\n    const idempotencyToken = crypto\r\n      .createHash('sha256')\r\n      .update(`${workflow.id}:${user.id}:${JSON.stringify(payload)}`)\r\n      .digest('hex')\r\n\r\n    // Generate webhook signature\r\n    const webhookSecret = process.env.N8N_WEBHOOK_SECRET || process.env.N8N_OUTBOUND_SECRET\r\n\r\n    if (!webhookSecret) {\r\n      console.error('N8N_WEBHOOK_SECRET not configured')\r\n      return {\r\n        success: false,\r\n        error: 'Webhook authentication not configured. Cannot trigger workflow.'\r\n      }\r\n    }\r\n\r\n    if (webhookSecret === 'default-webhook-secret' && process.env.NODE_ENV === 'production') {\r\n      console.error('CRITICAL: N8N_WEBHOOK_SECRET using insecure default value in production')\r\n      return {\r\n        success: false,\r\n        error: 'Webhook authentication misconfigured. Please set a secure N8N_WEBHOOK_SECRET.'\r\n      }\r\n    }\r\n\r\n    const webhookSignature = crypto\r\n      .createHmac('sha256', webhookSecret)\r\n      .update(idempotencyToken)\r\n      .digest('hex')\r\n\r\n    // Create workflow run\r\n    const { data: workflowRun, error: runError } = await serviceSupabase\r\n      .from('workflow_runs')\r\n      .insert({\r\n        workflow_id: workflow.id,\r\n        workflow_key: workflow.key,\r\n        triggered_by: user.id,\r\n        entity_type: entityType ?? 'process',\r\n        entity_id: entityId || null,\r\n        input_params: payload,\r\n        status: 'queued',\r\n        idempotency_token: idempotencyToken,\r\n        webhook_signature: webhookSignature\r\n      })\r\n      .select()\r\n      .single()\r\n\r\n    if (runError || !workflowRun) {\r\n      console.error('Failed to create workflow run:', runError)\r\n      return { success: false, error: 'Failed to create workflow run' }\r\n    }\r\n\r\n    // Prepare n8n payload\r\n    const n8nPayload = {\r\n      workflow_run_id: workflowRun.id,\r\n      workflow_key: workflow.key,\r\n      triggered_by: {\r\n        id: user.id,\r\n        email: user.email,\r\n        display_name: user.displayName,\r\n        role: user.role,\r\n        title: user.title\r\n      },\r\n      payload,\r\n      entity_type: workflowRun.entity_type\r\n    }\r\n\r\n    // Trigger n8n webhook\r\n    const n8nResponse = await fetch(workflow.n8n_webhook_url, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        'x-verso-signature': webhookSignature,\r\n        'x-idempotency-key': idempotencyToken,\r\n        'x-workflow-run-id': workflowRun.id\r\n      },\r\n      body: JSON.stringify(n8nPayload)\r\n    })\r\n\r\n    // Detect response type and handle accordingly\r\n    const contentType = n8nResponse.headers.get('content-type') || ''\r\n    let n8nResult: any = {}\r\n\r\n    if (isBinaryContentType(contentType)) {\r\n      // Binary response - use arrayBuffer to preserve binary data\r\n      console.log('üîç Detected binary response, Content-Type:', contentType)\r\n      const arrayBuffer = await n8nResponse.arrayBuffer()\r\n      const buffer = Buffer.from(arrayBuffer)\r\n\r\n      // Extract filename from headers if available\r\n      const filename = extractFilenameFromHeaders(n8nResponse.headers)\r\n\r\n      // Verify binary integrity (check for common file signatures)\r\n      const signature = buffer.slice(0, 4).toString('hex')\r\n      console.log('üìÑ Binary file signature:', signature, 'size:', buffer.length, 'bytes')\r\n\r\n      n8nResult = {\r\n        binary: buffer,\r\n        filename: filename,\r\n        mimeType: contentType,\r\n        size: buffer.length,\r\n        signature: signature // Useful for debugging\r\n      }\r\n    } else if (contentType.includes('application/json')) {\r\n      // JSON response\r\n      const responseText = await n8nResponse.text()\r\n      try {\r\n        n8nResult = JSON.parse(responseText)\r\n      } catch (error) {\r\n        console.warn('‚ö†Ô∏è Failed to parse JSON response:', error)\r\n        n8nResult = { raw: responseText }\r\n      }\r\n    } else {\r\n      // Unknown content type - try JSON first, fall back to text\r\n      const responseText = await n8nResponse.text()\r\n      try {\r\n        n8nResult = JSON.parse(responseText)\r\n      } catch {\r\n        // If not JSON and not explicitly binary, treat as latin1-encoded binary string\r\n        // This handles cases where n8n returns binary without proper Content-Type\r\n        console.log('‚ö†Ô∏è Unknown content type, treating as potential binary string')\r\n        n8nResult = { raw: responseText }\r\n      }\r\n    }\r\n\r\n    if (!n8nResponse.ok) {\r\n      const errorMessage = n8nResult.raw\r\n        ? `Failed to trigger n8n: ${n8nResult.raw}`\r\n        : `Failed to trigger n8n: ${n8nResponse.status} ${n8nResponse.statusText}`\r\n\r\n      await serviceSupabase\r\n        .from('workflow_runs')\r\n        .update({\r\n          status: 'failed',\r\n          error_message: errorMessage,\r\n          completed_at: new Date().toISOString()\r\n        })\r\n        .eq('id', workflowRun.id)\r\n\r\n      return { success: false, error: 'Failed to trigger n8n webhook' }\r\n    }\r\n\r\n    // Update workflow run status\r\n    await serviceSupabase\r\n      .from('workflow_runs')\r\n      .update({\r\n        status: 'running',\r\n        started_at: new Date().toISOString(),\r\n        output_data: n8nResult\r\n      })\r\n      .eq('id', workflowRun.id)\r\n\r\n    // Create audit log\r\n    await serviceSupabase.from('audit_logs').insert({\r\n      event_type: 'workflow',\r\n      actor_id: user.id,\r\n      action: 'workflow_triggered',\r\n      entity_type: 'workflow_runs',\r\n      entity_id: workflowRun.id,\r\n      action_details: {\r\n        workflow_key: workflow.key,\r\n        payload,\r\n        entity_type: workflowRun.entity_type\r\n      },\r\n      timestamp: new Date().toISOString()\r\n    })\r\n\r\n    return {\r\n      success: true,\r\n      workflow_run_id: workflowRun.id,\r\n      n8n_response: n8nResult\r\n    }\r\n  } catch (error) {\r\n    console.error('Workflow trigger error:', error)\r\n    return { success: false, error: 'Internal error triggering workflow' }\r\n  }\r\n}\r\n","/**\r\n * Centralized configuration for signature system\r\n */\r\n\r\nexport const SIGNATURE_CONFIG = {\r\n  storage: {\r\n    bucket: process.env.SIGNATURES_BUCKET || 'signatures',\r\n    paths: {\r\n      unsigned: (investorId: string, token: string) =>\r\n        `${investorId}/${token}_unsigned.pdf`,\r\n      signed: (investorId: string, token: string) =>\r\n        `${investorId}/${token}_signed.pdf`\r\n    }\r\n  },\r\n  token: {\r\n    lengthBytes: 32,\r\n    expiryDays: 7\r\n  },\r\n  pdf: {\r\n    signature: {\r\n      // Reduced from 180x70 to fit better in subscription pack signature fields\r\n      // and prevent overlap with surrounding text\r\n      width: 150,\r\n      height: 50\r\n    },\r\n    table: {\r\n      // Y position calibrated from actual NDA template (Page 5, US Letter 612√ó792pt)\r\n      // Signature boxes: y=433 from bottom, height=112\r\n      // Formula: signatureY = bottom + height/2 - sigHeight/2\r\n      // Target Y = 433 + 56 - 35 = 454 (centered in 112pt box)\r\n      bottom: 433,\r\n      height: 112\r\n    },\r\n    positions: {\r\n      // X positions calibrated from actual NDA template (Page 5)\r\n      // Party A (Investor): left box x=53, width=252 ‚Üí center=179 ‚Üí 179/612=0.292\r\n      party_a: { xPercent: 0.292 },\r\n      // Party B (VERSO): right box x=305, width=252 ‚Üí center=431 ‚Üí 431/612=0.704\r\n      party_b: { xPercent: 0.704 }\r\n    },\r\n    metadata: {\r\n      timestampFontSize: 7,\r\n      // Reduced offsets to keep metadata closer to signature\r\n      // and prevent overlap with content below\r\n      timestampOffsetY: 12,  // was 15\r\n      signerNameOffsetY: 22, // was 27\r\n      textColor: { r: 0.3, g: 0.3, b: 0.3 }\r\n    }\r\n  },\r\n  email: {\r\n    fromAddress: 'signatures@versoholdings.com',\r\n    replyTo: 'support@versoholdings.com'\r\n  }\r\n} as const\r\n","/**\n * Anchor Detection for Subscription Pack PDFs\n *\n * Scans a PDF for SIG_ANCHOR markers and returns their exact positions.\n * These positions are used to place signatures at the correct locations.\n *\n * ANCHOR NAMING CONVENTION (matches database signature_position):\n * - Subscribers: party_a, party_a_2, party_a_3, ... (first is 'party_a', NOT 'party_a_1')\n * - Issuer: party_b, party_b_form, party_b_wire, party_b_tcs\n * - Arranger: party_c, party_c_tcs\n * - Introducer agreements: party_a (VERSO/Arranger), party_b, party_b_2, ...\n */\n\nimport { existsSync } from 'fs'\nimport { fileURLToPath } from 'url'\nimport type { DocumentType, SignaturePlacementRecord } from './types'\nimport { SIGNATURE_CONFIG } from './config'\n\nexport interface DetectedAnchor {\n  anchorId: string       // e.g., 'party_a', 'party_b_tcs', 'party_a_2_form'\n  pageNumber: number     // 1-indexed page number\n  rawX: number           // X coordinate in points (from left of page)\n  rawY: number           // Y coordinate in points (from bottom of page - PDF native)\n  xPercent: number       // X as percentage of page width (0-1)\n  yFromBottom: number    // Y in points from bottom (same as rawY for PDF.js)\n  pageWidth: number      // Page width in points\n  pageHeight: number     // Page height in points\n}\n\n/**\n * Scan PDF for all SIG_ANCHOR markers\n *\n * The PDF.js library extracts text items with their transform matrices.\n * transform[4] = X position, transform[5] = Y position (from bottom of page)\n *\n * @param pdfBytes - Raw PDF bytes as Uint8Array\n * @returns Array of detected anchors with positions\n */\nexport async function detectAnchors(pdfBytes: Uint8Array): Promise<DetectedAnchor[]> {\n  // Dynamic import pdfjs-dist\n  const pdfjsLib = await import('pdfjs-dist/legacy/build/pdf.mjs')\n\n  // CRITICAL: Set worker path for Node.js/server-side usage\n  // Must be set BEFORE calling getDocument\n  const workerCandidates = [\n    process.env.PDFJS_WORKER_SRC,\n    new URL('pdfjs-dist/legacy/build/pdf.worker.mjs', import.meta.url).toString(),\n    new URL('../../../node_modules/pdfjs-dist/legacy/build/pdf.worker.mjs', import.meta.url).toString()\n  ].filter(Boolean) as string[]\n\n  const resolvedWorkerSrc = workerCandidates.find((candidate) => {\n    try {\n      const path = candidate.startsWith('file:')\n        ? fileURLToPath(candidate)\n        : candidate\n      return existsSync(path)\n    } catch {\n      return false\n    }\n  }) || workerCandidates[0]\n\n  pdfjsLib.GlobalWorkerOptions.workerSrc = resolvedWorkerSrc\n\n  const anchors: DetectedAnchor[] = []\n\n  try {\n    const loadingTask = pdfjsLib.getDocument({\n      data: pdfBytes,\n      useSystemFonts: true,\n      disableFontFace: true,\n    })\n\n    const pdf = await loadingTask.promise\n\n    console.log(`üîç [ANCHOR] Scanning ${pdf.numPages} pages for SIG_ANCHOR markers...`)\n\n    for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {\n      const page = await pdf.getPage(pageNum)\n      const textContent = await page.getTextContent()\n      const viewport = page.getViewport({ scale: 1.0 })\n\n      for (const item of textContent.items) {\n        if (!('str' in item)) continue\n\n        const text = item.str\n\n        // Check for both formats:\n        // 1. Normal: SIG_ANCHOR:party_b_wire\n        // 2. Space-corrupted: SIG ANCHOR:party b wire (HTML-to-PDF renderer sometimes breaks underscores)\n        const hasNormalAnchor = text.includes('SIG_ANCHOR:')\n        const hasSpaceAnchor = text.includes('SIG ANCHOR:')\n\n        if (!hasNormalAnchor && !hasSpaceAnchor) continue\n\n        // Try normal format first, then space-corrupted format\n        let anchorId: string | null = null\n\n        if (hasNormalAnchor) {\n          const match = text.match(/SIG_ANCHOR:(\\S+)/)\n          if (match) {\n            anchorId = match[1]\n          }\n        } else if (hasSpaceAnchor) {\n          // Match space-corrupted format: \"SIG ANCHOR:party b wire\" or \"SIG ANCHOR:party c\"\n          // Capture everything after the colon until end or next significant separator\n          const match = text.match(/SIG ANCHOR:([a-z0-9_ ]+)/i)\n          if (match) {\n            // Normalize: convert spaces to underscores, trim\n            anchorId = match[1].trim().replace(/ /g, '_')\n            console.log(`   üîß Normalized space-corrupted anchor: \"${match[1]}\" -> \"${anchorId}\"`)\n          }\n        }\n\n        if (!anchorId) continue\n\n        const rawX = item.transform[4]\n        const rawY = item.transform[5]\n\n        anchors.push({\n          anchorId,\n          pageNumber: pageNum,\n          rawX,\n          rawY,\n          xPercent: rawX / viewport.width,\n          yFromBottom: rawY,\n          pageWidth: viewport.width,\n          pageHeight: viewport.height\n        })\n\n        console.log(`   üìç Found ${anchorId} on page ${pageNum} at (${rawX.toFixed(1)}, ${rawY.toFixed(1)}) - ${(rawX / viewport.width * 100).toFixed(1)}% from left`)\n      }\n    }\n  } catch (error) {\n    console.error('‚ùå [ANCHOR] PDF parsing error:', error)\n    throw error\n  }\n\n  console.log(`‚úÖ [ANCHOR] Found ${anchors.length} anchor(s) total`)\n  return anchors\n}\n\n/**\n * Get a specific anchor by ID\n *\n * @param anchors - Array of detected anchors\n * @param anchorId - The anchor ID to find\n * @returns The anchor, or throws if not found\n */\nexport function getAnchorById(anchors: DetectedAnchor[], anchorId: string): DetectedAnchor {\n  const anchor = anchors.find(a => a.anchorId === anchorId)\n  if (!anchor) {\n    const available = anchors.map(a => a.anchorId).join(', ') || '(none)'\n    throw new Error(`ANCHOR_NOT_FOUND: ${anchorId}. Available anchors: ${available}`)\n  }\n  return anchor\n}\n\n/**\n * Validate that all required anchors exist in the detected set\n *\n * @param anchors - Array of detected anchors\n * @param required - Array of anchor IDs that must be present\n * @throws Error if any required anchor is missing\n */\nexport function validateRequiredAnchors(anchors: DetectedAnchor[], required: string[]): void {\n  const found = new Set(anchors.map(a => a.anchorId))\n  const missing = required.filter(r => !found.has(r))\n\n  if (missing.length > 0) {\n    const available = Array.from(found).join(', ') || '(none)'\n    throw new Error(`MISSING_ANCHORS: ${missing.join(', ')}. Found: ${available}`)\n  }\n}\n\n/**\n * Get anchor patterns for a given signature position\n *\n * NAMING CONVENTION:\n * - Database uses: party_a, party_a_2, party_a_3 (first is 'party_a', NOT 'party_a_1')\n * - Anchors match the database convention exactly\n *\n * WHICH PAGES EACH PARTY SIGNS:\n * - Subscribers (party_a*): Page 2 (form), Page 12 (main)\n * - Issuer (party_b): Page 2 (form), Page 3 (wire), Page 12 (main), Page 39 (T&Cs)\n * - Arranger (party_c): Page 12 (main), Page 39 (T&Cs)\n *\n * @param position - Database signature_position value\n * @returns Array of anchor patterns with their labels\n */\nfunction getAnchorPatternsForPosition(\n  position: string,\n  documentType: DocumentType = 'subscription'\n): { anchorId: string; label: string }[] {\n  if (documentType === 'introducer_agreement') {\n    return [\n      { anchorId: position, label: 'introducer_agreement' }\n    ]\n  }\n\n  // Subscribers sign on: Page 2 (form), Page 12 (main)\n  if (position.startsWith('party_a')) {\n    // position is 'party_a', 'party_a_2', 'party_a_3', etc.\n    // Anchors use SAME base: 'party_a', 'party_a_2', 'party_a_3'\n    const base = position\n    return [\n      { anchorId: `${base}_form`, label: 'subscription_form' },\n      { anchorId: base, label: 'main_agreement' }\n    ]\n  }\n\n  // Issuer signs on: Page 2 (form), Page 3 (wire), Page 12 (main), Page 39 (T&Cs)\n  if (position === 'party_b') {\n    return [\n      { anchorId: 'party_b_form', label: 'subscription_form' },\n      { anchorId: 'party_b_wire', label: 'wire_instructions' },\n      { anchorId: 'party_b', label: 'main_agreement' },\n      { anchorId: 'party_b_tcs', label: 'tcs' }\n    ]\n  }\n\n  // Arranger signs on: Page 12 (main), Page 39 (T&Cs)\n  if (position === 'party_c') {\n    return [\n      { anchorId: 'party_c', label: 'main_agreement' },\n      { anchorId: 'party_c_tcs', label: 'tcs' }\n    ]\n  }\n\n  console.warn(`‚ö†Ô∏è [ANCHOR] Unknown position: ${position}`)\n  return []\n}\n\n/**\n * Get fixed X position for signature based on party type and page label\n *\n * RATIONALE: The anchor's raw X coordinate represents where the anchor TEXT starts,\n * not where the signature should go. Since anchors are placed at the start of cells/blocks,\n * they always report X near the left margin. Instead, we use FIXED positions based on\n * the known column layout of the subscription pack template:\n *\n * COLUMN POSITIONS:\n * - Form page: Issuer left column, Subscriber right column\n * - Main agreement: All parties stacked on the left\n * - T&Cs: Issuer/Arranger centered on signature page\n *\n * @param signaturePosition - The database signature_position value (party_a, party_b, party_c)\n * @param label - The page/section label (subscription_form, main_agreement, etc.)\n * @returns X position as percentage of page width (0-1)\n */\nfunction getSignatureXPosition(\n  signaturePosition: string,\n  label: string,\n  documentType: DocumentType = 'subscription'\n): number {\n  // Party A (Subscribers): Right column on form page, stacked-left on main agreement\n  if (signaturePosition.startsWith('party_a')) {\n    if (label === 'subscription_form') return 0.63  // Right column (form table)\n    return 0.29  // Stacked left (main agreement)\n  }\n\n  // Party B (Issuer): Left on form/wire/main, centered on T&Cs signature page\n  if (signaturePosition === 'party_b') {\n    if (label === 'tcs') return 0.43\n    if (label === 'main_agreement') return 0.29\n    if (label === 'subscription_form') return 0.20\n    return 0.25\n  }\n\n  // Party C (Arranger): Stacked left on main, centered on T&Cs signature page\n  if (signaturePosition === 'party_c') {\n    if (label === 'tcs') return 0.43\n    return 0.29\n  }\n\n  return 0.29  // Default to stacked-left alignment\n}\n\n/**\n * Get signature Y position from the anchor position\n *\n * Anchors are now placed ON the signature line. This function shifts the signature\n * image ABOVE the line so that the metadata (timestamp + signer name) sits just\n * above the line and does not overlap Name/Title text below.\n *\n * @param anchor - Detected anchor with rawY (line position)\n * @param label - Page/section label (used for compact layout offsets)\n * @returns Signature Y position in points from bottom of page\n */\nfunction getSignatureYFromAnchor(\n  anchor: DetectedAnchor,\n  label: string,\n  documentType: DocumentType = 'subscription'\n): number {\n  const { metadata } = SIGNATURE_CONFIG.pdf\n\n  // Keep in sync with embedSignatureMultipleLocations() compact layout offsets\n  const compactSignerOffset = 14\n  const signerOffset = label === 'wire_instructions'\n    ? compactSignerOffset\n    : metadata.signerNameOffsetY\n\n  const lineGap = 4\n  return anchor.rawY + signerOffset + lineGap\n}\n\n/**\n * Convert detected anchors to signature placements for a specific signer\n *\n * This is the main function used during signature request creation to\n * calculate where signatures should be placed based on detected anchors.\n *\n * POSITIONING STRATEGY (v5 - ANCHOR-BASED Y):\n * - X: Uses FIXED column positions based on party type and page label\n * - Y: Uses anchor position + offset (anchor is on the signature line)\n *\n * WHY ANCHOR-BASED Y:\n * Anchors are placed directly on the signature line, so anchor.yFromBottom is the\n * line position. We then offset upward so the signature image sits above the line.\n *\n * X POSITIONING (VC215-aligned):\n * - Party A (Subscribers): 63% on form, 29% on main agreement\n * - Party B (Issuer): 20% on form, 25% on wire, 29% on main, 43% on T&Cs\n * - Party C (Arranger): 29% on main, 43% on T&Cs\n *\n * @param anchors - All detected anchors from PDF\n * @param signaturePosition - The signer's position (e.g., 'party_a', 'party_b')\n * @returns Array of placements for this signer\n */\nexport function getPlacementsFromAnchors(\n  anchors: DetectedAnchor[],\n  signaturePosition: string,\n  documentType: DocumentType = 'subscription'\n): SignaturePlacementRecord[] {\n  // Map signature positions to their anchor patterns\n  const anchorPatterns = getAnchorPatternsForPosition(signaturePosition, documentType)\n  const placements: SignaturePlacementRecord[] = []\n\n  console.log(`üìç [PLACEMENT] Calculating placements for ${signaturePosition} (${documentType}, anchor-based Y)...`)\n\n  for (const pattern of anchorPatterns) {\n    const anchor = anchors.find(a => a.anchorId === pattern.anchorId)\n    if (anchor) {\n      const fixedX = documentType === 'introducer_agreement'\n        ? anchor.xPercent\n        : getSignatureXPosition(signaturePosition, pattern.label, documentType)\n\n      // Get signature Y position based on anchor line + offset\n      const signatureY = getSignatureYFromAnchor(anchor, pattern.label, documentType)\n\n      // Debug logging\n      console.log(`   üîç [ANCHOR] ${pattern.anchorId} on page ${anchor.pageNumber}`)\n      console.log(`      Anchor position (for reference): (${anchor.rawX.toFixed(0)}pt, ${anchor.rawY.toFixed(0)}pt)`)\n      console.log(`   üìç [PLACEMENT] ${signaturePosition} -> page ${anchor.pageNumber}`)\n      console.log(`      FIXED X: ${(fixedX * 100).toFixed(0)}% | ANCHOR Y: ${signatureY.toFixed(0)}pt (${pattern.label})`)\n\n      placements.push({\n        page: anchor.pageNumber,\n        x: fixedX,  // FIXED X position based on party/page\n        y: signatureY,  // Anchor-based Y position\n        label: pattern.label\n      })\n\n      console.log(`   ‚úì ${pattern.anchorId} -> page ${anchor.pageNumber}, x=${(fixedX * 100).toFixed(0)}%, y=${signatureY.toFixed(0)}pt (${pattern.label})`)\n    } else {\n      console.warn(`   ‚ö†Ô∏è Anchor not found: ${pattern.anchorId} (expected for ${signaturePosition})`)\n    }\n  }\n\n  console.log(`‚úÖ [PLACEMENT] Created ${placements.length} placement(s) for ${signaturePosition}`)\n  return placements\n}\n\n/**\n * Get required anchors for a subscription pack based on signatory count\n *\n * @param subscriberCount - Number of investor signatories (1-10)\n * @returns Array of all anchor IDs that should be present in the PDF\n */\nexport function getRequiredAnchorsForSubscriptionPack(subscriberCount: number): string[] {\n  const required: string[] = []\n\n  // Subscriber anchors (party_a, party_a_2, party_a_3, ...)\n  for (let i = 1; i <= subscriberCount; i++) {\n    const base = i === 1 ? 'party_a' : `party_a_${i}`\n    required.push(`${base}_form`)   // Page 2\n    required.push(base)              // Page 12\n  }\n\n  // Issuer anchors (party_b)\n  required.push('party_b_form')  // Page 2\n  required.push('party_b_wire')  // Page 3\n  required.push('party_b')       // Page 12\n  required.push('party_b_tcs')   // Page 39\n\n  // Arranger anchors (party_c)\n  required.push('party_c')       // Page 12\n  required.push('party_c_tcs')   // Page 39\n\n  return required\n}\n\n/**\n * Get required anchors for an introducer agreement based on signatory count\n *\n * @param signatoryCount - Number of introducer signers\n * @returns Array of anchor IDs that should be present in the PDF\n */\nexport function getRequiredAnchorsForIntroducerAgreement(signatoryCount: number): string[] {\n  const required: string[] = ['party_a']\n\n  for (let i = 1; i <= signatoryCount; i++) {\n    const base = i === 1 ? 'party_b' : `party_b_${i}`\n    required.push(base)\n  }\n\n  return required\n}\n\n/**\n * Helper to generate anchor ID matching database convention\n * First subscriber is 'party_a', subsequent are 'party_a_2', 'party_a_3', etc.\n *\n * @param number - 1-based signatory number\n * @param suffix - Optional suffix like 'form'\n * @returns Anchor ID string\n */\nexport function getSignatoryAnchorId(number: number, suffix?: string): string {\n  const base = number === 1 ? 'party_a' : `party_a_${number}`\n  return suffix ? `${base}_${suffix}` : base\n}\n"],"names":[],"mappings":"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"}