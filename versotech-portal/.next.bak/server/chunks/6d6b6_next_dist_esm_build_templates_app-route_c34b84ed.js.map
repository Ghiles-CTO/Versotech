{"version":3,"sources":["../../../../versotech-portal/node_modules/next/dist/esm/build/templates/app-route.js","../../../../versotech-portal/src/app/api/subscriptions/%5Bid%5D/documents/%5BdocumentId%5D/ready-for-signature/route.ts"],"sourcesContent":["import { AppRouteRouteModule } from \"next/dist/esm/server/route-modules/app-route/module.compiled\";\nimport { RouteKind } from \"next/dist/esm/server/route-kind\";\nimport { patchFetch as _patchFetch } from \"next/dist/esm/server/lib/patch-fetch\";\nimport { addRequestMeta, getRequestMeta } from \"next/dist/esm/server/request-meta\";\nimport { getTracer, SpanKind } from \"next/dist/esm/server/lib/trace/tracer\";\nimport { setManifestsSingleton } from \"next/dist/esm/server/app-render/manifests-singleton\";\nimport { normalizeAppPath } from \"next/dist/esm/shared/lib/router/utils/app-paths\";\nimport { NodeNextRequest, NodeNextResponse } from \"next/dist/esm/server/base-http/node\";\nimport { NextRequestAdapter, signalFromNodeResponse } from \"next/dist/esm/server/web/spec-extension/adapters/next-request\";\nimport { BaseServerSpan } from \"next/dist/esm/server/lib/trace/constants\";\nimport { getRevalidateReason } from \"next/dist/esm/server/instrumentation/utils\";\nimport { sendResponse } from \"next/dist/esm/server/send-response\";\nimport { fromNodeOutgoingHttpHeaders, toNodeOutgoingHttpHeaders } from \"next/dist/esm/server/web/utils\";\nimport { getCacheControlHeader } from \"next/dist/esm/server/lib/cache-control\";\nimport { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from \"next/dist/esm/lib/constants\";\nimport { NoFallbackError } from \"next/dist/esm/shared/lib/no-fallback-error.external\";\nimport { CachedRouteKind } from \"next/dist/esm/server/response-cache\";\nimport * as userland from \"INNER_APP_ROUTE\";\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new AppRouteRouteModule({\n    definition: {\n        kind: RouteKind.APP_ROUTE,\n        page: \"/api/subscriptions/[id]/documents/[documentId]/ready-for-signature/route\",\n        pathname: \"/api/subscriptions/[id]/documents/[documentId]/ready-for-signature\",\n        filename: \"route\",\n        bundlePath: \"\"\n    },\n    distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n    relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n    resolvedPagePath: \"[project]/versotech-portal/src/app/api/subscriptions/[id]/documents/[documentId]/ready-for-signature/route.ts\",\n    nextConfigOutput,\n    userland\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return _patchFetch({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\nexport { routeModule, workAsyncStorage, workUnitAsyncStorage, serverHooks, patchFetch,  };\nexport async function handler(req, res, ctx) {\n    if (routeModule.isDev) {\n        addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint());\n    }\n    let srcPage = \"/api/subscriptions/[id]/documents/[documentId]/ready-for-signature/route\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (process.env.TURBOPACK) {\n        srcPage = srcPage.replace(/\\/index$/, '') || '/';\n    } else if (srcPage === '/index') {\n        // we always normalize /index specifically\n        srcPage = '/';\n    }\n    const multiZoneDraftMode = process.env.__NEXT_MULTI_ZONE_DRAFT_MODE;\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage,\n        multiZoneDraftMode\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return null;\n    }\n    const { buildId, params, nextConfig, parsedUrl, isDraftMode, prerenderManifest, routerServerContext, isOnDemandRevalidate, revalidateOnlyGenerated, resolvedPathname, clientReferenceManifest, serverActionsManifest } = prepareResult;\n    const normalizedSrcPage = normalizeAppPath(srcPage);\n    let isIsr = Boolean(prerenderManifest.dynamicRoutes[normalizedSrcPage] || prerenderManifest.routes[resolvedPathname]);\n    const render404 = async ()=>{\n        // TODO: should route-module itself handle rendering the 404\n        if (routerServerContext == null ? void 0 : routerServerContext.render404) {\n            await routerServerContext.render404(req, res, parsedUrl, false);\n        } else {\n            res.end('This page could not be found');\n        }\n        return null;\n    };\n    if (isIsr && !isDraftMode) {\n        const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname]);\n        const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage];\n        if (prerenderInfo) {\n            if (prerenderInfo.fallback === false && !isPrerendered) {\n                if (nextConfig.experimental.adapterPath) {\n                    return await render404();\n                }\n                throw new NoFallbackError();\n            }\n        }\n    }\n    let cacheKey = null;\n    if (isIsr && !routeModule.isDev && !isDraftMode) {\n        cacheKey = resolvedPathname;\n        // ensure /index and / is normalized to one key\n        cacheKey = cacheKey === '/index' ? '/' : cacheKey;\n    }\n    const supportsDynamicResponse = // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true || // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr;\n    // This is a revalidation request if the request is for a static\n    // page and it is not being resumed from a postponed render and\n    // it is not a dynamic RSC request then it is a revalidation\n    // request.\n    const isStaticGeneration = isIsr && !supportsDynamicResponse;\n    // Before rendering (which initializes component tree modules), we have to\n    // set the reference manifests to our global store so Server Action's\n    // encryption util can access to them at the top level of the page module.\n    if (serverActionsManifest && clientReferenceManifest) {\n        setManifestsSingleton({\n            page: srcPage,\n            clientReferenceManifest,\n            serverActionsManifest\n        });\n    }\n    const method = req.method || 'GET';\n    const tracer = getTracer();\n    const activeSpan = tracer.getActiveScopeSpan();\n    const context = {\n        params,\n        prerenderManifest,\n        renderOpts: {\n            experimental: {\n                authInterrupts: Boolean(nextConfig.experimental.authInterrupts)\n            },\n            cacheComponents: Boolean(nextConfig.cacheComponents),\n            supportsDynamicResponse,\n            incrementalCache: getRequestMeta(req, 'incrementalCache'),\n            cacheLifeProfiles: nextConfig.cacheLife,\n            waitUntil: ctx.waitUntil,\n            onClose: (cb)=>{\n                res.on('close', cb);\n            },\n            onAfterTaskError: undefined,\n            onInstrumentationRequestError: (error, _request, errorContext, silenceLog)=>routeModule.onRequestError(req, error, errorContext, silenceLog, routerServerContext)\n        },\n        sharedContext: {\n            buildId\n        }\n    };\n    const nodeNextReq = new NodeNextRequest(req);\n    const nodeNextRes = new NodeNextResponse(res);\n    const nextReq = NextRequestAdapter.fromNodeNextRequest(nodeNextReq, signalFromNodeResponse(res));\n    try {\n        const invokeRouteModule = async (span)=>{\n            return routeModule.handle(nextReq, context).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${srcPage}`);\n                }\n            });\n        };\n        const isMinimalMode = Boolean(process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode'));\n        const handleResponse = async (currentSpan)=>{\n            var _cacheEntry_value;\n            const responseGenerator = async ({ previousCacheEntry })=>{\n                try {\n                    if (!isMinimalMode && isOnDemandRevalidate && revalidateOnlyGenerated && !previousCacheEntry) {\n                        res.statusCode = 404;\n                        // on-demand revalidate always sets this header\n                        res.setHeader('x-nextjs-cache', 'REVALIDATED');\n                        res.end('This page could not be found');\n                        return null;\n                    }\n                    const response = await invokeRouteModule(currentSpan);\n                    req.fetchMetrics = context.renderOpts.fetchMetrics;\n                    let pendingWaitUntil = context.renderOpts.pendingWaitUntil;\n                    // Attempt using provided waitUntil if available\n                    // if it's not we fallback to sendResponse's handling\n                    if (pendingWaitUntil) {\n                        if (ctx.waitUntil) {\n                            ctx.waitUntil(pendingWaitUntil);\n                            pendingWaitUntil = undefined;\n                        }\n                    }\n                    const cacheTags = context.renderOpts.collectedTags;\n                    // If the request is for a static response, we can cache it so long\n                    // as it's not edge.\n                    if (isIsr) {\n                        const blob = await response.blob();\n                        // Copy the headers from the response.\n                        const headers = toNodeOutgoingHttpHeaders(response.headers);\n                        if (cacheTags) {\n                            headers[NEXT_CACHE_TAGS_HEADER] = cacheTags;\n                        }\n                        if (!headers['content-type'] && blob.type) {\n                            headers['content-type'] = blob.type;\n                        }\n                        const revalidate = typeof context.renderOpts.collectedRevalidate === 'undefined' || context.renderOpts.collectedRevalidate >= INFINITE_CACHE ? false : context.renderOpts.collectedRevalidate;\n                        const expire = typeof context.renderOpts.collectedExpire === 'undefined' || context.renderOpts.collectedExpire >= INFINITE_CACHE ? undefined : context.renderOpts.collectedExpire;\n                        // Create the cache entry for the response.\n                        const cacheEntry = {\n                            value: {\n                                kind: CachedRouteKind.APP_ROUTE,\n                                status: response.status,\n                                body: Buffer.from(await blob.arrayBuffer()),\n                                headers\n                            },\n                            cacheControl: {\n                                revalidate,\n                                expire\n                            }\n                        };\n                        return cacheEntry;\n                    } else {\n                        // send response without caching if not ISR\n                        await sendResponse(nodeNextReq, nodeNextRes, response, context.renderOpts.pendingWaitUntil);\n                        return null;\n                    }\n                } catch (err) {\n                    // if this is a background revalidate we need to report\n                    // the request error here as it won't be bubbled\n                    if (previousCacheEntry == null ? void 0 : previousCacheEntry.isStale) {\n                        const silenceLog = false;\n                        await routeModule.onRequestError(req, err, {\n                            routerKind: 'App Router',\n                            routePath: srcPage,\n                            routeType: 'route',\n                            revalidateReason: getRevalidateReason({\n                                isStaticGeneration,\n                                isOnDemandRevalidate\n                            })\n                        }, silenceLog, routerServerContext);\n                    }\n                    throw err;\n                }\n            };\n            const cacheEntry = await routeModule.handleResponse({\n                req,\n                nextConfig,\n                cacheKey,\n                routeKind: RouteKind.APP_ROUTE,\n                isFallback: false,\n                prerenderManifest,\n                isRoutePPREnabled: false,\n                isOnDemandRevalidate,\n                revalidateOnlyGenerated,\n                responseGenerator,\n                waitUntil: ctx.waitUntil,\n                isMinimalMode\n            });\n            // we don't create a cacheEntry for ISR\n            if (!isIsr) {\n                return null;\n            }\n            if ((cacheEntry == null ? void 0 : (_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== CachedRouteKind.APP_ROUTE) {\n                var _cacheEntry_value1;\n                throw Object.defineProperty(new Error(`Invariant: app-route received invalid cache entry ${cacheEntry == null ? void 0 : (_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E701\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            if (!isMinimalMode) {\n                res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT');\n            }\n            // Draft mode should never be cached\n            if (isDraftMode) {\n                res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\n            }\n            const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers);\n            if (!(isMinimalMode && isIsr)) {\n                headers.delete(NEXT_CACHE_TAGS_HEADER);\n            }\n            // If cache control is already set on the response we don't\n            // override it to allow users to customize it via next.config\n            if (cacheEntry.cacheControl && !res.getHeader('Cache-Control') && !headers.get('Cache-Control')) {\n                headers.set('Cache-Control', getCacheControlHeader(cacheEntry.cacheControl));\n            }\n            await sendResponse(nodeNextReq, nodeNextRes, // @ts-expect-error - Argument of type 'Buffer<ArrayBufferLike>' is not assignable to parameter of type 'BodyInit | null | undefined'.\n            new Response(cacheEntry.value.body, {\n                headers,\n                status: cacheEntry.value.status || 200\n            }));\n            return null;\n        };\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await handleResponse(activeSpan);\n        } else {\n            await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${srcPage}`,\n                    kind: SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, handleResponse));\n        }\n    } catch (err) {\n        if (!(err instanceof NoFallbackError)) {\n            const silenceLog = false;\n            await routeModule.onRequestError(req, err, {\n                routerKind: 'App Router',\n                routePath: normalizedSrcPage,\n                routeType: 'route',\n                revalidateReason: getRevalidateReason({\n                    isStaticGeneration,\n                    isOnDemandRevalidate\n                })\n            }, silenceLog, routerServerContext);\n        }\n        // rethrow so that we can handle serving error page\n        // If this is during static generation, throw the error again.\n        if (isIsr) throw err;\n        // Otherwise, send a 500 response.\n        await sendResponse(nodeNextReq, nodeNextRes, new Response(null, {\n            status: 500\n        }));\n        return null;\n    }\n}\n\n//# sourceMappingURL=app-route.js.map\n","import { NextRequest, NextResponse } from 'next/server'\r\nimport { createClient, createServiceClient } from '@/lib/supabase/server'\r\nimport { z } from 'zod'\r\nimport { getCeoSigner } from '@/lib/staff/ceo-signer'\r\nimport { convertDocxToPdf } from '@/lib/gotenberg/convert'\r\n\r\n// Schema for multi-signatory support with optional arranger countersigning\r\nconst requestSchema = z.object({\r\n  signatory_member_ids: z.array(z.string().uuid()).optional(),\r\n  // If no signatory_member_ids provided, falls back to investor email (backwards compatible)\r\n  countersigner_type: z.enum(['ceo', 'arranger']).optional().default('ceo'),\r\n  arranger_id: z.string().uuid().optional(),\r\n  // arranger_id is required when countersigner_type is 'arranger'\r\n}).optional()\r\n\r\nexport async function POST(\r\n  request: NextRequest,\r\n  { params }: { params: Promise<{ id: string; documentId: string }> }\r\n) {\r\n  const { id: subscriptionId, documentId } = await params\r\n\r\n  const clientSupabase = await createClient()\r\n  const { data: { user }, error: authError } = await clientSupabase.auth.getUser()\r\n\r\n  if (authError || !user) {\r\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\r\n  }\r\n\r\n  // Verify staff access\r\n  const { data: profile } = await clientSupabase\r\n    .from('profiles')\r\n    .select('role, display_name, email')\r\n    .eq('id', user.id)\r\n    .single()\r\n\r\n  const isStaff = profile?.role?.startsWith('staff_') || profile?.role === 'ceo'\r\n  if (!isStaff) {\r\n    return NextResponse.json({ error: 'Staff access required' }, { status: 403 })\r\n  }\r\n\r\n  // Parse request body for signatory selection\r\n  let body: { signatory_member_ids?: string[]; countersigner_type?: 'ceo' | 'arranger'; arranger_id?: string } = {}\r\n  try {\r\n    const rawBody = await request.text()\r\n    if (rawBody) {\r\n      body = JSON.parse(rawBody)\r\n      const validation = requestSchema.safeParse(body)\r\n      if (!validation.success) {\r\n        return NextResponse.json({ error: 'Invalid request body' }, { status: 400 })\r\n      }\r\n    }\r\n  } catch {\r\n    // Empty body is OK - use default behavior\r\n  }\r\n\r\n  // Note: arranger_id validation is only needed for legacy documents without stored countersigner\r\n  // New documents have countersigner info stored at generation time\r\n\r\n  const serviceSupabase = createServiceClient()\r\n\r\n  // Get document and subscription details\r\n  const { data: document } = await serviceSupabase\r\n    .from('documents')\r\n    .select('*')\r\n    .eq('id', documentId)\r\n    .eq('subscription_id', subscriptionId)\r\n    .single()\r\n\r\n  if (!document) {\r\n    return NextResponse.json({ error: 'Document not found' }, { status: 404 })\r\n  }\r\n\r\n  // Check if document is DOCX - if so, convert to PDF first\r\n  // If already PDF, use directly (no conversion needed!)\r\n  const isDocx = document.mime_type?.includes('wordprocessingml') ||\r\n                 document.mime_type?.includes('msword') ||\r\n                 document.file_key?.toLowerCase().endsWith('.docx') ||\r\n                 document.file_key?.toLowerCase().endsWith('.doc')\r\n\r\n  const isPdf = document.mime_type === 'application/pdf' ||\r\n                document.file_key?.toLowerCase().endsWith('.pdf')\r\n\r\n  let signableDocument = document\r\n  let signableDocumentId = documentId\r\n\r\n  if (isPdf) {\r\n    console.log('‚úÖ [READY-FOR-SIGNATURE] Document is already PDF, skipping conversion')\r\n  } else if (isDocx) {\r\n    console.log('üìÑ [READY-FOR-SIGNATURE] DOCX detected, converting to PDF via Gotenberg')\r\n\r\n    // Download the DOCX from storage\r\n    const { data: docxData, error: downloadError } = await serviceSupabase.storage\r\n      .from('deal-documents')\r\n      .download(document.file_key)\r\n\r\n    if (downloadError || !docxData) {\r\n      console.error('‚ùå Failed to download DOCX for conversion:', downloadError)\r\n      return NextResponse.json({\r\n        error: 'Failed to download document for conversion',\r\n        details: downloadError?.message\r\n      }, { status: 500 })\r\n    }\r\n\r\n    // Convert to Buffer\r\n    const docxBuffer = Buffer.from(await docxData.arrayBuffer())\r\n    console.log('üì• Downloaded DOCX:', { size: docxBuffer.length })\r\n\r\n    // Convert to PDF via Gotenberg\r\n    // Ensure filename has .docx extension (Gotenberg requires it)\r\n    let docxFilename = document.name || 'document.docx'\r\n    if (!docxFilename.toLowerCase().endsWith('.docx') && !docxFilename.toLowerCase().endsWith('.doc')) {\r\n      docxFilename = `${docxFilename}.docx`\r\n    }\r\n    const conversionResult = await convertDocxToPdf(docxBuffer, docxFilename)\r\n\r\n    if (!conversionResult.success || !conversionResult.pdfBuffer) {\r\n      console.error('‚ùå Gotenberg conversion failed:', conversionResult.error)\r\n      return NextResponse.json({\r\n        error: 'Failed to convert DOCX to PDF',\r\n        details: conversionResult.error || 'Conversion service unavailable'\r\n      }, { status: 500 })\r\n    }\r\n\r\n    console.log('‚úÖ DOCX converted to PDF:', {\r\n      input_size: docxBuffer.length,\r\n      output_size: conversionResult.pdfBuffer.length\r\n    })\r\n\r\n    // Upload the PDF to storage\r\n    const pdfFileName = document.file_key.replace(/\\.(docx?|DOCX?)$/, '.pdf')\r\n    const pdfFileKey = pdfFileName.includes('/converted/')\r\n      ? pdfFileName\r\n      : pdfFileName.replace(/\\/([^/]+)$/, '/converted/$1')\r\n\r\n    const { error: uploadError } = await serviceSupabase.storage\r\n      .from('deal-documents')\r\n      .upload(pdfFileKey, conversionResult.pdfBuffer, {\r\n        contentType: 'application/pdf',\r\n        upsert: true\r\n      })\r\n\r\n    if (uploadError) {\r\n      console.error('‚ùå Failed to upload converted PDF:', uploadError)\r\n      return NextResponse.json({\r\n        error: 'Failed to save converted PDF',\r\n        details: uploadError.message\r\n      }, { status: 500 })\r\n    }\r\n\r\n    console.log('üì§ Uploaded converted PDF:', pdfFileKey)\r\n\r\n    // Create a new document record for the PDF\r\n    const pdfDocName = (document.name || 'Document').replace(/\\.(docx?|DOCX?)$/i, '.pdf')\r\n    const { data: pdfDocument, error: pdfDocError } = await serviceSupabase\r\n      .from('documents')\r\n      .insert({\r\n        subscription_id: subscriptionId,\r\n        deal_id: document.deal_id,\r\n        vehicle_id: document.vehicle_id,\r\n        folder_id: document.folder_id,\r\n        type: 'subscription_pack',\r\n        name: pdfDocName,\r\n        file_key: pdfFileKey,\r\n        mime_type: 'application/pdf',\r\n        file_size_bytes: conversionResult.pdfBuffer.length,\r\n        status: 'final',\r\n        ready_for_signature: false,\r\n        current_version: 1,\r\n        created_by: user.id\r\n      })\r\n      .select()\r\n      .single()\r\n\r\n    if (pdfDocError || !pdfDocument) {\r\n      console.error('‚ùå Failed to create PDF document record:', pdfDocError)\r\n      return NextResponse.json({\r\n        error: 'Failed to create document record for converted PDF',\r\n        details: pdfDocError?.message\r\n      }, { status: 500 })\r\n    }\r\n\r\n    console.log('‚úÖ Created PDF document record:', pdfDocument.id)\r\n\r\n    // Update the original DOCX document status to indicate it has been converted\r\n    await serviceSupabase\r\n      .from('documents')\r\n      .update({\r\n        status: 'draft',\r\n        metadata: { converted_to_pdf: pdfDocument.id, converted_at: new Date().toISOString() }\r\n      })\r\n      .eq('id', document.id)\r\n\r\n    // Use the new PDF document for signature\r\n    signableDocument = pdfDocument\r\n    signableDocumentId = pdfDocument.id\r\n\r\n    console.log('üîÑ Proceeding with converted PDF for signature:', {\r\n      original_docx_id: document.id,\r\n      new_pdf_id: pdfDocument.id\r\n    })\r\n  } else if (document.mime_type && !document.mime_type.includes('pdf')) {\r\n    // Not DOCX and not PDF - unsupported format\r\n    return NextResponse.json({\r\n      error: 'Unsupported file format. Only PDF and DOCX files can be sent for signature.',\r\n      details: `Current file type: ${document.mime_type}`\r\n    }, { status: 400 })\r\n  }\r\n\r\n  // Get subscription with investor details including user_id from join table\r\n  console.log('üîç [READY-FOR-SIGNATURE] Fetching subscription...')\r\n  const { data: subscription } = await serviceSupabase\r\n    .from('subscriptions')\r\n    .select(`\r\n      *,\r\n      investor:investors(\r\n        id,\r\n        type,\r\n        legal_name,\r\n        display_name,\r\n        email,\r\n        investor_users!inner(user_id)\r\n      ),\r\n      vehicle:vehicles(id, name)\r\n    `)\r\n    .eq('id', subscriptionId)\r\n    .single()\r\n\r\n  if (!subscription) {\r\n    return NextResponse.json({ error: 'Subscription not found' }, { status: 404 })\r\n  }\r\n  console.log('‚úÖ [READY-FOR-SIGNATURE] Subscription fetched:', { investor_type: subscription.investor?.type })\r\n\r\n  // Check for existing signature requests to prevent duplicates\r\n  console.log('üîç [READY-FOR-SIGNATURE] Checking existing requests...')\r\n  const { data: existingRequests } = await serviceSupabase\r\n    .from('signature_requests')\r\n    .select('id, signer_role, status')\r\n    .eq('document_id', signableDocumentId)\r\n    .in('status', ['pending', 'signed'])\r\n\r\n  if (existingRequests && existingRequests.length > 0) {\r\n    const pendingCount = existingRequests.filter(r => r.status === 'pending').length\r\n    const signedCount = existingRequests.filter(r => r.status === 'signed').length\r\n\r\n    return NextResponse.json({\r\n      error: 'Signature requests already exist for this document',\r\n      details: `Found ${pendingCount} pending and ${signedCount} signed signature request(s). Cannot create duplicates.`,\r\n      existing_requests: existingRequests.map(r => ({ id: r.id, role: r.signer_role, status: r.status }))\r\n    }, { status: 409 }) // 409 Conflict\r\n  }\r\n\r\n  console.log('‚úÖ [READY-FOR-SIGNATURE] No existing requests, proceeding...')\r\n\r\n  // Get signed URL for document (use the signable PDF)\r\n  const { data: urlData } = await serviceSupabase.storage\r\n    .from('deal-documents')\r\n    .createSignedUrl(signableDocument.file_key, 7 * 24 * 60 * 60) // 7 days\r\n\r\n  if (!urlData?.signedUrl) {\r\n    return NextResponse.json({ error: 'Failed to generate document URL' }, { status: 500 })\r\n  }\r\n\r\n  console.log('‚úÖ [READY-FOR-SIGNATURE] Got signed URL')\r\n\r\n  // Determine signatories\r\n  console.log('üîç [READY-FOR-SIGNATURE] Determining signatories...')\r\n  type Signatory = { id: string; full_name: string; email: string }\r\n  let signatories: Signatory[] = []\r\n\r\n  if (body.signatory_member_ids && body.signatory_member_ids.length > 0) {\r\n    // Multi-signatory mode: fetch selected members\r\n    const { data: members, error: membersError } = await serviceSupabase\r\n      .from('investor_members')\r\n      .select('id, full_name, email')\r\n      .in('id', body.signatory_member_ids)\r\n      .eq('investor_id', subscription.investor_id)\r\n      .eq('is_active', true)\r\n\r\n    if (membersError || !members || members.length === 0) {\r\n      return NextResponse.json({\r\n        error: 'Selected signatories not found',\r\n        details: 'Could not find the specified signatory members'\r\n      }, { status: 400 })\r\n    }\r\n\r\n    signatories = members.map(m => ({\r\n      id: m.id,\r\n      full_name: m.full_name,\r\n      email: m.email\r\n    }))\r\n  } else {\r\n    // Check if investor is entity type - auto-fetch signatories from investor_members\r\n    const isEntityInvestor = subscription.investor.type === 'entity' ||\r\n                             subscription.investor.type === 'institutional'\r\n\r\n    if (isEntityInvestor) {\r\n      // Fetch authorized signatories for entity investor\r\n      const { data: entityMembers } = await serviceSupabase\r\n        .from('investor_members')\r\n        .select('id, full_name, email')\r\n        .eq('investor_id', subscription.investor_id)\r\n        .eq('is_signatory', true)\r\n        .eq('is_active', true)\r\n\r\n      if (entityMembers && entityMembers.length > 0) {\r\n        signatories = entityMembers.map(m => ({\r\n          id: m.id,\r\n          full_name: m.full_name,\r\n          email: m.email\r\n        }))\r\n        console.log(`üë• [READY-FOR-SIGNATURE] Auto-fetched ${signatories.length} signatories for entity investor`)\r\n      } else {\r\n        // Entity but no signatories marked - fall back to investor name\r\n        console.warn('[READY-FOR-SIGNATURE] Entity investor has no signatories marked, using investor name')\r\n        signatories = [{\r\n          id: 'investor_primary',\r\n          full_name: subscription.investor.legal_name || subscription.investor.display_name,\r\n          email: subscription.investor.email\r\n        }]\r\n      }\r\n    } else {\r\n      // Individual investor: use investor's primary email\r\n      signatories = [{\r\n        id: 'investor_primary',\r\n        full_name: subscription.investor.legal_name || subscription.investor.display_name,\r\n        email: subscription.investor.email\r\n      }]\r\n    }\r\n  }\r\n\r\n  // Create signature requests - COMPANY SIGNS FIRST, then investors\r\n  // This ensures the company (arranger/CEO) approves the document before investors sign\r\n  console.log('‚úÖ [READY-FOR-SIGNATURE] Signatories determined:', signatories.length)\r\n  try {\r\n    // ============================================================\r\n    // STEP 1: CREATE ISSUER (party_b) SIGNATURE REQUEST\r\n    // ============================================================\r\n    // The Issuer (VERSO Capital 2 SCSP via GP SARL) ALWAYS signs as party_b\r\n    // This is separate from the Arranger (party_c) which is handled in STEP 1.5\r\n    //\r\n    // IMPORTANT: countersigner_type only affects WORKFLOW ORDER, not signature positions!\r\n    // - countersigner_type='ceo': CEO signs first, then arranger, then investors\r\n    // - countersigner_type='arranger': Arranger signs first, then CEO, then investors\r\n    // Both CEO and Arranger ALWAYS sign, just in different order.\r\n    console.log('üîç [READY-FOR-SIGNATURE] Creating ISSUER (party_b) signature request...')\r\n\r\n    // ALWAYS get CEO/Issuer signer - they sign party_b regardless of countersigner_type\r\n    const ceoSigner = await getCeoSigner(serviceSupabase)\r\n\r\n    if (!ceoSigner || !ceoSigner.email) {\r\n      console.error('[ready-for-signature] CRITICAL: No CEO signer configured in ceo_users table')\r\n      return NextResponse.json({\r\n        error: 'No CEO/Issuer signer configured. Please add a CEO user with can_sign=true in the CEO settings.'\r\n      }, { status: 400 })\r\n    }\r\n\r\n    const issuerEmail = ceoSigner.email\r\n    const issuerName = ceoSigner.displayName\r\n\r\n    console.log('[ready-for-signature] Using configured CEO/Issuer signer for party_b:', {\r\n      email: issuerEmail,\r\n      name: issuerName\r\n    })\r\n\r\n    // Create Issuer (party_b) signature request\r\n    console.log(`üîç [READY-FOR-SIGNATURE] Creating ISSUER signature request for ${issuerName} (party_b)`)\r\n    const issuerSigPayload = {\r\n      investor_id: subscription.investor_id,\r\n      signer_email: issuerEmail,\r\n      signer_name: issuerName,\r\n      document_type: 'subscription',\r\n      google_drive_url: urlData.signedUrl,\r\n      signer_role: 'admin',  // CEO/Issuer is always 'admin' role\r\n      signature_position: 'party_b',  // ALWAYS party_b for Issuer\r\n      subscription_id: subscriptionId,\r\n      document_id: signableDocumentId,\r\n      deal_id: subscription.deal_id\r\n    }\r\n\r\n    const issuerSigResponse = await fetch(`${process.env.NEXT_PUBLIC_APP_URL}/api/signature/request`, {\r\n      method: 'POST',\r\n      headers: { 'Content-Type': 'application/json' },\r\n      body: JSON.stringify(issuerSigPayload)\r\n    })\r\n\r\n    if (!issuerSigResponse.ok) {\r\n      const errorText = await issuerSigResponse.text()\r\n      throw new Error(`Failed to create Issuer (party_b) signature request: ${errorText}`)\r\n    }\r\n\r\n    const issuerSigData = await issuerSigResponse.json()\r\n    console.log('‚úÖ [READY-FOR-SIGNATURE] Issuer (party_b) signature request created')\r\n\r\n    // ============================================================\r\n    // STEP 1.5: CREATE ARRANGER (party_c) SIGNATURE REQUEST\r\n    // ============================================================\r\n    // The arranger signs separately from the issuer on pages 12 and 39\r\n    // This is required because the legal document has THREE parties:\r\n    // - party_a: Subscribers (investors)\r\n    // - party_b: Issuer (VERSO Capital 2 SCSP)\r\n    // - party_c: Arranger (Verso Management Ltd.)\r\n    console.log('üîç [READY-FOR-SIGNATURE] Creating arranger (party_c) signature request...')\r\n    console.log('   Deal ID:', subscription.deal_id)\r\n\r\n    let arrangerSigData = null\r\n\r\n    // Get arranger details from the deal\r\n    const { data: dealForArranger, error: dealError } = await serviceSupabase\r\n      .from('deals')\r\n      .select('arranger_entity_id')\r\n      .eq('id', subscription.deal_id)\r\n      .single()\r\n\r\n    if (dealError) {\r\n      console.error('‚ùå [READY-FOR-SIGNATURE] Failed to fetch deal for arranger:', dealError.message)\r\n    }\r\n\r\n    console.log('   Arranger entity ID:', dealForArranger?.arranger_entity_id || 'NOT SET')\r\n\r\n    if (dealForArranger?.arranger_entity_id) {\r\n      // Get arranger entity and primary user who can sign\r\n      const { data: arrangerEntity, error: entityError } = await serviceSupabase\r\n        .from('arranger_entities')\r\n        .select('legal_name')\r\n        .eq('id', dealForArranger.arranger_entity_id)\r\n        .single()\r\n\r\n      if (entityError) {\r\n        console.error('‚ùå [READY-FOR-SIGNATURE] Failed to fetch arranger entity:', entityError.message)\r\n      }\r\n      console.log('   Arranger entity name:', arrangerEntity?.legal_name || 'NOT FOUND')\r\n\r\n      // Get primary arranger user who can sign (use maybeSingle to avoid error on no results)\r\n      const { data: arrangerUser, error: userError } = await serviceSupabase\r\n        .from('arranger_users')\r\n        .select('user_id')\r\n        .eq('arranger_id', dealForArranger.arranger_entity_id)\r\n        .eq('can_sign', true)\r\n        .eq('is_primary', true)\r\n        .maybeSingle()\r\n\r\n      if (userError) {\r\n        console.error('‚ùå [READY-FOR-SIGNATURE] Failed to fetch primary arranger user:', userError.message)\r\n      }\r\n      console.log('   Primary arranger user_id:', arrangerUser?.user_id || 'NOT FOUND')\r\n\r\n      // Fallback: get any arranger user who can sign\r\n      let arrangerUserId = arrangerUser?.user_id\r\n      if (!arrangerUserId) {\r\n        console.log('   Looking for fallback arranger user with can_sign=true...')\r\n        const { data: anySigningUser, error: fallbackError } = await serviceSupabase\r\n          .from('arranger_users')\r\n          .select('user_id')\r\n          .eq('arranger_id', dealForArranger.arranger_entity_id)\r\n          .eq('can_sign', true)\r\n          .limit(1)\r\n          .maybeSingle()\r\n\r\n        if (fallbackError) {\r\n          console.error('‚ùå [READY-FOR-SIGNATURE] Failed to fetch fallback arranger user:', fallbackError.message)\r\n        }\r\n        arrangerUserId = anySigningUser?.user_id\r\n        console.log('   Fallback arranger user_id:', arrangerUserId || 'NOT FOUND')\r\n      }\r\n\r\n      if (arrangerUserId) {\r\n        const { data: arrangerProfile, error: profileError } = await serviceSupabase\r\n          .from('profiles')\r\n          .select('email, display_name')\r\n          .eq('id', arrangerUserId)\r\n          .single()\r\n\r\n        if (profileError) {\r\n          console.error('‚ùå [READY-FOR-SIGNATURE] Failed to fetch arranger profile:', profileError.message)\r\n        }\r\n        console.log('   Arranger profile:', arrangerProfile?.email, arrangerProfile?.display_name)\r\n\r\n        if (arrangerProfile?.email) {\r\n          const arrangerSigPayload = {\r\n            investor_id: subscription.investor_id,\r\n            signer_email: arrangerProfile.email,\r\n            signer_name: arrangerProfile.display_name || arrangerEntity?.legal_name || 'Arranger',\r\n            document_type: 'subscription',\r\n            google_drive_url: urlData.signedUrl,\r\n            signer_role: 'arranger',\r\n            signature_position: 'party_c',  // KEY: Use party_c for arranger, NOT party_b!\r\n            subscription_id: subscriptionId,\r\n            document_id: signableDocumentId,\r\n            deal_id: subscription.deal_id\r\n          }\r\n\r\n          console.log('   Creating arranger signature request for:', arrangerProfile.email)\r\n\r\n          const arrangerSigResponse = await fetch(`${process.env.NEXT_PUBLIC_APP_URL}/api/signature/request`, {\r\n            method: 'POST',\r\n            headers: { 'Content-Type': 'application/json' },\r\n            body: JSON.stringify(arrangerSigPayload)\r\n          })\r\n\r\n          if (arrangerSigResponse.ok) {\r\n            arrangerSigData = await arrangerSigResponse.json()\r\n            console.log('‚úÖ [READY-FOR-SIGNATURE] Arranger (party_c) signature request created:', arrangerSigData.signature_request_id)\r\n          } else {\r\n            const errorText = await arrangerSigResponse.text()\r\n            console.error('‚ùå [READY-FOR-SIGNATURE] Failed to create arranger signature request:', errorText)\r\n            // FATAL: Arranger signature is required - fail the entire request\r\n            return NextResponse.json({\r\n              error: 'Failed to create arranger signature request',\r\n              details: errorText\r\n            }, { status: 500 })\r\n          }\r\n        } else {\r\n          // FATAL: Arranger must have email configured\r\n          console.error('‚ùå [READY-FOR-SIGNATURE] FATAL: Arranger user has no email configured')\r\n          return NextResponse.json({\r\n            error: `Arranger user for ${arrangerEntity?.legal_name || 'arranger entity'} has no email configured. Please update the arranger user's profile.`\r\n          }, { status: 400 })\r\n        }\r\n      } else {\r\n        // FATAL: Arranger must have a signer configured\r\n        console.error('‚ùå [READY-FOR-SIGNATURE] FATAL: No arranger user with can_sign=true found for arranger_id:', dealForArranger.arranger_entity_id)\r\n        return NextResponse.json({\r\n          error: `No arranger signer configured for ${arrangerEntity?.legal_name || 'arranger entity'}. Please configure an arranger user with can_sign=true.`\r\n        }, { status: 400 })\r\n      }\r\n    } else {\r\n      // FATAL: Deal must have an arranger entity for subscription pack signatures\r\n      console.error('‚ùå [READY-FOR-SIGNATURE] FATAL: No arranger entity linked to deal:', subscription.deal_id)\r\n      return NextResponse.json({\r\n        error: 'No arranger entity linked to this deal. Subscription packs require an arranger to sign as party_c. Please link an arranger entity to the deal.'\r\n      }, { status: 400 })\r\n    }\r\n\r\n    // ============================================================\r\n    // STEP 2: CREATE INVESTOR SIGNATURE REQUESTS (AFTER COMPANY)\r\n    // ============================================================\r\n    // Investors will sign after the company has signed\r\n    console.log('üîç [READY-FOR-SIGNATURE] Creating investor signature requests (they sign AFTER company)...')\r\n    const signerPositions = ['party_a', 'party_a_2', 'party_a_3', 'party_a_4', 'party_a_5']\r\n    const investorSignatureRequests = []\r\n\r\n    for (let i = 0; i < signatories.length; i++) {\r\n      const signatory = signatories[i]\r\n      const position = signerPositions[i] || `party_a_${i + 1}`\r\n      console.log(`üîç [READY-FOR-SIGNATURE] Creating investor signature ${i + 1}/${signatories.length} for ${signatory.full_name}`)\r\n\r\n      const investorSigPayload = {\r\n        investor_id: subscription.investor_id,\r\n        signer_email: signatory.email,\r\n        signer_name: signatory.full_name,\r\n        document_type: 'subscription',\r\n        google_drive_url: urlData.signedUrl,\r\n        signer_role: 'investor',\r\n        signature_position: position,\r\n        subscription_id: subscriptionId,\r\n        document_id: signableDocumentId,\r\n        deal_id: subscription.deal_id, // For task context (deal name, amount)\r\n        member_id: signatory.id !== 'investor_primary' ? signatory.id : undefined,\r\n        total_party_a_signatories: signatories.length // For multi-signatory positioning\r\n      }\r\n\r\n      const investorSigResponse = await fetch(`${process.env.NEXT_PUBLIC_APP_URL}/api/signature/request`, {\r\n        method: 'POST',\r\n        headers: { 'Content-Type': 'application/json' },\r\n        body: JSON.stringify(investorSigPayload)\r\n      })\r\n\r\n      if (!investorSigResponse.ok) {\r\n        const errorText = await investorSigResponse.text()\r\n        throw new Error(`Failed to create investor signature request for ${signatory.full_name}: ${errorText}`)\r\n      }\r\n\r\n      const investorSigData = await investorSigResponse.json()\r\n      investorSignatureRequests.push({\r\n        signatory: signatory.full_name,\r\n        email: signatory.email,\r\n        ...investorSigData\r\n      })\r\n    }\r\n\r\n    console.log('‚úÖ [READY-FOR-SIGNATURE] All investor signatures created')\r\n\r\n    // Update document status (update the signable PDF document)\r\n    await serviceSupabase\r\n      .from('documents')\r\n      .update({\r\n        ready_for_signature: true,\r\n        status: 'pending_signature',\r\n        signature_status: 'pending'  // Track signature collection progress\r\n      })\r\n      .eq('id', signableDocumentId)\r\n\r\n    const now = new Date().toISOString()\r\n    await serviceSupabase\r\n      .from('subscriptions')\r\n      .update({ pack_sent_at: now })\r\n      .eq('id', subscriptionId)\r\n      .is('pack_sent_at', null)\r\n    await serviceSupabase\r\n      .from('subscriptions')\r\n      .update({ pack_generated_at: now })\r\n      .eq('id', subscriptionId)\r\n      .is('pack_generated_at', null)\r\n\r\n    // Notify arranger users when pack is sent for signature\r\n    if (subscription.deal_id) {\r\n      const { data: deal } = await serviceSupabase\r\n        .from('deals')\r\n        .select('arranger_entity_id, name')\r\n        .eq('id', subscription.deal_id)\r\n        .single()\r\n\r\n      if (deal?.arranger_entity_id) {\r\n        const { data: arrangerUsers } = await serviceSupabase\r\n          .from('arranger_users')\r\n          .select('user_id')\r\n          .eq('arranger_id', deal.arranger_entity_id)\r\n\r\n        if (arrangerUsers && arrangerUsers.length > 0) {\r\n          const investorName = subscription.investor?.display_name || subscription.investor?.legal_name || 'Investor'\r\n          const dealName = deal.name || 'the deal'\r\n\r\n          const notifications = arrangerUsers.map((au: { user_id: string }) => ({\r\n            user_id: au.user_id,\r\n            investor_id: null,\r\n            title: 'Subscription Pack Sent',\r\n            message: `Subscription pack for ${investorName} (${dealName}) has been sent for signature.`,\r\n            link: '/versotech_main/versosign'\r\n          }))\r\n\r\n          await serviceSupabase.from('investor_notifications').insert(notifications)\r\n          console.log('üìß Notified arranger users about pack sent:', arrangerUsers.length)\r\n        }\r\n      }\r\n    }\r\n\r\n    console.log('‚úÖ Multi-signatory signature requests created for subscription pack:', {\r\n      document_id: signableDocumentId,\r\n      investor_requests: investorSignatureRequests.length,\r\n      issuer_request: issuerSigData.signature_request_id,\r\n      arranger_request: arrangerSigData?.signature_request_id || null\r\n    })\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      investor_signature_requests: investorSignatureRequests,\r\n      // NEW: Separate issuer (party_b) and arranger (party_c) requests\r\n      issuer_request: issuerSigData,        // party_b - VERSO Capital 2 SCSP (via GP SARL)\r\n      issuer_name: issuerName,\r\n      arranger_request: arrangerSigData,    // party_c - Verso Management Ltd.\r\n      // BACKWARDS COMPATIBLE: countersigner fields for existing UI consumers\r\n      // The \"countersigner\" is now always the CEO (party_b), not the arranger\r\n      countersigner_request: issuerSigData,\r\n      countersigner_type: 'ceo' as const,   // Always 'ceo' - party_b is always CEO/Issuer\r\n      countersigner_name: issuerName,\r\n      total_signatories: signatories.length + 1 + (arrangerSigData ? 1 : 0) // investors + issuer + arranger\r\n    })\r\n\r\n  } catch (error) {\r\n    console.error('Error creating signature requests:', error)\r\n    return NextResponse.json({\r\n      error: 'Failed to initiate signature workflow',\r\n      details: error instanceof Error ? error.message : 'Unknown error'\r\n    }, { status: 500 })\r\n  }\r\n}\r\n"],"names":[],"mappings":"wCAAA,IAAA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,CAAA,CAAA,QAAA,IAAA,EAAA,EAAA,CAAA,CAAA,OChBA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,OAGA,IAAM,EAAgB,EAAA,CAAC,CAAC,MAAM,CAAC,CAC7B,qBAAsB,EAAA,CAAC,CAAC,KAAK,CAAC,EAAA,CAAC,CAAC,MAAM,GAAG,IAAI,IAAI,QAAQ,GAEzD,mBAAoB,EAAA,CAAC,CAAC,IAAI,CAAC,CAAC,MAAO,WAAW,EAAE,QAAQ,GAAG,OAAO,CAAC,OACnE,YAAa,EAAA,CAAC,CAAC,MAAM,GAAG,IAAI,GAAG,QAAQ,EAEzC,GAAG,QAAQ,GAEJ,eAAe,EACpB,CAAoB,CACpB,QAAE,CAAM,CAA2D,EAEnE,GAAM,CAAE,GAAI,CAAc,YAAE,CAAU,CAAE,CAAG,MAAM,EAE3C,EAAiB,MAAM,CAAA,EAAA,EAAA,YAAY,AAAZ,IACvB,CAAE,KAAM,CAAE,MAAI,CAAE,CAAE,MAAO,CAAS,CAAE,CAAG,MAAM,EAAe,IAAI,CAAC,OAAO,GAE9E,GAAI,GAAa,CAAC,EAChB,IADsB,GACf,EAAA,YAAY,CAAC,IAAI,CAAC,CAAE,MAAO,cAAe,EAAG,CAAE,OAAQ,GAAI,GAIpE,GAAM,CAAE,KAAM,CAAO,CAAE,CAAG,MAAM,EAC7B,IAAI,CAAC,YACL,MAAM,CAAC,6BACP,EAAE,CAAC,KAAM,EAAK,EAAE,EAChB,MAAM,GAGT,GAAI,CADY,AACX,IADoB,KACX,CADiB,WAAW,WAAa,GAAS,OAAS,KAAA,EAEvE,OAAO,EAAA,YAAY,CAAC,IAAI,CAAC,CAAE,MAAO,uBAAwB,EAAG,CAAE,OAAQ,GAAI,GAI7E,IAAI,EAA2G,CAAC,EAChH,GAAI,CACF,IAAM,EAAU,MAAM,EAAQ,IAAI,GAClC,GAAI,IACF,EAAO,GADI,EACC,KAAK,CAAC,GAEd,CADe,AACd,EAD4B,SAAS,CAAC,GAC3B,OAAO,EAAE,AACvB,OAAO,EAAA,YAAY,CAAC,IAAI,CAAC,CAAE,MAAO,sBAAuB,EAAG,CAAE,OAAQ,GAAI,EAGhF,CAAE,KAAM,CAER,CAKA,IAAM,EAAkB,CAAA,EAAA,EAAA,mBAAmB,AAAnB,IAGlB,CAAE,KAAM,CAAQ,CAAE,CAAG,MAAM,EAC9B,IAAI,CAAC,aACL,MAAM,CAAC,KACP,EAAE,CAAC,KAAM,GACT,EAAE,CAAC,kBAAmB,GACtB,MAAM,GAET,GAAI,CAAC,EACH,OAAO,CADM,CACN,YAAY,CAAC,IAAI,CAAC,CAAE,MAAO,oBAAqB,EAAG,CAAE,OAAQ,GAAI,GAK1E,IAAM,EAAS,EAAS,SAAS,EAAE,SAAS,qBAC7B,EAAS,SAAS,EAAE,SAAS,WAC7B,EAAS,QAAQ,EAAE,cAAc,SAAS,UAC1C,EAAS,QAAQ,EAAE,cAAc,SAAS,QAEnD,EAA+B,oBAAvB,EAAS,SAAS,EAClB,EAAS,QAAQ,EAAE,cAAc,SAAS,QAEpD,EAAmB,EACnB,EAAqB,EAEzB,GAAI,EACF,KADS,GACD,GAAG,CAAC,6EACP,GAAI,EAAQ,CACjB,QAAQ,GAAG,CAAC,2EAGZ,GAAM,CAAE,KAAM,CAAQ,CAAE,MAAO,CAAa,CAAE,CAAG,MAAM,EAAgB,OAAO,CAC3E,IAAI,CAAC,kBACL,QAAQ,CAAC,EAAS,QAAQ,EAE7B,GAAI,GAAiB,CAAC,EAEpB,OADA,CAD8B,OACtB,KAAK,CAAC,4CAA6C,GACpD,EAAA,YAAY,CAAC,IAAI,CAAC,CACvB,MAAO,6CACP,QAAS,GAAe,OAC1B,EAAG,CAAE,OAAQ,GAAI,GAInB,IAAM,EAAa,OAAO,IAAI,CAAC,MAAM,EAAS,WAAW,IACzD,QAAQ,GAAG,CAAC,sBAAuB,CAAE,KAAM,EAAW,MAAM,AAAC,GAI7D,IAAI,EAAe,EAAS,IAAI,EAAI,eAChC,CAAC,EAAa,WAAW,GAAG,QAAQ,CAAC,UAAa,EAAD,AAAc,WAAW,GAAG,QAAQ,CAAC,SAAS,CACjG,EAAe,CAAA,EAAG,EAAa,MAAK,AAAC,EAEvC,IAAM,EAAmB,MAAM,CAAA,EAAA,EAAA,gBAAA,AAAgB,EAAC,EAAY,GAE5D,GAAI,CAAC,EAAiB,OAAO,EAAI,CAAC,EAAiB,SAAS,CAE1D,CAF4D,MAC5D,QAAQ,KAAK,CAAC,iCAAkC,EAAiB,KAAK,EAC/D,EAAA,YAAY,CAAC,IAAI,CAAC,CACvB,MAAO,gCACP,QAAS,EAAiB,KAAK,EAAI,gCACrC,EAAG,CAAE,OAAQ,GAAI,GAGnB,QAAQ,GAAG,CAAC,2BAA4B,CACtC,WAAY,EAAW,MAAM,CAC7B,YAAa,EAAiB,SAAS,CAAC,MAAM,AAChD,GAGA,IAAM,EAAc,EAAS,QAAQ,CAAC,OAAO,CAAC,mBAAoB,QAC5D,EAAa,EAAY,QAAQ,CAAC,eACpC,EACA,EAAY,OAAO,CAAC,aAAc,iBAEhC,CAAE,MAAO,CAAW,CAAE,CAAG,MAAM,EAAgB,OAAO,CACzD,IAAI,CAAC,kBACL,MAAM,CAAC,EAAY,EAAiB,SAAS,CAAE,CAC9C,YAAa,kBACb,QAAQ,CACV,GAEF,GAAI,EAEF,OADA,IADe,IACP,KAAK,CAAC,oCAAqC,GAC5C,EAAA,YAAY,CAAC,IAAI,CAAC,CACvB,MAAO,+BACP,QAAS,EAAY,OACvB,AAD8B,EAC3B,CAAE,OAAQ,GAAI,GAGnB,QAAQ,GAAG,CAAC,6BAA8B,GAG1C,IAAM,EAAa,CAAC,EAAS,IAAI,EAAI,UAAA,CAAU,CAAE,OAAO,CAAC,oBAAqB,QACxE,CAAE,KAAM,CAAW,CAAE,MAAO,CAAW,CAAE,CAAG,MAAM,EACrD,IAAI,CAAC,aACL,MAAM,CAAC,CACN,gBAAiB,EACjB,QAAS,EAAS,OAAO,CACzB,WAAY,EAAS,UAAU,CAC/B,UAAW,EAAS,SAAS,CAC7B,KAAM,oBACN,KAAM,EACN,SAAU,EACV,UAAW,kBACX,gBAAiB,EAAiB,SAAS,CAAC,MAAM,CAClD,OAAQ,QACR,qBAAqB,EACrB,gBAAiB,EACjB,WAAY,EAAK,EACnB,AADqB,GAEpB,MAAM,GACN,MAAM,GAET,GAAI,GAAe,CAAC,EAElB,OADA,IAD+B,IACvB,KAAK,CAAC,0CAA2C,GAClD,EAAA,YAAY,CAAC,IAAI,CAAC,CACvB,MAAO,qDACP,QAAS,GAAa,OACxB,EAAG,CAAE,OAAQ,GAAI,GAGnB,QAAQ,GAAG,CAAC,iCAAkC,EAAY,EAAE,EAG5D,MAAM,EACH,IAAI,CAAC,aACL,MAAM,CAAC,CACN,OAAQ,QACR,SAAU,CAAE,iBAAkB,EAAY,EAAE,CAAE,aAAc,IAAI,OAAO,WAAW,EAAG,CACvF,GACC,EAAE,CAAC,KAAM,EAAS,EAAE,EAGvB,EAAmB,EACnB,EAAqB,EAAY,EAAE,CAEnC,QAAQ,GAAG,CAAC,kDAAmD,CAC7D,iBAAkB,EAAS,EAAE,CAC7B,WAAY,EAAY,EAAE,AAC5B,EACF,MAAO,GAAI,EAAS,SAAS,EAAI,CAAC,EAAS,SAAS,CAAC,QAAQ,CAAC,OAE5D,CAFoE,MAE7D,EAAA,YAAY,CAAC,IAAI,CAAC,CACvB,MAAO,8EACP,QAAS,CAAC,mBAAmB,EAAE,EAAS,SAAS,CAAA,CAAE,AACrD,EAAG,CAAE,OAAQ,GAAI,GAInB,QAAQ,GAAG,CAAC,qDACZ,GAAM,CAAE,KAAM,CAAY,CAAE,CAAG,MAAM,EAClC,IAAI,CAAC,iBACL,MAAM,CAAC,CAAC;;;;;;;;;;;IAWT,CAAC,EACA,EAAE,CAAC,KAAM,GACT,MAAM,GAET,GAAI,CAAC,EACH,OAAO,EAAA,GADU,SACE,CAAC,IAAI,CAAC,CAAE,MAAO,wBAAyB,EAAG,CAAE,OAAQ,GAAI,GAE9E,QAAQ,GAAG,CAAC,gDAAiD,CAAE,cAAe,EAAa,QAAQ,EAAE,IAAK,GAG1G,QAAQ,GAAG,CAAC,0DACZ,GAAM,CAAE,KAAM,CAAgB,CAAE,CAAG,MAAM,EACtC,IAAI,CAAC,sBACL,MAAM,CAAC,2BACP,EAAE,CAAC,cAAe,GAClB,EAAE,CAAC,SAAU,CAAC,UAAW,SAAS,EAErC,GAAI,GAAoB,EAAiB,MAAM,CAAG,EAAG,CACnD,IAAM,EAAe,EAAiB,MAAM,CAAC,GAAkB,YAAb,EAAE,MAAM,EAAgB,MAAM,CAC1E,EAAc,EAAiB,MAAM,CAAC,GAAkB,WAAb,EAAE,MAAM,EAAe,MAAM,CAE9E,OAAO,EAAA,YAAY,CAAC,IAAI,CAAC,CACvB,MAAO,qDACP,QAAS,CAAC,MAAM,EAAE,EAAa,aAAa,EAAE,EAAY,uDAAuD,CAAC,CAClH,kBAAmB,EAAiB,GAAG,CAAC,IAAK,AAAC,CAAE,GAAI,EAAE,EAAE,CAAE,KAAM,EAAE,WAAW,CAAE,OAAQ,EAAE,MAAM,CAAC,CAAC,CACnG,EAAG,CAAE,OAAQ,GAAI,EACnB,CAEA,AAHsB,QAGd,GAAG,CAAC,GAHyB,4DAMrC,GAAM,CAAE,KAAM,CAAO,CAAE,CAAG,MAAM,EAAgB,OAAO,CACpD,IAAI,CAAC,kBACL,eAAe,CAAC,EAAiB,QAAQ,CAAE,IAAI,IAElD,CAFuD,EAEnD,CAAC,EAFuD,CAE9C,GAFkD,OAG9D,CADuB,CAFgD,KAGhE,EAAA,YAAY,CAAC,IAAI,CAAC,CAAE,MAAO,iCAAkC,EAAG,CAAE,OAAQ,GAAI,GAGvF,QAAQ,GAAG,CAAC,0CAGZ,QAAQ,GAAG,CAAC,uDAEZ,IAAI,EAA2B,EAAE,CAEjC,GAAI,EAAK,oBAAoB,EAAI,EAAK,oBAAoB,CAAC,MAAM,CAAG,EAAG,CAErE,GAAM,CAAE,KAAM,CAAO,CAAE,MAAO,CAAY,CAAE,CAAG,MAAM,EAClD,IAAI,CAAC,oBACL,MAAM,CAAC,wBACP,EAAE,CAAC,KAAM,EAAK,oBAAoB,EAClC,EAAE,CAAC,cAAe,EAAa,WAAW,EAC1C,EAAE,CAAC,aAAa,GAEnB,GAAI,GAAgB,CAAC,GAA8B,GAAG,CAAtB,EAAQ,MAAM,CAC5C,OAAO,EAAA,YAAY,CAAC,IAAI,CAAC,CACvB,MAAO,iCACP,QAAS,gDACX,EAAG,CAAE,OAAQ,GAAI,GAGnB,EAAc,EAAQ,GAAG,CAAC,GAAM,CAAD,CAC7B,GAAI,EAAE,EAAE,CACR,UAAW,EAAE,SAAS,CACtB,MAAO,EAAE,KAAK,CAChB,CAAC,CACH,MAKE,CALK,EAEmD,CAGpD,UAHqB,EAAa,QAAQ,CAAC,IAAI,EACK,kBAA/B,EAAa,QAAQ,CAAC,IAAI,CAE7B,CAEpB,GAAM,CAAE,KAAM,CAAa,CAAE,CAAG,MAAM,EACnC,IAAI,CAAC,oBACL,MAAM,CAAC,wBACP,EAAE,CAAC,cAAe,EAAa,WAAW,EAC1C,EAAE,CAAC,gBAAgB,GACnB,EAAE,CAAC,aAAa,GAEf,GAAiB,EAAc,MAAM,CAAG,GAAG,AAC7C,EAAc,EAAc,GAAG,CAAC,IAAK,AAAC,CACpC,GAAI,EAAE,EAAE,CACR,UAAW,EAAE,SAAS,CACtB,MAAO,EAAE,KAAK,CAChB,CAAC,EACD,QAAQ,GAAG,CAAC,CAAC,sCAAsC,EAAE,EAAY,MAAM,CAAC,gCAAgC,CAAC,IAGzG,QAAQ,IAAI,CAAC,wFACb,EAAc,CAAC,CACb,GAAI,mBACJ,UAAW,EAAa,QAAQ,CAAC,UAAU,EAAI,EAAa,QAAQ,CAAC,YAAY,CACjF,MAAO,EAAa,QAAQ,CAAC,KAAK,AACpC,EAAE,CAEN,MAEE,CAFK,CAES,CAAC,CACb,GAAI,mBACJ,UAAW,EAAa,QAAQ,CAAC,UAAU,EAAI,EAAa,QAAQ,CAAC,YAAY,CACjF,MAAO,EAAa,QAAQ,CAAC,KAAK,AACpC,EAAE,CAMN,QAAQ,GAAG,CAAC,kDAAmD,EAAY,MAAM,EACjF,GAAI,CAWF,QAAQ,GAAG,CAAC,2EAGZ,IAAM,EAAY,MAAM,CAAA,EAAA,EAAA,YAAY,AAAZ,EAAa,GAErC,GAAI,CAAC,GAAa,CAAC,EAAU,KAAK,CAEhC,CAFkC,MAClC,QAAQ,KAAK,CAAC,+EACP,EAAA,YAAY,CAAC,IAAI,CAAC,CACvB,MAAO,gGACT,EAAG,CAAE,OAAQ,GAAI,GAGnB,IAAM,EAAc,EAAU,KAAK,CAC7B,EAAa,EAAU,WAAW,CAExC,QAAQ,GAAG,CAAC,wEAAyE,CACnF,MAAO,EACP,KAAM,CACR,GAGA,QAAQ,GAAG,CAAC,CAAC,+DAA+D,EAAE,EAAW,UAAU,CAAC,EACpG,IAAM,EAAmB,CACvB,YAAa,EAAa,WAAW,CACrC,aAAc,EACd,YAAa,EACb,cAAe,eACf,iBAAkB,EAAQ,SAAS,CACnC,YAAa,QACb,mBAAoB,UACpB,gBAAiB,EACjB,YAAa,EACb,QAAS,EAAa,OAAO,AAC/B,EAEM,EAAoB,MAAM,MAAM,8CAA4D,CAChG,OAAQ,OACR,AAFuE,QAE9D,CAAE,aAFkF,CAAC,CAEnE,kBAAmB,EAC9C,KAAM,KAAK,SAAS,CAAC,EACvB,GAEA,GAAI,CAAC,EAAkB,EAAE,CAAE,CACzB,IAAM,EAAY,MAAM,EAAkB,IAAI,EAC9C,OAAM,AAAI,MAAM,CAAC,qDAAqD,EAAE,EAAA,CAAW,CACrF,CAEA,IAAM,EAAgB,MAAM,EAAkB,IAAI,GAClD,QAAQ,GAAG,CAAC,sEAUZ,QAAQ,GAAG,CAAC,6EACZ,QAAQ,GAAG,CAAC,cAAe,EAAa,OAAO,EAE/C,IAAI,EAAkB,KAGhB,CAAE,KAAM,CAAe,CAAE,MAAO,CAAS,CAAE,CAAG,MAAM,EACvD,IAAI,CAAC,SACL,MAAM,CAAC,sBACP,EAAE,CAAC,KAAM,EAAa,OAAO,EAC7B,MAAM,GAQT,GANI,GACF,QADa,AACL,KAAK,CAAC,6DAA8D,EAAU,OAAO,EAG/F,QAAQ,GAAG,CAAC,yBAA0B,GAAiB,oBAAsB,YAEzE,GAAiB,mBA6GnB,OADA,QAAQ,KAAK,CAAC,oEAAqE,EAAa,OAAO,EAChG,EAAA,YAAY,CAAC,IAAI,CAAC,CACvB,MAAO,gJACT,EAAG,CAAE,OAAQ,GAAI,EA/GsB,EAEvC,GAAM,CAAE,KAAM,CAAc,CAAE,MAAO,CAAW,CAAE,CAAG,MAAM,EACxD,IAAI,CAAC,qBACL,MAAM,CAAC,cACP,EAAE,CAAC,KAAM,EAAgB,kBAAkB,EAC3C,MAAM,GAEL,GACF,QAAQ,EADO,GACF,CAAC,2DAA4D,EAAY,OAAO,EAE/F,QAAQ,GAAG,CAAC,2BAA4B,GAAgB,YAAc,aAGtE,GAAM,CAAE,KAAM,CAAY,CAAE,MAAO,CAAS,CAAE,CAAG,MAAM,EACpD,IAAI,CAAC,kBACL,MAAM,CAAC,WACP,EAAE,CAAC,cAAe,EAAgB,kBAAkB,EACpD,EAAE,CAAC,YAAY,GACf,EAAE,CAAC,cAAc,GACjB,WAAW,EAEV,IACF,OADa,CACL,KAAK,CAAC,iEAAkE,EAAU,OAAO,EAEnG,QAAQ,GAAG,CAAC,+BAAgC,GAAc,SAAW,aAGrE,IAAI,EAAiB,GAAc,QACnC,GAAI,CAAC,EAAgB,CACnB,QAAQ,GAAG,CAAC,+DACZ,GAAM,CAAE,KAAM,CAAc,CAAE,MAAO,CAAa,CAAE,CAAG,MAAM,EAC1D,IAAI,CAAC,kBACL,MAAM,CAAC,WACP,EAAE,CAAC,cAAe,EAAgB,kBAAkB,EACpD,EAAE,CAAC,YAAY,GACf,KAAK,CAAC,GACN,WAAW,EAEV,IACF,QAAQ,GADS,EACJ,CAAC,kEAAmE,EAAc,OAAO,EAExG,EAAiB,GAAgB,QACjC,QAAQ,GAAG,CAAC,gCAAiC,GAAkB,YACjE,CAEA,IAAI,EAwDF,OADA,QAAQ,KAAK,CAAC,4FAA6F,EAAgB,kBAAkB,EACtI,EAAA,YAAY,CAAC,IAAI,CAAC,CACvB,MAAO,CAAC,kCAAkC,EAAE,GAAgB,YAAc,kBAAkB,uDAAuD,CAAC,AACtJ,EAAG,CAAE,OAAQ,GAAI,EA1DC,EAClB,GAAM,CAAE,KAAM,CAAe,CAAE,MAAO,CAAY,CAAE,CAAG,MAAM,EAC1D,IAAI,CAAC,YACL,MAAM,CAAC,uBACP,EAAE,CAAC,KAAM,GACT,MAAM,GAOT,GALI,GACF,QAAQ,GADQ,EACH,CAAC,4DAA6D,EAAa,OAAO,EAEjG,QAAQ,GAAG,CAAC,uBAAwB,GAAiB,MAAO,GAAiB,eAEzE,GAAiB,MAqCnB,OADA,QAAQ,KAAK,CAAC,wEACP,EAAA,YAAY,CAAC,IAAI,CAAC,CACvB,MAAO,CAAC,kBAAkB,EAAE,GAAgB,YAAc,kBAAkB,oEAAoE,CAAC,AACnJ,EAAG,CAAE,OAAQ,GAAI,EAvCS,EAC1B,IAAM,EAAqB,CACzB,YAAa,EAAa,WAAW,CACrC,aAAc,EAAgB,KAAK,CACnC,YAAa,EAAgB,YAAY,EAAI,GAAgB,YAAc,WAC3E,cAAe,eACf,iBAAkB,EAAQ,SAAS,CACnC,YAAa,WACb,mBAAoB,UACpB,gBAAiB,EACjB,YAAa,EACb,QAAS,EAAa,OAAO,AAC/B,EAEA,QAAQ,GAAG,CAAC,8CAA+C,EAAgB,KAAK,EAEhF,IAAM,EAAsB,MAAM,MAAM,8CAA4D,CAClG,OAAQ,OADiE,AAEzE,QAAS,CAAE,aAFoF,CAAC,CAErE,kBAAmB,EAC9C,KAAM,KAAK,SAAS,CAAC,EACvB,GAEA,GAAI,EAAoB,EAAE,CACxB,CAD0B,CACR,MAAM,EAAoB,IAAI,GAChD,QAAQ,GAAG,CAAC,wEAAyE,EAAgB,oBAAoB,MACpH,CACL,IAAM,EAAY,MAAM,EAAoB,IAAI,GAGhD,OAFA,QAAQ,KAAK,CAAC,uEAAwE,GAE/E,EAAA,YAAY,CAAC,IAAI,CAAC,CACvB,MAAO,8CACP,QAAS,CACX,EAAG,CAAE,OAAQ,GAAI,EACnB,CACF,CAOF,CAOF,CAYA,IA1BW,CAOF,CAOF,EAYC,GAAG,CAAC,8FACZ,IAAM,EAAkB,CAAC,UAAW,YAAa,YAAa,YAAa,YAAY,CACjF,EAA4B,EAAE,CAEpC,IAAK,IAAI,EAAI,EAAG,EAAI,EAAY,MAAM,CAAE,IAAK,CAC3C,IAAM,EAAY,CAAW,CAAC,EAAE,CAC1B,EAAW,CAAe,CAAC,EAAE,EAAI,CAAC,QAAQ,EAAE,EAAI,EAAA,CAAG,CACzD,QAAQ,GAAG,CAAC,CAAC,qDAAqD,EAAE,EAAI,EAAE,CAAC,EAAE,EAAY,MAAM,CAAC,KAAK,EAAE,EAAU,SAAS,CAAA,CAAE,EAE5H,IAAM,EAAqB,CACzB,YAAa,EAAa,WAAW,CACrC,aAAc,EAAU,KAAK,CAC7B,YAAa,EAAU,SAAS,CAChC,cAAe,eACf,iBAAkB,EAAQ,SAAS,CACnC,YAAa,WACb,mBAAoB,EACpB,gBAAiB,EACjB,YAAa,EACb,QAAS,EAAa,OAAO,CAC7B,UAA4B,qBAAjB,EAAU,EAAE,CAA0B,EAAU,EAAE,MAAG,EAChE,0BAA2B,EAAY,MAAM,AAC/C,CADgD,CAG1C,EAAsB,MAAM,MAAM,mBAH0C,2BAGkB,CAClG,OAAQ,OACR,AAFyE,QAEhE,CAAE,aAFoF,CAAC,CAErE,kBAAmB,EAC9C,KAAM,KAAK,SAAS,CAAC,EACvB,GAEA,GAAI,CAAC,EAAoB,EAAE,CAAE,CAC3B,IAAM,EAAY,MAAM,EAAoB,IAAI,EAChD,OAAM,AAAI,MAAM,CAAC,gDAAgD,EAAE,EAAU,SAAS,CAAC,EAAE,EAAE,EAAA,CAAW,CACxG,CAEA,IAAM,EAAkB,MAAM,EAAoB,IAAI,GACtD,EAA0B,IAAI,CAAC,CAC7B,UAAW,EAAU,SAAS,CAC9B,MAAO,EAAU,KAAK,CACtB,GAAG,CAAe,AACpB,EACF,CAEA,QAAQ,GAAG,CAAC,2DAGZ,MAAM,EACH,IAAI,CAAC,aACL,MAAM,CAAC,CACN,qBAAqB,EACrB,OAAQ,oBACR,iBAAkB,SACpB,CAD+B,EAE9B,EAAE,CAAC,KAAM,GAEZ,IAAM,EAAM,IAAI,OAAO,QAJgD,GAIrC,GAalC,GAZA,MAAM,EACH,IAAI,CAAC,iBACL,MAAM,CAAC,CAAE,aAAc,CAAI,GAC3B,EAAE,CAAC,KAAM,GACT,EAAE,CAAC,eAAgB,MACtB,MAAM,EACH,IAAI,CAAC,iBACL,MAAM,CAAC,CAAE,kBAAmB,CAAI,GAChC,EAAE,CAAC,KAAM,GACT,EAAE,CAAC,oBAAqB,MAGvB,EAAa,OAAO,CAAE,CACxB,GAAM,CAAE,KAAM,CAAI,CAAE,CAAG,MAAM,EAC1B,IAAI,CAAC,SACL,MAAM,CAAC,4BACP,EAAE,CAAC,KAAM,EAAa,OAAO,EAC7B,MAAM,GAET,GAAI,GAAM,mBAAoB,CAC5B,GAAM,CAAE,KAAM,CAAa,CAAE,CAAG,MAAM,EACnC,IAAI,CAAC,kBACL,MAAM,CAAC,WACP,EAAE,CAAC,cAAe,EAAK,kBAAkB,EAE5C,GAAI,GAAiB,EAAc,MAAM,CAAG,EAAG,CAC7C,IAAM,EAAe,EAAa,QAAQ,EAAE,cAAgB,EAAa,QAAQ,EAAE,YAAc,WAC3F,EAAW,EAAK,IAAI,EAAI,WAExB,EAAgB,EAAc,GAAG,CAAC,AAAC,IAA6B,CAAD,AACnE,QAAS,EAAG,OAAO,CACnB,YAAa,KACb,MAAO,yBACP,QAAS,CAAC,sBAAsB,EAAE,EAAa,EAAE,EAAE,EAAS,8BAA8B,CAAC,CAC3F,KAAM,4BACR,CAAC,CAED,OAAM,EAAgB,IAAI,CAAC,0BAA0B,MAAM,CAAC,GAC5D,QAAQ,GAAG,CAAC,8CAA+C,EAAc,MAAM,CACjF,CACF,CACF,CASA,OAPA,QAAQ,GAAG,CAAC,sEAAuE,CACjF,YAAa,EACb,kBAAmB,EAA0B,MAAM,CACnD,eAAgB,EAAc,oBAAoB,CAClD,iBAAkB,GAAiB,sBAAwB,IAC7D,GAEO,EAAA,YAAY,CAAC,IAAI,CAAC,CACvB,SAAS,EACT,4BAA6B,EAE7B,eAAgB,EAChB,YAAa,EACb,iBAAkB,EAGlB,sBAAuB,EACvB,mBAAoB,MACpB,mBAAoB,EACpB,kBAAmB,EAAY,MAAM,CAAG,IAAI,EAAC,CAC/C,EAEF,CAAE,MAAO,EAAO,CAEd,KALiE,EAIjE,EAJqE,CAAC,EAAE,GAIhE,KAAK,CAAC,uBAJ0F,cAIpD,GAC7C,EAAA,YAAY,CAAC,IAAI,CAAC,CACvB,MAAO,wCACP,QAAS,aAAiB,MAAQ,EAAM,OAAO,CAAG,eACpD,EAAG,CAAE,OAAQ,GAAI,EACnB,CACF,4BDxoBA,IAAA,EAAA,EAAA,CAAA,CAAA,QAIA,IAAM,EAAc,IAAI,EAAA,mBAAmB,CAAC,CACxC,WAAY,CACR,KAAM,EAAA,SAAS,CAAC,SAAS,CACzB,KAAM,2EACN,SAAU,qEACV,SAAU,QACV,WAAY,EAChB,EACA,QAAS,CAAA,OACT,IADiD,eACc,CAA3C,EACpB,iBAAkB,gHAClB,iBAZqB,GAarB,SAAA,CACJ,GAIM,kBAAE,CAAgB,sBAAE,CAAoB,aAAE,CAAW,CAAE,CAAG,EAChE,SAAS,IACL,MAAO,CAAA,EAAA,EAAA,UAAW,AAAX,EAAY,kBACf,uBACA,CACJ,EACJ,CAEO,eAAe,EAAQ,CAAG,CAAE,CAAG,CAAE,CAAG,EACnC,EAAY,KAAK,EAAE,AACnB,CAAA,EAAA,EAAA,cAAA,AAAc,EAAC,EAAK,+BAAgC,QAAQ,MAAM,CAAC,MAAM,IAE7E,IAAI,EAAU,2EAKV,EAAU,EAAQ,OAAO,CAAC,WAAY,KAAO,IAMjD,IAAM,EAAgB,MAAM,EAAY,OAAO,CAAC,EAAK,EAAK,SACtD,EACA,mBAHE,CAAA,CAIN,GACA,GAAI,CAAC,EAID,OAHA,EAAI,IADY,MACF,CAAG,IACjB,EAAI,GAAG,CAAC,eACS,MAAjB,CAAwB,CAApB,IAAyB,KAAhB,EAAoB,EAAI,SAAS,CAAC,IAAI,CAAC,EAAK,QAAQ,OAAO,IACjE,KAEX,GAAM,CAAE,SAAO,QAAE,CAAM,YAAE,CAAU,WAAE,CAAS,aAAE,CAAW,mBAAE,CAAiB,qBAAE,CAAmB,sBAAE,CAAoB,yBAAE,CAAuB,CAAE,kBAAgB,yBAAE,CAAuB,uBAAE,CAAqB,CAAE,CAAG,EACnN,EAAoB,CAAA,EAAA,EAAA,gBAAA,AAAgB,EAAC,GACvC,GAAQ,EAAQ,EAAkB,aAAa,CAAC,EAAkB,EAAI,EAAkB,MAAM,CAAC,EAAA,AAAiB,EAC9G,EAAY,WAEa,MAAvB,EAA8B,KAAK,EAAI,EAAoB,SAAA,AAAS,EAAE,AACtE,MAAM,EAAoB,SAAS,CAAC,EAAK,EAAK,GAAW,GAEzD,EAAI,GAAG,CAAC,gCAEL,MAEX,GAAI,GAAS,CAAC,EAAa,CACvB,IAAM,GAAgB,CAAQ,EAAkB,MAAM,CAAC,EAAiB,CAClE,EAAgB,EAAkB,aAAa,CAAC,EAAkB,CACxE,GAAI,IAC+B,IAA3B,EAAc,KADH,GACW,EAAc,CAAC,EAAe,CACpD,GAAI,EAAW,YAAY,CAAC,WAAW,CACnC,CADqC,MAC9B,MAAM,GAEjB,OAAM,IAAI,EAAA,eAAe,AAC7B,CAER,CACA,IAAI,EAAW,MACX,GAAU,EAAY,IAAb,CAAkB,EAAK,EAAD,CAG/B,GAAW,AAAa,OAHqB,KAC7C,EAAW,CAAA,EAEwB,IAAM,CAAA,EAE7C,IAAM,GACgB,IAAtB,EAAY,EAAkB,GAAb,EAEjB,CAAC,EAKK,EAAqB,GAAS,CAAC,EAIjC,GAAyB,GACzB,CAAA,EAAA,EAAA,iBADkD,IAClD,AAAqB,EAAC,CAClB,KAAM,aAbqF,aAc3F,wBACA,CACJ,GAEJ,IAAM,EAAS,EAAI,MAAM,EAAI,MACvB,EAAS,CAAA,EAAA,EAAA,SAAA,AAAS,IAClB,EAAa,EAAO,kBAAkB,GACtC,EAAU,CACZ,SACA,oBACA,WAAY,CACR,aAAc,CACV,gBAAgB,CAAQ,EAAW,YAAY,CAAC,cAAc,AAClE,EACA,iBAAiB,CAAQ,EAAW,eAAe,yBACnD,EACA,iBAAkB,CAAA,EAAA,EAAA,cAAc,AAAd,EAAe,EAAK,oBACtC,kBAAmB,EAAW,SAAS,CACvC,UAAW,EAAI,SAAS,CACxB,QAAS,AAAC,IACN,EAAI,EAAE,CAAC,QAAS,EACpB,EACA,iBAAkB,OAClB,8BAA+B,CAAC,EAAO,EAAU,EAAc,IAAa,EAAY,cAAc,CAAC,EAAK,EAAO,EAAc,EAAY,EACjJ,EACA,cAAe,CACX,SACJ,CACJ,EACM,EAAc,IAAI,EAAA,eAAe,CAAC,GAClC,EAAc,IAAI,EAAA,gBAAgB,CAAC,GACnC,EAAU,EAAA,kBAAkB,CAAC,mBAAmB,CAAC,EAAa,CAAA,EAAA,EAAA,sBAAA,AAAsB,EAAC,IAC3F,GAAI,CACA,IAAM,EAAoB,MAAO,GACtB,EAAY,MAAM,CAAC,EAAS,GAAS,OAAO,CAAC,KAChD,GAAI,CAAC,EAAM,OACX,EAAK,aAAa,CAAC,CACf,mBAAoB,EAAI,UAAU,CAClC,YAAY,CAChB,GACA,IAAM,EAAqB,EAAO,qBAAqB,GAEvD,GAAI,CAAC,EACD,OAEJ,GAAI,EAAmB,GAAG,CAAC,EAHF,kBAGwB,EAAA,cAAc,CAAC,aAAa,CAAE,YAC3E,QAAQ,IAAI,CAAC,CAAC,2BAA2B,EAAE,EAAmB,GAAG,CAAC,kBAAkB,qEAAqE,CAAC,EAG9J,IAAM,EAAQ,EAAmB,GAAG,CAAC,cACrC,GAAI,EAAO,CACP,IAAM,EAAO,CAAA,EAAG,EAAO,CAAC,EAAE,EAAA,CAAO,CACjC,EAAK,aAAa,CAAC,CACf,aAAc,EACd,aAAc,EACd,iBAAkB,CACtB,GACA,EAAK,UAAU,CAAC,EACpB,MACI,CADG,CACE,UAAU,CAAC,CAAA,EAAG,EAAO,CAAC,EAAE,EAAA,CAAS,CAE9C,GAEE,GAAgB,CAAoC,CAAA,EAAA,EAAA,EAA5B,YAA4B,AAAc,EAAC,EAAK,eACxE,EAAiB,MAAO,QACtB,EA4FI,EA3FR,IAAM,EAAoB,MAAO,CAAE,oBAAkB,CAAE,IACnD,GAAI,CACA,GAAI,CAAC,GAAiB,GAAwB,GAA2B,CAAC,EAKtE,OAJA,EAAI,SADsF,CAC5E,CAAG,IAEjB,EAAI,SAAS,CAAC,iBAAkB,eAChC,EAAI,GAAG,CAAC,gCACD,KAEX,IAAM,EAAW,MAAM,EAAkB,GACzC,EAAI,YAAY,CAAG,EAAQ,UAAU,CAAC,YAAY,CAClD,IAAI,EAAmB,EAAQ,UAAU,CAAC,gBAAgB,CAGtD,GACI,EAAI,SAAS,EAAE,CACf,CAFc,CAEV,SAAS,CAAC,GACd,OAAmB,GAG3B,IAAM,EAAY,EAAQ,UAAU,CAAC,aAAa,CAGlD,IAAI,EA6BA,OADA,MAAM,CAAA,EAAA,EAAA,YAAA,AAAY,EAAC,EAAa,EAAa,EAAU,EAAQ,UAAU,CAAC,gBAAgB,EACnF,IA7BA,EACP,IAAM,EAAO,MAAM,EAAS,IAAI,GAE1B,EAAU,CAAA,EAAA,EAAA,yBAAA,AAAyB,EAAC,EAAS,OAAO,EACtD,GACA,EAAO,CAAC,EAAA,GADG,mBACmB,CAAC,CAAG,CAAA,EAElC,CAAC,CAAO,CAAC,eAAe,EAAI,EAAK,IAAI,EAAE,CACvC,CAAO,CAAC,eAAe,CAAG,EAAK,IAAA,AAAI,EAEvC,IAAM,EAAa,KAAkD,IAA3C,EAAQ,UAAU,CAAC,mBAAmB,IAAoB,EAAQ,UAAU,CAAC,mBAAmB,EAAI,EAAA,cAAA,AAAc,GAAG,AAAQ,EAAQ,UAAU,CAAC,mBAAmB,CACvL,EAAS,KAA8C,IAAvC,EAAQ,UAAU,CAAC,eAAe,EAAoB,EAAQ,UAAU,CAAC,eAAe,EAAI,EAAA,cAAc,MAAG,EAAY,EAAQ,UAAU,CAAC,eAAe,CAcjL,MAZmB,CAYZ,AAXH,MAAO,CACH,KAAM,EAAA,eAAe,CAAC,SAAS,CAC/B,OAAQ,EAAS,MAAM,CACvB,KAAM,OAAO,IAAI,CAAC,MAAM,EAAK,WAAW,YACxC,CACJ,EACA,aAAc,CACV,aACA,QACJ,CACJ,CAEJ,CAKJ,CAAE,KALS,CAKF,EAAK,CAeV,MAZ0B,MAAtB,EAA6B,KAAK,EAAI,EAAmB,OAAA,AAAO,EAAE,CAElE,MAAM,EAAY,cAAc,CAAC,EAAK,EAAK,CACvC,WAAY,aACZ,UAAW,EACX,UAAW,QACX,iBAAkB,CAAA,EAAA,EAAA,mBAAA,AAAmB,EAAC,CAClC,0CACA,CACJ,EACJ,GAAG,AATgB,EASJ,GAEb,CACV,CACJ,EACM,EAAa,MAAM,EAAY,cAAc,CAAC,KAChD,EACA,aACA,WACA,UAAW,EAAA,SAAS,CAAC,SAAS,CAC9B,YAAY,oBACZ,EACA,mBAAmB,uBACnB,0BACA,oBACA,EACA,UAAW,EAAI,SAAS,eACxB,CACJ,GAEA,GAAI,CAAC,EACD,KADQ,EACD,KAEX,GAAI,CAAe,MAAd,CAAqB,EAAS,AAA0C,GAA9C,GAAK,GAAoB,EAAW,KAAA,AAAK,EAAY,KAAK,EAAI,EAAkB,IAAI,IAAM,EAAA,eAAe,CAAC,SAAS,CAE9I,CAFgJ,KAE1I,OAAO,cAAc,CAAC,AAAI,MAAM,CAAC,kDAAkD,EAAgB,MAAd,CAAqB,EAAS,AAA2C,GAA/C,IAAK,EAAqB,EAAW,KAAA,AAAK,EAAY,KAAK,EAAI,EAAmB,IAAI,CAAA,CAAE,EAAG,oBAAqB,CACjO,MAAO,OACP,YAAY,EACZ,cAAc,CAClB,EAEA,CAAC,GACD,EAAI,SAAS,CAAC,AADE,iBACgB,EAAuB,cAAgB,EAAW,MAAM,CAAG,OAAS,EAAW,OAAO,CAAG,QAAU,OAGnI,GACA,EAAI,QADS,CACA,CAAC,gBAAiB,2DAEnC,IAAM,EAAU,CAAA,EAAA,EAAA,2BAAA,AAA2B,EAAC,EAAW,KAAK,CAAC,OAAO,EAcpE,OAbM,AAAF,CAAC,EAAkB,GACnB,EADwB,AAChB,GADmB,GACb,CAAC,EAAA,sBAAsB,GAIrC,EAAW,YAAY,EAAK,EAAD,AAAK,SAAS,CAAC,kBAAqB,EAAD,AAAS,GAAG,CAAC,kBAAkB,AAC7F,EAAQ,GAAG,CAAC,gBAAiB,CAAA,EAAA,EAAA,qBAAA,AAAqB,EAAC,EAAW,YAAY,GAE9E,MAAM,CAAA,EAAA,EAAA,YAAA,AAAY,EAAC,EAAa,EAChC,IAAI,SAAS,EAAW,KAAK,CAAC,IAAI,CAAE,SAChC,EACA,OAAQ,EAAW,KAAK,CAAC,MAAM,EAAI,GACvC,IACO,IACX,EAGI,EACA,MAAM,EAAe,EADT,CAGZ,MAAM,EAAO,qBAAqB,CAAC,EAAI,OAAO,CAAE,IAAI,EAAO,KAAK,CAAC,EAAA,cAAc,CAAC,aAAa,CAAE,CACvF,SAAU,CAAA,EAAG,EAAO,CAAC,EAAE,EAAA,CAAS,CAChC,KAAM,EAAA,QAAQ,CAAC,MAAM,CACrB,WAAY,CACR,cAAe,EACf,cAAe,EAAI,GAAG,AAC1B,CACJ,EAAG,GAEf,CAAE,MAAO,EAAK,CAeV,GAdM,aAAe,EAAA,eAAe,EAEhC,CAFmC,KAE7B,EAAY,cAAc,CAAC,EAAK,EAAK,CACvC,WAAY,aACZ,UAAW,EACX,UAAW,QACX,iBAAkB,CAAA,EAAA,EAAA,mBAAA,AAAmB,EAAC,oBAClC,uBACA,CACJ,EACJ,GAAG,AATgB,EASJ,GAIf,EAAO,MAAM,EAKjB,OAHA,MAAM,CAAA,EAAA,EAAA,YAAA,AAAY,EAAC,EAAa,EAAa,IAAI,SAAS,KAAM,CAC5D,OAAQ,GACZ,IACO,IACX,CACJ,EAEA,qCAAqC","ignoreList":[0]}