{"version":3,"sources":["../../../../versotech-portal/src/lib/supabase/server.ts","../../../../versotech-portal/src/lib/staff/ceo-signer.ts","../../../../versotech-portal/src/lib/gotenberg/convert.ts"],"sourcesContent":["import { createServerClient } from '@supabase/ssr'\nimport { createClient as createSupabaseClient } from '@supabase/supabase-js'\nimport { cookies } from 'next/headers'\n\nexport const createClient = async () => {\n  const cookieStore = await cookies()\n\n  return createServerClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n    {\n      cookies: {\n        getAll() {\n          return cookieStore.getAll()\n        },\n        setAll(cookiesToSet) {\n          try {\n            cookiesToSet.forEach(({ name, value, options }) => {\n              cookieStore.set(name, value, options)\n            })\n          } catch (error) {\n            // The `setAll` method was called from a Server Component.\n            // This can be ignored if you have middleware refreshing\n            // user sessions.\n          }\n        },\n      },\n    }\n  )\n}\n\n// Server client with service role for admin operations\n// Uses raw supabase-js client which properly bypasses RLS with service role\nexport const createServiceClient = () => {\n  return createSupabaseClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.SUPABASE_SERVICE_ROLE_KEY!,\n    {\n      auth: {\n        autoRefreshToken: false,\n        persistSession: false,\n      },\n    }\n  )\n}\n","import type { SupabaseClient } from '@supabase/supabase-js'\nimport type { Database } from '@/types/supabase'\n\n/**\n * CEO Signer type - represents a user who can sign documents for Verso Capital\n */\nexport type CeoSigner = {\n  id: string\n  email: string\n  displayName: string\n  title: string | null\n  canSign: boolean\n}\n\n/**\n * Get a CEO user who can sign documents for Verso Capital\n *\n * Queries ceo_users table for users with can_sign = true\n * Returns the primary signer first, otherwise the first available signer\n */\nexport async function getCeoSigner(\n  supabase: SupabaseClient<Database>\n): Promise<CeoSigner | null> {\n  // Query ceo_users to find a user who can sign\n  const { data: ceoUser, error } = await supabase\n    .from('ceo_users')\n    .select('user_id, can_sign, is_primary, title')\n    .eq('can_sign', true)\n    .order('is_primary', { ascending: false })  // Primary signer first\n    .order('created_at', { ascending: true })   // Then oldest first\n    .limit(1)\n    .maybeSingle()\n\n  if (error) {\n    console.error('[ceo-signer] Failed to load CEO signer:', error)\n    return null\n  }\n\n  if (!ceoUser) {\n    console.warn('[ceo-signer] No CEO signer found with can_sign = true')\n    return null\n  }\n\n  // Fetch profile separately to avoid deep type issues with FK hints\n  const { data: profile, error: profileError } = await supabase\n    .from('profiles')\n    .select('id, email, display_name')\n    .eq('id', ceoUser.user_id)\n    .single()\n\n  if (profileError || !profile) {\n    console.error('[ceo-signer] Failed to load profile for signer:', profileError)\n    return null\n  }\n\n  return {\n    id: profile.id,\n    email: profile.email || '',\n    displayName: profile.display_name || profile.email?.split('@')[0] || 'CEO',\n    title: ceoUser.title,\n    canSign: ceoUser.can_sign ?? false\n  }\n}\n\n/**\n * Get all CEO users (for member management)\n */\nexport async function getCeoUsers(\n  supabase: SupabaseClient<Database>\n): Promise<Array<{\n  userId: string\n  email: string\n  displayName: string\n  title: string | null\n  role: string\n  canSign: boolean\n  isPrimary: boolean\n  createdAt: string | null\n}>> {\n  // Fetch CEO users without FK hint to avoid TypeScript type depth issues\n  const { data: ceoUsers, error } = await supabase\n    .from('ceo_users')\n    .select('user_id, role, can_sign, is_primary, title, created_at')\n    .order('is_primary', { ascending: false })\n    .order('created_at', { ascending: true })\n\n  if (error) {\n    console.error('[ceo-signer] Failed to load CEO users:', error)\n    return []\n  }\n\n  if (!ceoUsers || ceoUsers.length === 0) {\n    return []\n  }\n\n  // Fetch profiles separately for all CEO users\n  const userIds = ceoUsers.map(u => u.user_id)\n  const { data: profiles, error: profilesError } = await supabase\n    .from('profiles')\n    .select('id, email, display_name')\n    .in('id', userIds)\n\n  if (profilesError) {\n    console.error('[ceo-signer] Failed to load profiles for CEO users:', profilesError)\n    return []\n  }\n\n  // Create a map for quick profile lookup\n  const profileMap = new Map(profiles?.map(p => [p.id, p]) || [])\n\n  return ceoUsers.map(row => {\n    const profile = profileMap.get(row.user_id)\n    return {\n      userId: row.user_id,\n      email: profile?.email || 'unknown@email.com',\n      displayName: profile?.display_name || profile?.email?.split('@')[0] || 'Unknown',\n      title: row.title,\n      role: row.role,\n      canSign: row.can_sign ?? false,\n      isPrimary: row.is_primary ?? false,\n      createdAt: row.created_at\n    }\n  })\n}\n\n/**\n * Get the CEO entity info (Verso Capital)\n */\nexport async function getCeoEntity(\n  supabase: SupabaseClient<Database>\n): Promise<{\n  id: string\n  legalName: string\n  displayName: string | null\n  registrationNumber: string | null\n  taxId: string | null\n  registeredAddress: string | null\n  city: string | null\n  postalCode: string | null\n  country: string | null\n  email: string | null\n  phone: string | null\n  website: string | null\n  logoUrl: string | null\n  status: string\n} | null> {\n  const { data, error } = await supabase\n    .from('ceo_entity')\n    .select('*')\n    .limit(1)\n    .maybeSingle()\n\n  if (error) {\n    console.error('[ceo-signer] Failed to load CEO entity:', error)\n    return null\n  }\n\n  if (!data) {\n    console.warn('[ceo-signer] No CEO entity found')\n    return null\n  }\n\n  return {\n    id: data.id,\n    legalName: data.legal_name,\n    displayName: data.display_name,\n    registrationNumber: data.registration_number,\n    taxId: data.tax_id,\n    registeredAddress: data.registered_address,\n    city: data.city,\n    postalCode: data.postal_code,\n    country: data.country,\n    email: data.email,\n    phone: data.phone,\n    website: data.website,\n    logoUrl: data.logo_url,\n    status: data.status ?? 'active'\n  }\n}\n\n/**\n * Check if the current user is a CEO member\n */\nexport async function isUserCeoMember(\n  supabase: SupabaseClient<Database>,\n  userId?: string\n): Promise<boolean> {\n  const targetUserId = userId || (await supabase.auth.getUser()).data.user?.id\n\n  if (!targetUserId) return false\n\n  const { data, error } = await supabase\n    .from('ceo_users')\n    .select('user_id')\n    .eq('user_id', targetUserId)\n    .maybeSingle()\n\n  if (error) {\n    console.error('[ceo-signer] Error checking CEO membership:', error)\n    return false\n  }\n\n  return !!data\n}\n\n/**\n * Check if the current user is a CEO admin\n */\nexport async function isUserCeoAdmin(\n  supabase: SupabaseClient<Database>,\n  userId?: string\n): Promise<boolean> {\n  const targetUserId = userId || (await supabase.auth.getUser()).data.user?.id\n\n  if (!targetUserId) return false\n\n  const { data, error } = await supabase\n    .from('ceo_users')\n    .select('user_id, role')\n    .eq('user_id', targetUserId)\n    .eq('role', 'admin')\n    .maybeSingle()\n\n  if (error) {\n    console.error('[ceo-signer] Error checking CEO admin status:', error)\n    return false\n  }\n\n  return !!data\n}\n","/**\n * Gotenberg Document Conversion Utilities\n *\n * Uses Gotenberg's LibreOffice endpoint to convert DOCX to PDF.\n * Gotenberg must be running at GOTENBERG_URL (default: http://gotenberg:3000)\n */\n\nconst GOTENBERG_URL = process.env.GOTENBERG_URL || 'http://gotenberg:3000'\n\nexport interface ConversionResult {\n  success: boolean\n  pdfBuffer?: Buffer\n  error?: string\n}\n\n/**\n * Convert a DOCX file to PDF using Gotenberg's LibreOffice endpoint\n *\n * @param docxBuffer - The DOCX file as a Buffer\n * @param filename - Original filename (used for form data, optional)\n * @returns ConversionResult with PDF buffer on success\n */\nexport async function convertDocxToPdf(\n  docxBuffer: Buffer,\n  filename: string = 'document.docx'\n): Promise<ConversionResult> {\n  try {\n    console.log('üìÑ [GOTENBERG] Starting DOCX to PDF conversion:', {\n      input_size: docxBuffer.length,\n      filename\n    })\n\n    // Gotenberg LibreOffice endpoint for document conversion\n    const url = `${GOTENBERG_URL}/forms/libreoffice/convert`\n\n    // Create form data with the file\n    // Convert Buffer to Uint8Array for TypeScript Blob compatibility\n    const formData = new FormData()\n    const blob = new Blob([new Uint8Array(docxBuffer)], {\n      type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'\n    })\n    formData.append('files', blob, filename)\n\n    // Optional: Set PDF/A format for archival quality\n    // formData.append('pdfFormat', 'PDF/A-1a')\n\n    const response = await fetch(url, {\n      method: 'POST',\n      body: formData\n    })\n\n    if (!response.ok) {\n      const errorText = await response.text()\n      console.error('‚ùå [GOTENBERG] Conversion failed:', {\n        status: response.status,\n        statusText: response.statusText,\n        error: errorText\n      })\n      return {\n        success: false,\n        error: `Gotenberg conversion failed: ${response.status} ${response.statusText}`\n      }\n    }\n\n    // Get the PDF as ArrayBuffer\n    const pdfArrayBuffer = await response.arrayBuffer()\n    const pdfBuffer = Buffer.from(pdfArrayBuffer)\n\n    console.log('‚úÖ [GOTENBERG] Conversion successful:', {\n      input_size: docxBuffer.length,\n      output_size: pdfBuffer.length\n    })\n\n    return {\n      success: true,\n      pdfBuffer\n    }\n  } catch (error) {\n    console.error('‚ùå [GOTENBERG] Conversion error:', error)\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown conversion error'\n    }\n  }\n}\n\n/**\n * Check if Gotenberg is available and responding\n */\nexport async function checkGotenbergHealth(): Promise<boolean> {\n  try {\n    const response = await fetch(`${GOTENBERG_URL}/health`, {\n      method: 'GET',\n      signal: AbortSignal.timeout(5000) // 5 second timeout\n    })\n    return response.ok\n  } catch {\n    return false\n  }\n}\n\n/**\n * Convert HTML to PDF using Gotenberg's Chromium endpoint\n * (Alternative method if you have HTML content)\n */\nexport async function convertHtmlToPdf(\n  htmlContent: string,\n  filename: string = 'document.html'\n): Promise<ConversionResult> {\n  try {\n    const url = `${GOTENBERG_URL}/forms/chromium/convert/html`\n\n    const formData = new FormData()\n    const blob = new Blob([htmlContent], { type: 'text/html' })\n    formData.append('files', blob, filename)\n\n    const response = await fetch(url, {\n      method: 'POST',\n      body: formData\n    })\n\n    if (!response.ok) {\n      const errorText = await response.text()\n      return {\n        success: false,\n        error: `HTML to PDF conversion failed: ${response.status} - ${errorText}`\n      }\n    }\n\n    const pdfArrayBuffer = await response.arrayBuffer()\n    return {\n      success: true,\n      pdfBuffer: Buffer.from(pdfArrayBuffer)\n    }\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error'\n    }\n  }\n}\n"],"names":[],"mappings":"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"}