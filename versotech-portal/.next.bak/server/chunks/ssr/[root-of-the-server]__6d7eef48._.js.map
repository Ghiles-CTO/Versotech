{"version":3,"sources":["../../../../../versotech-portal/src/lib/supabase/client.ts/__nextjs-internal-proxy.mjs","../../../../../versotech-portal/src/lib/messaging/supabase.ts","../../../../../versotech-portal/src/components/messaging/staff/messaging-client.tsx/__nextjs-internal-proxy.mjs","../../../../../versotech-portal/src/app/%28staff%29/versotech/staff/messages/page.tsx"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const createClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call createClient() from the server but createClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/versotech-portal/src/lib/supabase/client.ts\",\n    \"createClient\",\n);\nexport const hasActiveSession = registerClientReference(\n    function() { throw new Error(\"Attempted to call hasActiveSession() from the server but hasActiveSession is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/versotech-portal/src/lib/supabase/client.ts\",\n    \"hasActiveSession\",\n);\nexport const resetClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call resetClient() from the server but resetClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/versotech-portal/src/lib/supabase/client.ts\",\n    \"resetClient\",\n);\n","import { createClient } from '@/lib/supabase/client'\nimport type {\n  ConversationFilters,\n  ConversationMessage,\n  ConversationSummary,\n  MessageSender,\n} from '@/types/messaging'\n\ninterface FetchConversationsOptions extends ConversationFilters {\n  limit?: number\n  offset?: number\n  includeMessages?: boolean\n}\n\ninterface FetchConversationsResponse {\n  conversations: ConversationSummary[]\n  total: number\n  limit: number\n  offset: number\n  hasMore: boolean\n}\n\ninterface FetchMessagesOptions {\n  limit?: number\n  offset?: number\n}\n\nexport async function fetchConversationsClient(\n  filters: FetchConversationsOptions\n): Promise<FetchConversationsResponse> {\n  const params = new URLSearchParams()\n\n  if (filters.visibility) params.set('visibility', filters.visibility)\n  if (filters.type) params.set('type', filters.type)\n  if (filters.unreadOnly) params.set('unread', 'true')\n  if (filters.search) params.set('search', filters.search)\n  if (filters.dealId) params.set('dealId', filters.dealId)\n  if (typeof filters.limit === 'number') params.set('limit', String(filters.limit))\n  if (typeof filters.offset === 'number') params.set('offset', String(filters.offset))\n  if (filters.includeMessages === false) params.set('includeMessages', 'false')\n\n  const response = await fetch(`/api/conversations?${params.toString()}`, {\n    cache: 'no-store',\n  })\n\n  if (!response.ok) {\n    const error = await response.json().catch(() => null)\n    throw new Error(error?.error || 'Failed to load conversations')\n  }\n\n  const data = await response.json()\n\n  return {\n    conversations: data.conversations as ConversationSummary[],\n    total: data.pagination.total,\n    limit: data.pagination.limit,\n    offset: data.pagination.offset,\n    hasMore: data.pagination.has_more,\n  }\n}\n\nexport function normalizeConversation(raw: any): ConversationSummary {\n  const participants = Array.isArray(raw?.conversation_participants)\n    ? raw.conversation_participants.map((participant: any) => {\n        const profile = participant?.profiles || {}\n        return {\n          id: profile.id || participant.user_id,\n          displayName: profile.display_name || profile.email || null,\n          email: profile.email || null,\n          role: profile.role || null,\n          avatarUrl: profile.avatar_url ?? null,\n          participantRole: participant?.participant_role ?? 'member',\n          joinedAt: participant?.joined_at,\n          lastReadAt: participant?.last_read_at ?? null,\n          lastNotifiedAt: participant?.last_notified_at ?? null,\n          isMuted: participant?.is_muted ?? false,\n          isPinned: participant?.is_pinned ?? false,\n        }\n      })\n    : []\n\n  const latestMessageRaw = Array.isArray(raw?.messages) ? raw.messages[0] : null\n  const latestMessage = latestMessageRaw ? normalizeMessage(latestMessageRaw) : null\n\n  return {\n    id: raw.id,\n    subject: raw.subject ?? null,\n    preview: raw.preview ?? null,\n    type: raw.type ?? 'dm',\n    visibility: raw.visibility ?? 'internal',\n    ownerTeam: raw.owner_team ?? null,\n    dealId: raw.deal_id ?? null,\n    createdBy: raw.created_by ?? null,\n    createdAt: raw.created_at,\n    updatedAt: raw.updated_at,\n    lastMessageAt: raw.last_message_at ?? null,\n    lastMessageId: raw.last_message_id ?? null,\n    archivedAt: raw.archived_at ?? null,\n    metadata: raw.metadata ?? {},\n    participants,\n    unreadCount: raw.unreadCount ?? 0,\n    latestMessage,\n    participantCount: participants.length,\n  }\n}\n\nexport async function fetchConversationMessages(\n  conversationId: string,\n  options: FetchMessagesOptions = {}\n): Promise<ConversationMessage[]> {\n  const params = new URLSearchParams()\n  if (typeof options.limit === 'number') params.set('limit', String(options.limit))\n  if (typeof options.offset === 'number') params.set('offset', String(options.offset))\n\n  const response = await fetch(`/api/conversations/${conversationId}/messages?${params.toString()}`)\n\n  if (!response.ok) {\n    const error = await response.json().catch(() => null)\n    throw new Error(error?.error || 'Failed to fetch messages')\n  }\n\n  const data = await response.json()\n  return data.messages as ConversationMessage[]\n}\n\nexport async function markConversationRead(conversationId: string) {\n  await fetch(`/api/conversations/${conversationId}/read`, { method: 'POST' })\n}\n\nexport function getClientSupabase() {\n  return createClient()\n}\n\nexport function subscribeToConversationUpdates(\n  conversationId: string,\n  callbacks: {\n    onMessage?: (message: ConversationMessage) => void\n    onUpdate?: () => void\n  }\n) {\n  const supabase = createClient()\n\n  \n\n  const channel = supabase\n    .channel(`conversation-${conversationId}`)\n    .on(\n      'postgres_changes',\n      {\n        event: 'INSERT',\n        schema: 'public',\n        table: 'messages',\n        filter: `conversation_id=eq.${conversationId}`,\n      },\n      (payload) => {\n        if (payload.eventType === 'INSERT') {\n          callbacks.onMessage?.(normalizeMessage(payload.new))\n        }\n        callbacks.onUpdate?.()\n      }\n    )\n    .on(\n      'postgres_changes',\n      {\n        event: '*',\n        schema: 'public',\n        table: 'conversation_participants',\n        filter: `conversation_id=eq.${conversationId}`,\n      },\n      (payload) => {\n        callbacks.onUpdate?.()\n      }\n    )\n    .subscribe()\n\n  return () => {\n    supabase.removeChannel(channel)\n  }\n}\n\nexport function normalizeMessage(raw: any): ConversationMessage {\n  // Handle both API responses (with joined sender) and realtime events (without joins)\n  const sender = raw.sender as MessageSender | undefined\n\n  return {\n    id: raw.id,\n    conversationId: raw.conversation_id,\n    senderId: raw.sender_id,\n    body: raw.body ?? null,\n    messageType: raw.message_type ?? 'text',\n    fileKey: raw.file_key ?? null,\n    replyToMessageId: raw.reply_to_message_id ?? null,\n    metadata: raw.metadata ?? {},\n    createdAt: raw.created_at,\n    editedAt: raw.edited_at ?? null,\n    deletedAt: raw.deleted_at ?? null,\n    // Sender might not be available in realtime payloads, that's ok\n    sender: sender ? {\n      id: sender.id ?? null,\n      displayName: sender.displayName ?? (sender as any).display_name ?? null,\n      email: sender.email ?? null,\n      role: sender.role ?? null,\n      avatarUrl: sender.avatarUrl ?? (sender as any).avatar_url ?? null,\n    } : null,\n    readBy: Array.isArray(raw.read_by) ? raw.read_by : [],\n  }\n}\n\n\n","// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const MessagingClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call MessagingClient() from the server but MessagingClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/versotech-portal/src/components/messaging/staff/messaging-client.tsx\",\n    \"MessagingClient\",\n);\n","import { MessagingClient } from '@/components/messaging/staff/messaging-client'\nimport { requireAuth } from '@/lib/auth'\nimport { createServiceClient } from '@/lib/supabase/server'\nimport { normalizeConversation } from '@/lib/messaging/supabase'\n\nexport const dynamic = 'force-dynamic'\n\nexport default async function StaffMessages() {\n  const profile = await requireAuth(['staff_admin', 'staff_ops', 'staff_rm', 'ceo'])\n  const supabase = createServiceClient()\n\n  console.log('[Staff Messages Page] Loading conversations for user:', profile.id)\n\n  const { data, error } = await supabase\n    .from('conversations')\n    .select(`\n      *,\n      conversation_participants (\n        conversation_id,\n        user_id,\n        participant_role,\n        joined_at,\n        last_read_at,\n        last_notified_at,\n        is_muted,\n        is_pinned,\n        profiles:user_id (\n          id,\n          display_name,\n          email,\n          role,\n          avatar_url\n        )\n      ),\n      messages (\n        id,\n        conversation_id,\n        sender_id,\n        body,\n        message_type,\n        file_key,\n        reply_to_message_id,\n        metadata,\n        created_at,\n        edited_at,\n        deleted_at,\n        sender:sender_id (\n          id,\n          display_name,\n          email,\n          role,\n          avatar_url\n        )\n      )\n    `)\n    .order('last_message_at', { ascending: false, nullsFirst: false })\n    .order('created_at', { foreignTable: 'messages', ascending: false })\n    .limit(1, { foreignTable: 'messages' })\n    .limit(50)\n\n  if (error) {\n    console.error('[Staff Messages Page] Error loading conversations:', error)\n    throw new Error(error.message)\n  }\n\n  console.log('[Staff Messages Page] Loaded conversations:', data?.length || 0)\n\n  // Normalize conversations\n  const normalizedConversations = (data || []).map(normalizeConversation)\n\n  // Compute unread counts for staff\n  const conversationIds = normalizedConversations.map(conv => conv.id)\n  \n  if (conversationIds.length > 0) {\n    const { data: unreadData } = await supabase.rpc('get_conversation_unread_counts', {\n      p_user_id: profile.id,\n      p_conversation_ids: conversationIds,\n    })\n\n    const unreadMap = new Map<string, number>()\n    for (const row of unreadData || []) {\n      if (row?.conversation_id) {\n        unreadMap.set(row.conversation_id, Number(row.unread_count) || 0)\n      }\n    }\n\n    for (const conversation of normalizedConversations) {\n      conversation.unreadCount = unreadMap.get(conversation.id) ?? 0\n    }\n  }\n\n  return (\n    <MessagingClient initialConversations={normalizedConversations} currentUserId={profile.id} />\n    )\n}\n\n"],"names":[],"mappings":"gdACA,IAAA,EAAA,EAAA,CAAA,CAAA,QACO,IAAM,EAAe,CAAA,EAAA,EAAA,uBAAA,AAAuB,EAC/C,WAAa,MAAM,AAAI,MAAM,sOAAwO,EACrQ,4EACA,gBAES,EAAmB,CAAA,EAAA,EAAA,uBAAA,AAAuB,EACnD,WAAa,MAAM,AAAI,MAAM,8OAAgP,EAC7Q,4EACA,oBAES,EAAc,CAAA,EAAA,EAAA,uBAAA,AAAuB,EAC9C,WAAa,MAAM,AAAI,MAAM,oOAAsO,EACnQ,4EACA,iHAdJ,IAAA,EAAA,EAAA,CAAA,CAAA,QACO,IAAM,EAAe,CAAA,EAAA,EAAA,uBAAA,AAAuB,EAC/C,WAAa,MAAM,AAAI,MAAM,sOAAwO,EACrQ,wDACA,gBAES,EAAmB,CAAA,EAAA,EAAA,uBAAA,AAAuB,EACnD,WAAa,MAAM,AAAI,MAAM,8OAAgP,EAC7Q,wDACA,oBAES,EAAc,CAAA,EAAA,EAAA,uBAAA,AAAuB,EAC9C,WAAa,MAAM,AAAI,MAAM,oOAAsO,EACnQ,wDACA,sGC8CG,SAAS,EAAsB,CAAQ,MAuHb,GAAQ,KAtHjC,EAAe,MAAM,OAAO,CAAC,GAAK,2BACpC,EAAI,yBAAyB,CAAC,GAAG,CAAC,AAAC,IACjC,IAAM,EAAU,GAAa,UAAY,CAAC,EAC1C,MAAO,CACL,GAAI,EAAQ,EAAE,EAAI,EAAY,OAAO,CACrC,YAAa,EAAQ,YAAY,EAAI,EAAQ,KAAK,EAAI,KACtD,MAAO,EAAQ,KAAK,EAAI,KACxB,KAAM,EAAQ,IAAI,EAAI,KACtB,UAAW,EAAQ,UAAU,EAAI,KACjC,gBAAiB,GAAa,kBAAoB,SAClD,SAAU,GAAa,UACvB,WAAY,GAAa,cAAgB,KACzC,eAAgB,GAAa,kBAAoB,KACjD,QAAS,GAAa,WAAY,EAClC,SAAU,GAAa,WAAa,EACtC,CACF,GACA,EAAE,CAEA,EAAmB,MAAM,OAAO,CAAC,GAAK,UAAY,EAAI,QAAQ,CAAC,EAAE,CAAG,KACpE,EAAgB,GAoGhB,EAAS,GApG2C,GAoGvC,MAAM,CAElB,CACL,AAvGuC,GAuGnC,EAAI,EAAE,CACV,eAAgB,EAAI,eAAe,CACnC,SAAU,EAAI,SAAS,CACvB,KAAM,EAAI,IAAI,EAAI,KAClB,YAAa,EAAI,YAAY,EAAI,OACjC,QAAS,EAAI,QAAQ,EAAI,KACzB,iBAAkB,EAAI,mBAAmB,EAAI,KAC7C,SAAU,EAAI,QAAQ,EAAI,CAAC,EAC3B,UAAW,EAAI,UAAU,CACzB,SAAU,EAAI,SAAS,EAAI,KAC3B,UAAW,EAAI,UAAU,EAAI,KAE7B,OAAQ,EAAS,CACf,GAAI,EAAO,EAAE,EAAI,KACjB,YAAa,EAAO,WAAW,EAAK,EAAe,YAAY,EAAI,KACnE,MAAO,EAAO,KAAK,EAAI,KACvB,KAAM,EAAO,IAAI,EAAI,KACrB,UAAW,EAAO,SAAS,EAAK,EAAe,UAAU,EAAI,IAC/D,EAAI,KACJ,OAAQ,MAAM,OAAO,CAAC,EAAI,OAAO,EAAI,EAAI,OAAO,CAAG,EACrD,AADuD,GA1HuB,KAE9E,MAAO,CACL,GAAI,EAAI,EAAE,CACV,QAAS,EAAI,OAAO,EAAI,KACxB,QAAS,EAAI,OAAO,EAAI,KACxB,KAAM,EAAI,IAAI,EAAI,KAClB,WAAY,EAAI,UAAU,EAAI,WAC9B,UAAW,EAAI,UAAU,EAAI,KAC7B,OAAQ,EAAI,OAAO,EAAI,KACvB,UAAW,EAAI,UAAU,EAAI,KAC7B,UAAW,EAAI,UAAU,CACzB,UAAW,EAAI,UAAU,CACzB,cAAe,EAAI,eAAe,EAAI,KACtC,cAAe,EAAI,eAAe,EAAI,KACtC,WAAY,EAAI,WAAW,EAAI,KAC/B,SAAU,EAAI,QAAQ,EAAI,CAAC,eAC3B,EACA,YAAa,EAAI,WAAW,EAAI,gBAChC,EACA,iBAAkB,EAAa,MACjC,AADuC,CAEzC,CAxGA,EAAA,CAAA,CAAA,qGCEO,IAAM,EAAkB,CAAA,EAAA,AAD/B,EAAA,CAAA,CAAA,QAC+B,uBAAuB,AAAvB,EAC3B,WAAa,MAAM,AAAI,MAAM,4OAA8O,EAC3Q,qGACA,2EAHG,IAAM,EAAkB,CAAA,EAD/B,AAC+B,EAD/B,CAAA,CAAA,QAC+B,uBAAA,AAAuB,EAClD,WAAa,MAAM,AAAI,MAAM,4OAA8O,EAC3Q,iFACA,4HCLJ,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QAIe,eAAe,IAC5B,IAAM,EAAU,MAAM,CAAA,EAAA,EAAA,WAAA,AAAW,EAAC,CAAC,cAAe,YAAa,WAAY,MAAM,EAC3E,EAAW,CAAA,EAAA,EAAA,mBAAA,AAAmB,IAEpC,QAAQ,GAAG,CAAC,wDAAyD,EAAQ,EAAE,EAE/E,GAAM,CAAE,MAAI,OAAE,CAAK,CAAE,CAAG,MAAM,EAC3B,IAAI,CAAC,iBACL,MAAM,CAAC,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAuCT,CAAC,EACA,KAAK,CAAC,kBAAmB,CAAE,WAAW,EAAO,YAAY,CAAM,GAC/D,KAAK,CAAC,aAAc,CAAE,aAAc,WAAY,WAAW,CAAM,GACjE,KAAK,CAAC,EAAG,CAAE,aAAc,UAAW,GACpC,KAAK,CAAC,IAET,GAAI,EAEF,KAFS,CACT,QAAQ,KAAK,CAAC,qDAAsD,GAC9D,AAAI,MAAM,EAAM,OAAO,EAG/B,QAAQ,GAAG,CAAC,8CAA+C,GAAM,QAAU,GAG3E,IAAM,EAA0B,CAAC,GAAQ,EAAA,AAAE,EAAE,GAAG,CAAC,EAAA,qBAAqB,EAGhE,EAAkB,EAAwB,GAAG,CAAC,GAAQ,EAAK,EAAE,EAEnE,GAAI,EAAgB,MAAM,CAAG,EAAG,CAC9B,GAAM,CAAE,KAAM,CAAU,CAAE,CAAG,MAAM,EAAS,GAAG,CAAC,iCAAkC,CAChF,UAAW,EAAQ,EAAE,CACrB,mBAAoB,CACtB,GAEM,EAAY,IAAI,IACtB,IAAK,IAAM,KAAO,GAAc,EAAE,CAAE,AAC9B,GAAK,iBAAiB,AACxB,EAAU,GAAG,CAAC,EAAI,eAAe,CAAE,OAAO,EAAI,YAAY,GAAK,GAInE,IAAK,IAAM,KAAgB,EACzB,EAAa,WAAW,CAAG,EAAU,GAAG,CAAC,EADS,AACI,EAAE,GAAK,CAEjE,CAEA,MACE,CAAA,EAAA,EAAA,GAAA,EAAC,EAAA,eAAe,CAAA,CAAC,qBAAsB,EAAyB,cAAe,EAAQ,EAAE,EAE7F,kCAzFuB","ignoreList":[0,2]}