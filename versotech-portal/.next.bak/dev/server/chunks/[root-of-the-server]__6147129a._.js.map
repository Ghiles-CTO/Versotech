{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 82, "column": 0}, "map": {"version":3,"sources":["file:///Users/ghilesmoussaoui/Desktop/Versotech/versotech-portal/src/lib/supabase/server.ts"],"sourcesContent":["import { createServerClient } from '@supabase/ssr'\nimport { createClient as createSupabaseClient } from '@supabase/supabase-js'\nimport { cookies } from 'next/headers'\n\nexport const createClient = async () => {\n  const cookieStore = await cookies()\n\n  return createServerClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n    {\n      cookies: {\n        getAll() {\n          return cookieStore.getAll()\n        },\n        setAll(cookiesToSet) {\n          try {\n            cookiesToSet.forEach(({ name, value, options }) => {\n              cookieStore.set(name, value, options)\n            })\n          } catch (error) {\n            // The `setAll` method was called from a Server Component.\n            // This can be ignored if you have middleware refreshing\n            // user sessions.\n          }\n        },\n      },\n    }\n  )\n}\n\n// Server client with service role for admin operations\n// Uses raw supabase-js client which properly bypasses RLS with service role\nexport const createServiceClient = () => {\n  return createSupabaseClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.SUPABASE_SERVICE_ROLE_KEY!,\n    {\n      auth: {\n        autoRefreshToken: false,\n        persistSession: false,\n      },\n    }\n  )\n}\n"],"names":[],"mappings":";;;;;;AAAA;AAAA;AACA;AACA;;;;AAEO,MAAM,eAAe;IAC1B,MAAM,cAAc,MAAM,IAAA,mKAAO;IAEjC,OAAO,IAAA,wNAAkB,sUAGvB;QACE,SAAS;YACP;gBACE,OAAO,YAAY,MAAM;YAC3B;YACA,QAAO,YAAY;gBACjB,IAAI;oBACF,aAAa,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE;wBAC5C,YAAY,GAAG,CAAC,MAAM,OAAO;oBAC/B;gBACF,EAAE,OAAO,OAAO;gBACd,0DAA0D;gBAC1D,wDAAwD;gBACxD,iBAAiB;gBACnB;YACF;QACF;IACF;AAEJ;AAIO,MAAM,sBAAsB;IACjC,OAAO,IAAA,gOAAoB,gFAEzB,QAAQ,GAAG,CAAC,yBAAyB,EACrC;QACE,MAAM;YACJ,kBAAkB;YAClB,gBAAgB;QAClB;IACF;AAEJ"}},
    {"offset": {"line": 134, "column": 0}, "map": {"version":3,"sources":["file:///Users/ghilesmoussaoui/Desktop/Versotech/versotech-portal/src/lib/auth.ts"],"sourcesContent":["import { createServerClient } from '@supabase/ssr'\r\nimport { cookies } from 'next/headers'\r\nimport { redirect } from 'next/navigation'\r\nimport type { User, Session } from '@supabase/supabase-js'\r\n\r\n// Profile roles (stored in profiles.role)\r\nexport type ProfileRole =\r\n  | 'investor'\r\n  | 'staff_admin'\r\n  | 'staff_ops'\r\n  | 'staff_rm'\r\n  | 'arranger'\r\n  | 'introducer'\r\n  | 'partner'\r\n  | 'commercial_partner'\r\n  | 'lawyer'\r\n  | 'ceo'\r\n\r\n// All persona types (from get_user_personas())\r\nexport type PersonaType = 'staff' | 'investor' | 'arranger' | 'introducer' | 'partner' | 'commercial_partner' | 'lawyer'\r\n\r\n// UserRole = ProfileRole for backward compatibility\r\nexport type UserRole = ProfileRole\r\n\r\nconst STAFF_ROLES: ProfileRole[] = ['staff_admin', 'staff_ops', 'staff_rm', 'ceo']\r\n\r\nexport interface AuthUser {\r\n  id: string\r\n  email: string\r\n  displayName: string\r\n  avatar?: string\r\n  role: UserRole\r\n  title?: string\r\n  created_at: string\r\n  permissions?: string[]\r\n}\r\n\r\n// Alias for backward compatibility\r\nexport type Profile = AuthUser\r\n\r\nexport interface AuthSession {\r\n  user: AuthUser\r\n  session: Session\r\n}\r\n\r\nexport class AuthError extends Error {\r\n  constructor(message: string, public code?: string) {\r\n    super(message)\r\n    this.name = 'AuthError'\r\n  }\r\n}\r\n\r\n// Server-side Supabase client\r\nconst createServerSupabaseClient = async () => {\r\n  const cookieStore = await cookies()\r\n\r\n  return createServerClient(\r\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\r\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\r\n    {\r\n      cookies: {\r\n        getAll() {\r\n          return cookieStore.getAll()\r\n        },\r\n        setAll(cookiesToSet) {\r\n          try {\r\n            cookiesToSet.forEach(({ name, value, options }) =>\r\n              cookieStore.set(name, value, options)\r\n            )\r\n          } catch {\r\n            // The `setAll` method was called from a Server Component.\r\n            // This can be ignored if you have middleware refreshing\r\n            // user sessions.\r\n          }\r\n        },\r\n      },\r\n    }\r\n  )\r\n}\r\n\r\n// Get current user with profile data\r\nexport async function getCurrentUser(): Promise<AuthUser | null> {\r\n  try {\r\n    const supabase = await createServerSupabaseClient()\r\n\r\n    // Get current auth user\r\n    const { data: { user }, error: userError } = await supabase.auth.getUser()\r\n\r\n    if (userError || !user) {\r\n      return null\r\n    }\r\n\r\n    // Get profile data from database\r\n    const { data: profile, error: profileError } = await supabase\r\n      .from('profiles')\r\n      .select('*')\r\n      .eq('id', user.id)\r\n      .single()\r\n\r\n    if (profileError || !profile) {\r\n      console.error('[auth] Profile not found for user:', user.id, profileError)\r\n      return null\r\n    }\r\n\r\n    // Fetch permissions for staff users\r\n    let permissions: string[] = []\r\n    const isStaffRole = STAFF_ROLES.includes(profile.role)\r\n\r\n    if (isStaffRole) {\r\n      const { data: permissionsData } = await supabase\r\n        .from('staff_permissions')\r\n        .select('permission')\r\n        .eq('user_id', user.id)\r\n\r\n      permissions = permissionsData?.map(p => p.permission) || []\r\n    }\r\n\r\n    return {\r\n      id: profile.id,\r\n      email: profile.email,\r\n      displayName: profile.display_name || profile.email?.split('@')[0] || 'User',\r\n      avatar: profile.avatar_url,\r\n      role: profile.role as UserRole,\r\n      title: profile.title,\r\n      created_at: profile.created_at,\r\n      permissions\r\n    }\r\n  } catch (error) {\r\n    console.error('Error getting current user:', error)\r\n    return null\r\n  }\r\n}\r\n\r\n// Get current session\r\nexport async function getCurrentSession(): Promise<Session | null> {\r\n  try {\r\n    const supabase = await createServerSupabaseClient()\r\n\r\n    const { data: { session }, error } = await supabase.auth.getSession()\r\n\r\n    if (error) {\r\n      console.error('Error getting session:', error)\r\n      return null\r\n    }\r\n\r\n    return session\r\n  } catch (error) {\r\n    console.error('Error getting session:', error)\r\n    return null\r\n  }\r\n}\r\n\r\n// Get profile (alias for getCurrentUser for backward compatibility)\r\nexport async function getProfile(): Promise<AuthUser | null> {\r\n  const user = await getCurrentUser()\r\n  if (user) {\r\n    console.log('[auth] Profile retrieved:', user.email, user.role)\r\n  } else {\r\n    console.log('[auth] No profile found')\r\n  }\r\n  return user\r\n}\r\n\r\n// Require authentication\r\nexport async function requireAuth(allowedRoles?: UserRole[]) {\r\n  const user = await getCurrentUser()\r\n\r\n  if (!user) {\r\n    redirect('/versotech_main/login')\r\n  }\r\n\r\n  if (allowedRoles && !allowedRoles.includes(user.role)) {\r\n    throw new Error('Insufficient permissions')\r\n  }\r\n\r\n  return user\r\n}\r\n\r\n// Require investor auth\r\nexport async function requireInvestorAuth() {\r\n  const user = await getCurrentUser()\r\n\r\n  if (!user) {\r\n    redirect('/versotech_main/login')\r\n  }\r\n\r\n  if (user.role !== 'investor') {\r\n    throw new Error('Investor access required')\r\n  }\r\n\r\n  return user\r\n}\r\n\r\n// Require staff auth\r\nexport async function requireStaffAuth() {\r\n  const user = await getCurrentUser()\r\n\r\n  if (!user) {\r\n    redirect('/versotech_main/login')\r\n  }\r\n\r\n  if (!STAFF_ROLES.includes(user.role)) {\r\n    throw new Error('Staff access required')\r\n  }\r\n\r\n  return user\r\n}\r\n\r\n/**\r\n * Check if a user has staff-level access for page authorization.\r\n *\r\n * IMPORTANT: Staff users (staff_admin, ceo, staff_ops, staff_rm) don't have\r\n * traditional database persona entries. Their \"personas\" are created synthetically\r\n * in the layout. This function checks BOTH:\r\n * 1. Profile role (for staff users without persona entries)\r\n * 2. Database personas (for users with explicit staff/ceo persona entries)\r\n *\r\n * @param userId - The user's ID\r\n * @returns true if user has staff access (via role OR persona)\r\n */\r\nexport async function checkStaffAccess(userId: string): Promise<boolean> {\r\n  const supabase = await createServerSupabaseClient()\r\n\r\n  // Check profile role first (handles synthetic staff personas)\r\n  const { data: profile, error: profileError } = await supabase\r\n    .from('profiles')\r\n    .select('role')\r\n    .eq('id', userId)\r\n    .single()\r\n\r\n  if (!profileError && profile && STAFF_ROLES.includes(profile.role as ProfileRole)) {\r\n    return true\r\n  }\r\n\r\n  // Fallback: check database personas (for edge cases)\r\n  const { data: personas } = await supabase.rpc('get_user_personas', {\r\n    p_user_id: userId\r\n  })\r\n\r\n  return personas?.some(\r\n    (p: { persona_type: string }) => p.persona_type === 'staff' || p.persona_type === 'ceo'\r\n  ) || false\r\n}\r\n\r\n/**\r\n * Check if a user has CEO-level access (full admin access).\r\n * CEO access is granted to users with 'ceo' or 'staff_admin' profile roles.\r\n */\r\nexport async function checkCeoAccess(userId: string): Promise<boolean> {\r\n  const supabase = await createServerSupabaseClient()\r\n\r\n  const { data: profile } = await supabase\r\n    .from('profiles')\r\n    .select('role')\r\n    .eq('id', userId)\r\n    .single()\r\n\r\n  return profile?.role === 'ceo' || profile?.role === 'staff_admin'\r\n}\r\n\r\n// Export STAFF_ROLES for use in pages\r\nexport { STAFF_ROLES }\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AACA;AACA;AAAA;;;;AAsBA,MAAM,cAA6B;IAAC;IAAe;IAAa;IAAY;CAAM;AAqB3E,MAAM,kBAAkB;;IAC7B,YAAY,OAAe,EAAE,AAAO,IAAa,CAAE;QACjD,KAAK,CAAC,eAD4B,OAAA;QAElC,IAAI,CAAC,IAAI,GAAG;IACd;AACF;AAEA,8BAA8B;AAC9B,MAAM,6BAA6B;IACjC,MAAM,cAAc,MAAM,IAAA,mKAAO;IAEjC,OAAO,IAAA,wNAAkB,sUAGvB;QACE,SAAS;YACP;gBACE,OAAO,YAAY,MAAM;YAC3B;YACA,QAAO,YAAY;gBACjB,IAAI;oBACF,aAAa,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE,GAC5C,YAAY,GAAG,CAAC,MAAM,OAAO;gBAEjC,EAAE,OAAM;gBACN,0DAA0D;gBAC1D,wDAAwD;gBACxD,iBAAiB;gBACnB;YACF;QACF;IACF;AAEJ;AAGO,eAAe;IACpB,IAAI;QACF,MAAM,WAAW,MAAM;QAEvB,wBAAwB;QACxB,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,EAAE,OAAO,SAAS,EAAE,GAAG,MAAM,SAAS,IAAI,CAAC,OAAO;QAExE,IAAI,aAAa,CAAC,MAAM;YACtB,OAAO;QACT;QAEA,iCAAiC;QACjC,MAAM,EAAE,MAAM,OAAO,EAAE,OAAO,YAAY,EAAE,GAAG,MAAM,SAClD,IAAI,CAAC,YACL,MAAM,CAAC,KACP,EAAE,CAAC,MAAM,KAAK,EAAE,EAChB,MAAM;QAET,IAAI,gBAAgB,CAAC,SAAS;YAC5B,QAAQ,KAAK,CAAC,sCAAsC,KAAK,EAAE,EAAE;YAC7D,OAAO;QACT;QAEA,oCAAoC;QACpC,IAAI,cAAwB,EAAE;QAC9B,MAAM,cAAc,YAAY,QAAQ,CAAC,QAAQ,IAAI;QAErD,IAAI,aAAa;YACf,MAAM,EAAE,MAAM,eAAe,EAAE,GAAG,MAAM,SACrC,IAAI,CAAC,qBACL,MAAM,CAAC,cACP,EAAE,CAAC,WAAW,KAAK,EAAE;YAExB,cAAc,iBAAiB,IAAI,CAAA,IAAK,EAAE,UAAU,KAAK,EAAE;QAC7D;QAEA,OAAO;YACL,IAAI,QAAQ,EAAE;YACd,OAAO,QAAQ,KAAK;YACpB,aAAa,QAAQ,YAAY,IAAI,QAAQ,KAAK,EAAE,MAAM,IAAI,CAAC,EAAE,IAAI;YACrE,QAAQ,QAAQ,UAAU;YAC1B,MAAM,QAAQ,IAAI;YAClB,OAAO,QAAQ,KAAK;YACpB,YAAY,QAAQ,UAAU;YAC9B;QACF;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,+BAA+B;QAC7C,OAAO;IACT;AACF;AAGO,eAAe;IACpB,IAAI;QACF,MAAM,WAAW,MAAM;QAEvB,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,EAAE,KAAK,EAAE,GAAG,MAAM,SAAS,IAAI,CAAC,UAAU;QAEnE,IAAI,OAAO;YACT,QAAQ,KAAK,CAAC,0BAA0B;YACxC,OAAO;QACT;QAEA,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,0BAA0B;QACxC,OAAO;IACT;AACF;AAGO,eAAe;IACpB,MAAM,OAAO,MAAM;IACnB,IAAI,MAAM;QACR,QAAQ,GAAG,CAAC,6BAA6B,KAAK,KAAK,EAAE,KAAK,IAAI;IAChE,OAAO;QACL,QAAQ,GAAG,CAAC;IACd;IACA,OAAO;AACT;AAGO,eAAe,YAAY,YAAyB;IACzD,MAAM,OAAO,MAAM;IAEnB,IAAI,CAAC,MAAM;QACT,IAAA,0NAAQ,EAAC;IACX;IAEA,IAAI,gBAAgB,CAAC,aAAa,QAAQ,CAAC,KAAK,IAAI,GAAG;QACrD,MAAM,IAAI,MAAM;IAClB;IAEA,OAAO;AACT;AAGO,eAAe;IACpB,MAAM,OAAO,MAAM;IAEnB,IAAI,CAAC,MAAM;QACT,IAAA,0NAAQ,EAAC;IACX;IAEA,IAAI,KAAK,IAAI,KAAK,YAAY;QAC5B,MAAM,IAAI,MAAM;IAClB;IAEA,OAAO;AACT;AAGO,eAAe;IACpB,MAAM,OAAO,MAAM;IAEnB,IAAI,CAAC,MAAM;QACT,IAAA,0NAAQ,EAAC;IACX;IAEA,IAAI,CAAC,YAAY,QAAQ,CAAC,KAAK,IAAI,GAAG;QACpC,MAAM,IAAI,MAAM;IAClB;IAEA,OAAO;AACT;AAcO,eAAe,iBAAiB,MAAc;IACnD,MAAM,WAAW,MAAM;IAEvB,8DAA8D;IAC9D,MAAM,EAAE,MAAM,OAAO,EAAE,OAAO,YAAY,EAAE,GAAG,MAAM,SAClD,IAAI,CAAC,YACL,MAAM,CAAC,QACP,EAAE,CAAC,MAAM,QACT,MAAM;IAET,IAAI,CAAC,gBAAgB,WAAW,YAAY,QAAQ,CAAC,QAAQ,IAAI,GAAkB;QACjF,OAAO;IACT;IAEA,qDAAqD;IACrD,MAAM,EAAE,MAAM,QAAQ,EAAE,GAAG,MAAM,SAAS,GAAG,CAAC,qBAAqB;QACjE,WAAW;IACb;IAEA,OAAO,UAAU,KACf,CAAC,IAAgC,EAAE,YAAY,KAAK,WAAW,EAAE,YAAY,KAAK,UAC/E;AACP;AAMO,eAAe,eAAe,MAAc;IACjD,MAAM,WAAW,MAAM;IAEvB,MAAM,EAAE,MAAM,OAAO,EAAE,GAAG,MAAM,SAC7B,IAAI,CAAC,YACL,MAAM,CAAC,QACP,EAAE,CAAC,MAAM,QACT,MAAM;IAET,OAAO,SAAS,SAAS,SAAS,SAAS,SAAS;AACtD"}},
    {"offset": {"line": 309, "column": 0}, "map": {"version":3,"sources":["file:///Users/ghilesmoussaoui/Desktop/Versotech/versotech-portal/src/app/api/admin/growth/cohorts/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server'\r\nimport { createServiceClient } from '@/lib/supabase/server'\r\nimport { getCurrentUser } from '@/lib/auth'\r\n\r\ntype GroupBy = 'signup_week' | 'signup_month' | 'first_investment_month'\r\n\r\ninterface Profile {\r\n  id: string\r\n  created_at: string\r\n  display_name: string | null\r\n}\r\n\r\ninterface InvestorUser {\r\n  user_id: string\r\n  investor_id: string\r\n}\r\n\r\ninterface Subscription {\r\n  investor_id: string\r\n  commitment: number | null\r\n  created_at: string\r\n}\r\n\r\ninterface ActivityLog {\r\n  actor_id: string\r\n  created_at: string\r\n}\r\n\r\ninterface Cohort {\r\n  cohortName: string\r\n  size: number\r\n  activationRate: number\r\n  investmentRate: number\r\n  avgInvestment: number\r\n  avgTimeToFirstInvestment: number | null\r\n  retention30d: number\r\n  retention60d: number\r\n  retention90d: number\r\n}\r\n\r\nexport async function GET(request: NextRequest) {\r\n  try {\r\n    const user = await getCurrentUser()\r\n    if (!user) {\r\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\r\n    }\r\n\r\n    const supabase = createServiceClient()\r\n\r\n    // Check if user is super admin\r\n    const { data: permission } = await supabase\r\n      .from('staff_permissions')\r\n      .select('permission')\r\n      .eq('user_id', user.id)\r\n      .eq('permission', 'super_admin')\r\n      .single()\r\n\r\n    if (!permission) {\r\n      return NextResponse.json({ error: 'Forbidden' }, { status: 403 })\r\n    }\r\n\r\n    // Parse groupBy parameter\r\n    const { searchParams } = new URL(request.url)\r\n    const groupByParam = searchParams.get('groupBy') || 'signup_month'\r\n    const groupBy: GroupBy = ['signup_week', 'signup_month', 'first_investment_month'].includes(groupByParam)\r\n      ? (groupByParam as GroupBy)\r\n      : 'signup_month'\r\n\r\n    // ===== Fetch all necessary data =====\r\n\r\n    // 1. Fetch all profiles (non-deleted)\r\n    const { data: profiles } = await supabase\r\n      .from('profiles')\r\n      .select('id, created_at, display_name')\r\n      .is('deleted_at', null)\r\n      .order('created_at', { ascending: true }) as { data: Profile[] | null }\r\n\r\n    const allProfiles = profiles || []\r\n\r\n    // 2. Fetch investor_users to map users to investors\r\n    const { data: investorUsers } = await supabase\r\n      .from('investor_users')\r\n      .select('user_id, investor_id') as { data: InvestorUser[] | null }\r\n\r\n    const userToInvestors: Record<string, string[]> = {}\r\n    investorUsers?.forEach((iu) => {\r\n      if (!userToInvestors[iu.user_id]) {\r\n        userToInvestors[iu.user_id] = []\r\n      }\r\n      userToInvestors[iu.user_id].push(iu.investor_id)\r\n    })\r\n\r\n    // 3. Fetch all subscriptions for investment data\r\n    const { data: subscriptions } = await supabase\r\n      .from('subscriptions')\r\n      .select('investor_id, commitment, created_at')\r\n      .order('created_at', { ascending: true }) as { data: Subscription[] | null }\r\n\r\n    // Map investor to their first subscription and total investment\r\n    const investorFirstSubscription: Record<string, Date> = {}\r\n    const investorTotalInvestment: Record<string, number> = {}\r\n\r\n    subscriptions?.forEach((sub) => {\r\n      const subDate = new Date(sub.created_at)\r\n\r\n      // Track first subscription date\r\n      if (!investorFirstSubscription[sub.investor_id] || subDate < investorFirstSubscription[sub.investor_id]) {\r\n        investorFirstSubscription[sub.investor_id] = subDate\r\n      }\r\n\r\n      // Sum up total investment\r\n      const amount = Number(sub.commitment) || 0\r\n      investorTotalInvestment[sub.investor_id] = (investorTotalInvestment[sub.investor_id] || 0) + amount\r\n    })\r\n\r\n    // 4. Fetch audit logs for retention calculations (last 120 days)\r\n    const now = new Date()\r\n    const day120Ago = new Date(now.getTime() - 120 * 24 * 60 * 60 * 1000)\r\n\r\n    const { data: activityLogs } = await supabase\r\n      .from('audit_logs')\r\n      .select('actor_id, created_at')\r\n      .gte('created_at', day120Ago.toISOString())\r\n      .not('actor_id', 'is', null)\r\n      .order('created_at', { ascending: true })\r\n      .limit(500000) as { data: ActivityLog[] | null }\r\n\r\n    // Build user activity dates map\r\n    const userLastActivityDate: Record<string, Date> = {}\r\n    activityLogs?.forEach((log) => {\r\n      const logDate = new Date(log.created_at)\r\n      if (!userLastActivityDate[log.actor_id] || logDate > userLastActivityDate[log.actor_id]) {\r\n        userLastActivityDate[log.actor_id] = logDate\r\n      }\r\n    })\r\n\r\n    // ===== Group users into cohorts =====\r\n    const cohortGroups: Record<string, Profile[]> = {}\r\n\r\n    if (groupBy === 'signup_week' || groupBy === 'signup_month') {\r\n      // Group by signup date\r\n      allProfiles.forEach((profile) => {\r\n        const signupDate = new Date(profile.created_at)\r\n        const cohortKey = groupBy === 'signup_week'\r\n          ? getWeekKey(signupDate)\r\n          : getMonthKey(signupDate)\r\n\r\n        if (!cohortGroups[cohortKey]) {\r\n          cohortGroups[cohortKey] = []\r\n        }\r\n        cohortGroups[cohortKey].push(profile)\r\n      })\r\n    } else {\r\n      // Group by first investment month\r\n      // First, map users to their first investment date\r\n      allProfiles.forEach((profile) => {\r\n        const investorIds = userToInvestors[profile.id] || []\r\n\r\n        // Find earliest investment date for this user\r\n        let earliestInvestmentDate: Date | null = null\r\n        investorIds.forEach((investorId) => {\r\n          const firstSub = investorFirstSubscription[investorId]\r\n          if (firstSub && (!earliestInvestmentDate || firstSub < earliestInvestmentDate)) {\r\n            earliestInvestmentDate = firstSub\r\n          }\r\n        })\r\n\r\n        if (earliestInvestmentDate) {\r\n          const cohortKey = getMonthKey(earliestInvestmentDate)\r\n          if (!cohortGroups[cohortKey]) {\r\n            cohortGroups[cohortKey] = []\r\n          }\r\n          cohortGroups[cohortKey].push(profile)\r\n        }\r\n      })\r\n    }\r\n\r\n    // ===== Calculate metrics for each cohort =====\r\n    const cohorts: Cohort[] = []\r\n\r\n    // Sort cohort keys chronologically\r\n    const sortedCohortKeys = Object.keys(cohortGroups).sort()\r\n\r\n    for (const cohortKey of sortedCohortKeys) {\r\n      const cohortUsers = cohortGroups[cohortKey]\r\n      const size = cohortUsers.length\r\n\r\n      if (size === 0) continue\r\n\r\n      // 1. Activation Rate: users with display_name filled\r\n      const activatedCount = cohortUsers.filter(\r\n        (u) => u.display_name && u.display_name.trim() !== ''\r\n      ).length\r\n      const activationRate = Math.round((activatedCount / size) * 100 * 10) / 10\r\n\r\n      // 2. Investment Rate: users who have made any subscription\r\n      let investorsCount = 0\r\n      let totalInvestment = 0\r\n      let totalTimeToFirstInvestment = 0\r\n      let usersWithInvestment = 0\r\n\r\n      cohortUsers.forEach((profile) => {\r\n        const investorIds = userToInvestors[profile.id] || []\r\n        const hasInvestment = investorIds.some((id) => investorFirstSubscription[id])\r\n\r\n        if (hasInvestment) {\r\n          investorsCount++\r\n\r\n          // Calculate total investment for this user\r\n          investorIds.forEach((investorId) => {\r\n            totalInvestment += investorTotalInvestment[investorId] || 0\r\n          })\r\n\r\n          // Calculate time to first investment\r\n          const signupDate = new Date(profile.created_at)\r\n          const earliestInvestment = investorIds.reduce<Date | null>((earliest, investorId) => {\r\n            const firstSub = investorFirstSubscription[investorId]\r\n            if (firstSub && (!earliest || firstSub < earliest)) {\r\n              return firstSub\r\n            }\r\n            return earliest\r\n          }, null)\r\n\r\n          if (earliestInvestment !== null) {\r\n            const daysToInvest = Math.floor(\r\n              (earliestInvestment.getTime() - signupDate.getTime()) / (1000 * 60 * 60 * 24)\r\n            )\r\n            totalTimeToFirstInvestment += Math.max(0, daysToInvest) // Ensure non-negative\r\n            usersWithInvestment++\r\n          }\r\n        }\r\n      })\r\n\r\n      const investmentRate = Math.round((investorsCount / size) * 100 * 10) / 10\r\n      const avgInvestment = investorsCount > 0\r\n        ? Math.round(totalInvestment / investorsCount)\r\n        : 0\r\n      const avgTimeToFirstInvestment = usersWithInvestment > 0\r\n        ? Math.round(totalTimeToFirstInvestment / usersWithInvestment)\r\n        : null\r\n\r\n      // 3. Retention rates: check activity at 30, 60, 90 days after cohort start\r\n      const cohortStartDate = getCohortStartDate(cohortKey, groupBy)\r\n\r\n      const day30 = new Date(cohortStartDate.getTime() + 30 * 24 * 60 * 60 * 1000)\r\n      const day60 = new Date(cohortStartDate.getTime() + 60 * 24 * 60 * 60 * 1000)\r\n      const day90 = new Date(cohortStartDate.getTime() + 90 * 24 * 60 * 60 * 1000)\r\n\r\n      // Count users still active at each retention checkpoint\r\n      // Active = had activity within 7 days of the checkpoint\r\n      const activeAt30 = cohortUsers.filter((u) => {\r\n        const lastActivity = userLastActivityDate[u.id]\r\n        if (!lastActivity) return false\r\n        const windowStart = new Date(day30.getTime() - 7 * 24 * 60 * 60 * 1000)\r\n        return lastActivity >= windowStart && lastActivity <= day30\r\n      }).length\r\n\r\n      const activeAt60 = cohortUsers.filter((u) => {\r\n        const lastActivity = userLastActivityDate[u.id]\r\n        if (!lastActivity) return false\r\n        const windowStart = new Date(day60.getTime() - 7 * 24 * 60 * 60 * 1000)\r\n        return lastActivity >= windowStart && lastActivity <= day60\r\n      }).length\r\n\r\n      const activeAt90 = cohortUsers.filter((u) => {\r\n        const lastActivity = userLastActivityDate[u.id]\r\n        if (!lastActivity) return false\r\n        const windowStart = new Date(day90.getTime() - 7 * 24 * 60 * 60 * 1000)\r\n        return lastActivity >= windowStart && lastActivity <= day90\r\n      }).length\r\n\r\n      // Only calculate retention if enough time has passed\r\n      const retention30d = day30 <= now\r\n        ? Math.round((activeAt30 / size) * 100 * 10) / 10\r\n        : -1 // -1 indicates not enough time has passed\r\n      const retention60d = day60 <= now\r\n        ? Math.round((activeAt60 / size) * 100 * 10) / 10\r\n        : -1\r\n      const retention90d = day90 <= now\r\n        ? Math.round((activeAt90 / size) * 100 * 10) / 10\r\n        : -1\r\n\r\n      cohorts.push({\r\n        cohortName: formatCohortName(cohortKey, groupBy),\r\n        size,\r\n        activationRate,\r\n        investmentRate,\r\n        avgInvestment,\r\n        avgTimeToFirstInvestment,\r\n        retention30d,\r\n        retention60d,\r\n        retention90d,\r\n      })\r\n    }\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      data: {\r\n        groupBy,\r\n        cohorts,\r\n      },\r\n    })\r\n  } catch (error) {\r\n    console.error('Cohorts metrics error:', error)\r\n    return NextResponse.json(\r\n      { error: 'Failed to fetch cohort metrics' },\r\n      { status: 500 }\r\n    )\r\n  }\r\n}\r\n\r\n// ===== Helper functions =====\r\n\r\n/**\r\n * Get a sortable week key in format YYYY-WXX\r\n */\r\nfunction getWeekKey(date: Date): string {\r\n  const year = date.getFullYear()\r\n  const startOfYear = new Date(year, 0, 1)\r\n  const dayOfYear = Math.floor((date.getTime() - startOfYear.getTime()) / (1000 * 60 * 60 * 24))\r\n  const weekNumber = Math.ceil((dayOfYear + 1) / 7)\r\n  return `${year}-W${String(weekNumber).padStart(2, '0')}`\r\n}\r\n\r\n/**\r\n * Get a sortable month key in format YYYY-MM\r\n */\r\nfunction getMonthKey(date: Date): string {\r\n  const year = date.getFullYear()\r\n  const month = date.getMonth() + 1\r\n  return `${year}-${String(month).padStart(2, '0')}`\r\n}\r\n\r\n/**\r\n * Parse cohort key back to start date\r\n */\r\nfunction getCohortStartDate(cohortKey: string, groupBy: GroupBy): Date {\r\n  if (groupBy === 'signup_week') {\r\n    // Parse YYYY-WXX format\r\n    const [yearStr, weekStr] = cohortKey.split('-W')\r\n    const year = parseInt(yearStr)\r\n    const week = parseInt(weekStr)\r\n    const startOfYear = new Date(year, 0, 1)\r\n    const daysOffset = (week - 1) * 7\r\n    return new Date(startOfYear.getTime() + daysOffset * 24 * 60 * 60 * 1000)\r\n  } else {\r\n    // Parse YYYY-MM format\r\n    const [yearStr, monthStr] = cohortKey.split('-')\r\n    return new Date(parseInt(yearStr), parseInt(monthStr) - 1, 1)\r\n  }\r\n}\r\n\r\n/**\r\n * Format cohort key for human-readable display\r\n */\r\nfunction formatCohortName(cohortKey: string, groupBy: GroupBy): string {\r\n  if (groupBy === 'signup_week') {\r\n    // Convert YYYY-WXX to \"Week of MMM D, YYYY\"\r\n    const startDate = getCohortStartDate(cohortKey, groupBy)\r\n    const month = startDate.toLocaleString('en-US', { month: 'short' })\r\n    const day = startDate.getDate()\r\n    const year = startDate.getFullYear()\r\n    return `Week of ${month} ${day}, ${year}`\r\n  } else {\r\n    // Convert YYYY-MM to \"MMM YYYY\"\r\n    const [yearStr, monthStr] = cohortKey.split('-')\r\n    const date = new Date(parseInt(yearStr), parseInt(monthStr) - 1, 1)\r\n    return date.toLocaleString('en-US', { month: 'short', year: 'numeric' })\r\n  }\r\n}\r\n"],"names":[],"mappings":"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"}}]
}