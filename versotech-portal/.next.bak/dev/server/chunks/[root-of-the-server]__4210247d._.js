module.exports = [
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/stream [external] (stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}),
"[externals]/http [external] (http, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}),
"[externals]/url [external] (url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}),
"[externals]/punycode [external] (punycode, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("punycode", () => require("punycode"));

module.exports = mod;
}),
"[externals]/https [external] (https, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}),
"[externals]/zlib [external] (zlib, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}),
"[project]/versotech-portal/src/lib/supabase/server.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createClient",
    ()=>createClient,
    "createServiceClient",
    ()=>createServiceClient
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f40$supabase$2f$ssr$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/versotech-portal/node_modules/@supabase/ssr/dist/module/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f40$supabase$2f$ssr$2f$dist$2f$module$2f$createServerClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/versotech-portal/node_modules/@supabase/ssr/dist/module/createServerClient.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/versotech-portal/node_modules/@supabase/supabase-js/dist/module/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/versotech-portal/node_modules/next/headers.js [app-route] (ecmascript)");
;
;
;
const createClient = async ()=>{
    const cookieStore = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["cookies"])();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f40$supabase$2f$ssr$2f$dist$2f$module$2f$createServerClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createServerClient"])(("TURBOPACK compile-time value", "https://ipguxdssecfexudnvtia.supabase.co"), ("TURBOPACK compile-time value", "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImlwZ3V4ZHNzZWNmZXh1ZG52dGlhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgzNjE4MzcsImV4cCI6MjA3MzkzNzgzN30.AGxM_YW9hfxuu7xDpi_4xhOoRhYM7iGTS1vJ0z2FByE"), {
        cookies: {
            getAll () {
                return cookieStore.getAll();
            },
            setAll (cookiesToSet) {
                try {
                    cookiesToSet.forEach(({ name, value, options })=>{
                        cookieStore.set(name, value, options);
                    });
                } catch (error) {
                // The `setAll` method was called from a Server Component.
                // This can be ignored if you have middleware refreshing
                // user sessions.
                }
            }
        }
    });
};
const createServiceClient = ()=>{
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createClient"])(("TURBOPACK compile-time value", "https://ipguxdssecfexudnvtia.supabase.co"), process.env.SUPABASE_SERVICE_ROLE_KEY, {
        auth: {
            autoRefreshToken: false,
            persistSession: false
        }
    });
};
}),
"[externals]/next/dist/server/app-render/action-async-storage.external.js [external] (next/dist/server/app-render/action-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/action-async-storage.external.js", () => require("next/dist/server/app-render/action-async-storage.external.js"));

module.exports = mod;
}),
"[project]/versotech-portal/src/lib/auth.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AuthError",
    ()=>AuthError,
    "STAFF_ROLES",
    ()=>STAFF_ROLES,
    "checkCeoAccess",
    ()=>checkCeoAccess,
    "checkStaffAccess",
    ()=>checkStaffAccess,
    "getCurrentSession",
    ()=>getCurrentSession,
    "getCurrentUser",
    ()=>getCurrentUser,
    "getProfile",
    ()=>getProfile,
    "requireAuth",
    ()=>requireAuth,
    "requireInvestorAuth",
    ()=>requireInvestorAuth,
    "requireStaffAuth",
    ()=>requireStaffAuth
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f40$supabase$2f$ssr$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/versotech-portal/node_modules/@supabase/ssr/dist/module/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f40$supabase$2f$ssr$2f$dist$2f$module$2f$createServerClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/versotech-portal/node_modules/@supabase/ssr/dist/module/createServerClient.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/versotech-portal/node_modules/next/headers.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$dist$2f$api$2f$navigation$2e$react$2d$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/versotech-portal/node_modules/next/dist/api/navigation.react-server.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$navigation$2e$react$2d$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/versotech-portal/node_modules/next/dist/client/components/navigation.react-server.js [app-route] (ecmascript)");
;
;
;
const STAFF_ROLES = [
    'staff_admin',
    'staff_ops',
    'staff_rm',
    'ceo'
];
class AuthError extends Error {
    code;
    constructor(message, code){
        super(message), this.code = code;
        this.name = 'AuthError';
    }
}
// Server-side Supabase client
const createServerSupabaseClient = async ()=>{
    const cookieStore = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["cookies"])();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f40$supabase$2f$ssr$2f$dist$2f$module$2f$createServerClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createServerClient"])(("TURBOPACK compile-time value", "https://ipguxdssecfexudnvtia.supabase.co"), ("TURBOPACK compile-time value", "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImlwZ3V4ZHNzZWNmZXh1ZG52dGlhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgzNjE4MzcsImV4cCI6MjA3MzkzNzgzN30.AGxM_YW9hfxuu7xDpi_4xhOoRhYM7iGTS1vJ0z2FByE"), {
        cookies: {
            getAll () {
                return cookieStore.getAll();
            },
            setAll (cookiesToSet) {
                try {
                    cookiesToSet.forEach(({ name, value, options })=>cookieStore.set(name, value, options));
                } catch  {
                // The `setAll` method was called from a Server Component.
                // This can be ignored if you have middleware refreshing
                // user sessions.
                }
            }
        }
    });
};
async function getCurrentUser() {
    try {
        const supabase = await createServerSupabaseClient();
        // Get current auth user
        const { data: { user }, error: userError } = await supabase.auth.getUser();
        if (userError || !user) {
            return null;
        }
        // Get profile data from database
        const { data: profile, error: profileError } = await supabase.from('profiles').select('*').eq('id', user.id).single();
        if (profileError || !profile) {
            console.error('[auth] Profile not found for user:', user.id, profileError);
            return null;
        }
        // Fetch permissions for staff users
        let permissions = [];
        const isStaffRole = STAFF_ROLES.includes(profile.role);
        if (isStaffRole) {
            const { data: permissionsData } = await supabase.from('staff_permissions').select('permission').eq('user_id', user.id);
            permissions = permissionsData?.map((p)=>p.permission) || [];
        }
        return {
            id: profile.id,
            email: profile.email,
            displayName: profile.display_name || profile.email?.split('@')[0] || 'User',
            avatar: profile.avatar_url,
            role: profile.role,
            title: profile.title,
            created_at: profile.created_at,
            permissions
        };
    } catch (error) {
        console.error('Error getting current user:', error);
        return null;
    }
}
async function getCurrentSession() {
    try {
        const supabase = await createServerSupabaseClient();
        const { data: { session }, error } = await supabase.auth.getSession();
        if (error) {
            console.error('Error getting session:', error);
            return null;
        }
        return session;
    } catch (error) {
        console.error('Error getting session:', error);
        return null;
    }
}
async function getProfile() {
    const user = await getCurrentUser();
    if (user) {
        console.log('[auth] Profile retrieved:', user.email, user.role);
    } else {
        console.log('[auth] No profile found');
    }
    return user;
}
async function requireAuth(allowedRoles) {
    const user = await getCurrentUser();
    if (!user) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$navigation$2e$react$2d$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["redirect"])('/versotech_main/login');
    }
    if (allowedRoles && !allowedRoles.includes(user.role)) {
        throw new Error('Insufficient permissions');
    }
    return user;
}
async function requireInvestorAuth() {
    const user = await getCurrentUser();
    if (!user) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$navigation$2e$react$2d$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["redirect"])('/versotech_main/login');
    }
    if (user.role !== 'investor') {
        throw new Error('Investor access required');
    }
    return user;
}
async function requireStaffAuth() {
    const user = await getCurrentUser();
    if (!user) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$navigation$2e$react$2d$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["redirect"])('/versotech_main/login');
    }
    if (!STAFF_ROLES.includes(user.role)) {
        throw new Error('Staff access required');
    }
    return user;
}
async function checkStaffAccess(userId) {
    const supabase = await createServerSupabaseClient();
    // Check profile role first (handles synthetic staff personas)
    const { data: profile, error: profileError } = await supabase.from('profiles').select('role').eq('id', userId).single();
    if (!profileError && profile && STAFF_ROLES.includes(profile.role)) {
        return true;
    }
    // Fallback: check database personas (for edge cases)
    const { data: personas } = await supabase.rpc('get_user_personas', {
        p_user_id: userId
    });
    return personas?.some((p)=>p.persona_type === 'staff' || p.persona_type === 'ceo') || false;
}
async function checkCeoAccess(userId) {
    const supabase = await createServerSupabaseClient();
    const { data: profile } = await supabase.from('profiles').select('role').eq('id', userId).single();
    return profile?.role === 'ceo' || profile?.role === 'staff_admin';
}
;
}),
"[project]/versotech-portal/src/lib/api-auth.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Helper to get authenticated user from Supabase auth
 * Works with both createClient() and createServiceClient()
 */ __turbopack_context__.s([
    "getAuthenticatedUser",
    ()=>getAuthenticatedUser,
    "getUserRole",
    ()=>getUserRole,
    "hasPermission",
    ()=>hasPermission,
    "isStaffUser",
    ()=>isStaffUser,
    "isSuperAdmin",
    ()=>isSuperAdmin
]);
async function getAuthenticatedUser(supabase) {
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    return {
        user,
        error: authError
    };
}
async function getUserRole(supabase, user) {
    const { data: profile } = await supabase.from('profiles').select('role').eq('id', user.id).single();
    return profile?.role || null;
}
async function hasPermission(supabase, userId, requiredPermissions) {
    // First, check if user is CEO - CEO bypasses all permission checks
    const { data: profile } = await supabase.from('profiles').select('role').eq('id', userId).single();
    if (profile?.role === 'ceo') {
        return true // CEO has all permissions
        ;
    }
    // Also check if user has CEO persona (for multi_persona users)
    const { data: ceoUser } = await supabase.from('ceo_users').select('user_id').eq('user_id', userId).maybeSingle();
    if (ceoUser) {
        return true // User is in ceo_users table, has all permissions
        ;
    }
    // For non-CEO users, check staff_permissions table
    const { data: permission } = await supabase.from('staff_permissions').select('permission').eq('user_id', userId).in('permission', requiredPermissions).limit(1).maybeSingle();
    return !!permission;
}
async function isSuperAdmin(supabase, userId) {
    return hasPermission(supabase, userId, [
        'super_admin'
    ]);
}
async function isStaffUser(supabase, user) {
    // First check legacy role field
    const role = await getUserRole(supabase, user);
    if (role && (role.startsWith('staff_') || role === 'ceo')) {
        return true;
    }
    // For multi_persona users, check personas via RPC
    if (role === 'multi_persona') {
        try {
            const { data: personas } = await supabase.rpc('get_user_personas', {
                p_user_id: user.id
            });
            if (personas && Array.isArray(personas)) {
                return personas.some((p)=>p.persona_type === 'staff' || p.persona_type === 'ceo');
            }
        } catch (err) {
            console.error('[isStaffUser] Error checking personas:', err);
        }
    }
    return false;
}
}),
"[project]/versotech-portal/src/lib/utils/date-helpers.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Date Helper Utilities
 *
 * Shared utility functions for date-related operations across the application.
 */ /**
 * Check if an ID document is expiring soon (within 30 days) or already expired.
 *
 * @param expiryDate - The expiry date string (ISO format) or null
 * @returns 'expired' if the date is in the past, 'expiring_soon' if within 30 days, null otherwise
 */ __turbopack_context__.s([
    "formatDateDisplay",
    ()=>formatDateDisplay,
    "getIdExpiryWarning",
    ()=>getIdExpiryWarning,
    "getRelativeTime",
    ()=>getRelativeTime
]);
function getIdExpiryWarning(expiryDate) {
    if (!expiryDate) return null;
    const expiry = new Date(expiryDate);
    const now = new Date();
    const thirtyDaysFromNow = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000);
    if (expiry < now) return 'expired';
    if (expiry < thirtyDaysFromNow) return 'expiring_soon';
    return null;
}
function formatDateDisplay(dateStr) {
    return new Date(dateStr).toLocaleDateString('en-GB', {
        day: 'numeric',
        month: 'short',
        year: 'numeric'
    });
}
function getRelativeTime(dateStr) {
    if (!dateStr) return 'Never';
    const date = new Date(dateStr);
    const now = new Date();
    const diff = now.getTime() - date.getTime();
    const hours = Math.floor(diff / (1000 * 60 * 60));
    const days = Math.floor(diff / (1000 * 60 * 60 * 24));
    if (hours < 1) return 'Just now';
    if (hours === 1) return '1 hour ago';
    if (hours < 24) return `${hours} hours ago`;
    if (days === 1) return 'Yesterday';
    if (days < 7) return `${days} days ago`;
    if (days < 30) return `${Math.floor(days / 7)} weeks ago`;
    if (days < 365) return `${Math.floor(days / 30)} months ago`;
    return `${Math.floor(days / 365)} years ago`;
}
}),
"[project]/versotech-portal/src/app/api/admin/users/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GET",
    ()=>GET
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/versotech-portal/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$src$2f$lib$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/versotech-portal/src/lib/supabase/server.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$src$2f$lib$2f$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/versotech-portal/src/lib/auth.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$src$2f$lib$2f$api$2d$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/versotech-portal/src/lib/api-auth.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$src$2f$lib$2f$utils$2f$date$2d$helpers$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/versotech-portal/src/lib/utils/date-helpers.ts [app-route] (ecmascript)");
;
;
;
;
;
async function GET(request) {
    try {
        const user = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$src$2f$lib$2f$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getCurrentUser"])();
        if (!user) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                success: false,
                error: 'Unauthorized'
            }, {
                status: 401
            });
        }
        const supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$src$2f$lib$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createServiceClient"])();
        // Check if user is super admin OR CEO
        const hasAccess = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$src$2f$lib$2f$api$2d$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isSuperAdmin"])(supabase, user.id);
        if (!hasAccess) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                success: false,
                error: 'Forbidden'
            }, {
                status: 403
            });
        }
        // Parse query parameters
        const searchParams = request.nextUrl.searchParams;
        const page = parseInt(searchParams.get('page') || '1');
        const pageSize = parseInt(searchParams.get('pageSize') || '50');
        const search = searchParams.get('search') || '';
        // Support multiple values (comma-separated) for filters
        const roleFilter = searchParams.get('role') || '';
        const roleFilters = roleFilter ? roleFilter.split(',').filter(Boolean) : [];
        const entityTypeFilter = searchParams.get('entityType') || '';
        const entityTypeFilters = entityTypeFilter ? entityTypeFilter.split(',').filter(Boolean) : [];
        const statusFilter = searchParams.get('status') || '';
        const statusFilters = statusFilter ? statusFilter.split(',').filter(Boolean) : [];
        const kycStatusFilter = searchParams.get('kycStatus') || '';
        const hasEntitiesFilter = searchParams.get('hasEntities');
        const sortBy = searchParams.get('sortBy') || 'createdAt';
        const sortOrder = searchParams.get('sortOrder') || 'desc';
        const includeDeleted = searchParams.get('includeDeleted') === 'true';
        // 1. Fetch all profiles
        let profilesQuery = supabase.from('profiles').select('id, display_name, email, role, title, phone, office_location, avatar_url, created_at, last_login_at, password_set, is_super_admin, signature_specimen_url, deleted_at');
        if (!includeDeleted) {
            profilesQuery = profilesQuery.is('deleted_at', null);
        }
        const { data: profiles, error: profilesError } = await profilesQuery;
        if (profilesError) {
            console.error('[admin/users] Profiles error:', profilesError);
            return __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                success: false,
                error: 'Failed to fetch profiles'
            }, {
                status: 500
            });
        }
        // 2. Fetch all entity associations in parallel
        const [investorUsersResult, partnerUsersResult, lawyerUsersResult, commercialPartnerUsersResult, introducerUsersResult, arrangerUsersResult] = await Promise.all([
            supabase.from('investor_users').select('user_id, investor_id, role, is_primary, can_sign, ceo_approval_status, investors:investors!investor_users_investor_id_fkey(id, legal_name)'),
            supabase.from('partner_users').select('user_id, partner_id, role, is_primary, can_sign, ceo_approval_status, partners:partners!partner_users_partner_fk(id, name, legal_name)'),
            supabase.from('lawyer_users').select('user_id, lawyer_id, role, is_primary, can_sign, ceo_approval_status, lawyers:lawyers!lawyer_users_lawyer_fk(id, firm_name, display_name)'),
            supabase.from('commercial_partner_users').select('user_id, commercial_partner_id, role, is_primary, can_sign, ceo_approval_status, commercial_partners:commercial_partners!commercial_partner_users_cp_fk(id, name, legal_name)'),
            supabase.from('introducer_users').select('user_id, introducer_id, role, is_primary, can_sign, ceo_approval_status, introducers:introducers!introducer_users_introducer_fk(id, legal_name)'),
            supabase.from('arranger_users').select('user_id, arranger_id, role, is_primary, can_sign, ceo_approval_status, arranger_entities:arranger_entities!arranger_users_arranger_fk(id, legal_name)')
        ]);
        // Build entity association maps by user_id
        const entityMap = new Map();
        // Helper to safely get entity data
        const getEntity = (data)=>Array.isArray(data) ? data[0] : data;
        // Process investor associations
        if (investorUsersResult.data) {
            for (const iu of investorUsersResult.data){
                const entity = getEntity(iu.investors);
                if (!entity) continue;
                const associations = entityMap.get(iu.user_id) || [];
                associations.push({
                    id: entity.id,
                    name: entity.legal_name || 'Unnamed Investor',
                    type: 'investor',
                    role: iu.role || 'member',
                    isPrimary: iu.is_primary || false,
                    canSign: iu.can_sign || false,
                    approvalStatus: iu.ceo_approval_status
                });
                entityMap.set(iu.user_id, associations);
            }
        }
        // Process partner associations
        if (partnerUsersResult.data) {
            for (const pu of partnerUsersResult.data){
                const entity = getEntity(pu.partners);
                if (!entity) continue;
                const associations = entityMap.get(pu.user_id) || [];
                associations.push({
                    id: entity.id,
                    name: entity.name || entity.legal_name || 'Unnamed Partner',
                    type: 'partner',
                    role: pu.role || 'member',
                    isPrimary: pu.is_primary || false,
                    canSign: pu.can_sign || false,
                    approvalStatus: pu.ceo_approval_status
                });
                entityMap.set(pu.user_id, associations);
            }
        }
        // Process lawyer associations
        if (lawyerUsersResult.data) {
            for (const lu of lawyerUsersResult.data){
                const entity = getEntity(lu.lawyers);
                if (!entity) continue;
                const associations = entityMap.get(lu.user_id) || [];
                associations.push({
                    id: entity.id,
                    name: entity.firm_name || entity.display_name || 'Unnamed Law Firm',
                    type: 'lawyer',
                    role: lu.role || 'member',
                    isPrimary: lu.is_primary || false,
                    canSign: lu.can_sign || false,
                    approvalStatus: lu.ceo_approval_status
                });
                entityMap.set(lu.user_id, associations);
            }
        }
        // Process commercial partner associations
        if (commercialPartnerUsersResult.data) {
            for (const cpu of commercialPartnerUsersResult.data){
                const entity = getEntity(cpu.commercial_partners);
                if (!entity) continue;
                const associations = entityMap.get(cpu.user_id) || [];
                associations.push({
                    id: entity.id,
                    name: entity.name || entity.legal_name || 'Unnamed Commercial Partner',
                    type: 'commercial_partner',
                    role: cpu.role || 'member',
                    isPrimary: cpu.is_primary || false,
                    canSign: cpu.can_sign || false,
                    approvalStatus: cpu.ceo_approval_status
                });
                entityMap.set(cpu.user_id, associations);
            }
        }
        // Process introducer associations
        if (introducerUsersResult.data) {
            for (const iu of introducerUsersResult.data){
                const entity = getEntity(iu.introducers);
                if (!entity) continue;
                const associations = entityMap.get(iu.user_id) || [];
                associations.push({
                    id: entity.id,
                    name: entity.legal_name || 'Unnamed Introducer',
                    type: 'introducer',
                    role: iu.role || 'member',
                    isPrimary: iu.is_primary || false,
                    canSign: iu.can_sign || false,
                    approvalStatus: iu.ceo_approval_status
                });
                entityMap.set(iu.user_id, associations);
            }
        }
        // Process arranger associations
        if (arrangerUsersResult.data) {
            for (const au of arrangerUsersResult.data){
                const entity = getEntity(au.arranger_entities);
                if (!entity) continue;
                const associations = entityMap.get(au.user_id) || [];
                associations.push({
                    id: entity.id,
                    name: entity.legal_name || 'Unnamed Arranger',
                    type: 'arranger',
                    role: au.role || 'member',
                    isPrimary: au.is_primary || false,
                    canSign: au.can_sign || false,
                    approvalStatus: au.ceo_approval_status
                });
                entityMap.set(au.user_id, associations);
            }
        }
        // 3. Fetch KYC data from DIRECT member tables (linked by email)
        // Users can be members in any entity type, so we check all 6 direct member tables
        // NOTE: counterparty_entity_members is EXCLUDED - it stores members of third-party
        // structures (trusts, LLCs) that investors invest THROUGH, not the user's personal KYC
        const profileEmails = profiles?.map((p)=>p.email).filter(Boolean) || [];
        // Fetch KYC data from all direct member tables in parallel (6 tables)
        const kycFields = 'email, kyc_status, id_type, id_expiry_date, nationality, country_of_tax_residency, is_us_citizen';
        const [investorMembersResult, partnerMembersResult, lawyerMembersResult, commercialPartnerMembersResult, introducerMembersResult, arrangerMembersResult] = profileEmails.length > 0 ? await Promise.all([
            supabase.from('investor_members').select(kycFields).in('email', profileEmails),
            supabase.from('partner_members').select(kycFields).in('email', profileEmails),
            supabase.from('lawyer_members').select(kycFields).in('email', profileEmails),
            supabase.from('commercial_partner_members').select(kycFields).in('email', profileEmails),
            supabase.from('introducer_members').select(kycFields).in('email', profileEmails),
            supabase.from('arranger_members').select(kycFields).in('email', profileEmails)
        ]) : [
            {
                data: []
            },
            {
                data: []
            },
            {
                data: []
            },
            {
                data: []
            },
            {
                data: []
            },
            {
                data: []
            }
        ];
        // Combine all KYC data from direct member tables
        const allKycMembers = [
            ...investorMembersResult.data || [],
            ...partnerMembersResult.data || [],
            ...lawyerMembersResult.data || [],
            ...commercialPartnerMembersResult.data || [],
            ...introducerMembersResult.data || [],
            ...arrangerMembersResult.data || []
        ];
        // Build KYC map by email
        // Priority: approved > submitted > pending > rejected > expired > null
        const kycStatusPriority = {
            'approved': 5,
            'submitted': 4,
            'pending': 3,
            'rejected': 2,
            'expired': 1
        };
        const kycMap = new Map();
        for (const member of allKycMembers){
            if (!member.email) continue;
            const existing = kycMap.get(member.email);
            const existingPriority = existing?.status ? kycStatusPriority[existing.status] || 0 : 0;
            const newPriority = member.kyc_status ? kycStatusPriority[member.kyc_status] || 0 : 0;
            // Store if we don't have data for this email yet, or if this one has higher priority status
            if (!existing || newPriority > existingPriority) {
                kycMap.set(member.email, {
                    status: member.kyc_status,
                    idType: member.id_type,
                    idExpiry: member.id_expiry_date,
                    idExpiryWarning: (0, __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$src$2f$lib$2f$utils$2f$date$2d$helpers$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getIdExpiryWarning"])(member.id_expiry_date),
                    nationality: member.nationality,
                    taxResidency: member.country_of_tax_residency,
                    isUsPerson: member.is_us_citizen || false
                });
            }
        }
        // 4. Build user rows
        let userRows = (profiles || []).map((p)=>({
                id: p.id,
                displayName: p.display_name || 'Unknown',
                email: p.email || '',
                systemRole: p.role || 'investor',
                title: p.title,
                phone: p.phone,
                officeLocation: p.office_location,
                avatarUrl: p.avatar_url,
                createdAt: p.created_at,
                lastLoginAt: p.last_login_at,
                passwordSet: p.password_set || false,
                isSuperAdmin: p.is_super_admin || false,
                hasSignature: !!p.signature_specimen_url,
                isDeleted: !!p.deleted_at,
                entities: entityMap.get(p.id) || [],
                entityCount: (entityMap.get(p.id) || []).length,
                kyc: p.email ? kycMap.get(p.email) || null : null
            }));
        // 5. Apply filters
        if (search) {
            const searchLower = search.toLowerCase();
            userRows = userRows.filter((u)=>u.displayName.toLowerCase().includes(searchLower) || u.email.toLowerCase().includes(searchLower) || u.title?.toLowerCase().includes(searchLower));
        }
        // Multi-select role filter
        if (roleFilters.length > 0) {
            userRows = userRows.filter((u)=>roleFilters.includes(u.systemRole));
        }
        // Multi-select entity type filter
        if (entityTypeFilters.length > 0) {
            userRows = userRows.filter((u)=>u.entities.some((e)=>entityTypeFilters.includes(e.type)));
        }
        // Status filter (derived from user data)
        // Status: active, pending, inactive, deactivated
        if (statusFilters.length > 0) {
            const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
            userRows = userRows.filter((u)=>{
                let status;
                if (u.isDeleted) {
                    status = 'deactivated';
                } else if (!u.lastLoginAt) {
                    status = 'pending';
                } else if (new Date(u.lastLoginAt) > thirtyDaysAgo) {
                    status = 'active';
                } else {
                    status = 'inactive';
                }
                return statusFilters.includes(status);
            });
        }
        if (kycStatusFilter && kycStatusFilter !== 'all') {
            userRows = userRows.filter((u)=>u.kyc?.status === kycStatusFilter);
        }
        if (hasEntitiesFilter !== null && hasEntitiesFilter !== undefined) {
            const hasEntities = hasEntitiesFilter === 'true';
            userRows = userRows.filter((u)=>hasEntities ? u.entityCount > 0 : u.entityCount === 0);
        }
        // 6. Calculate stats (before pagination)
        const stats = {
            total: userRows.length,
            active: userRows.filter((u)=>u.lastLoginAt && new Date(u.lastLoginAt) > new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)).length,
            staff: userRows.filter((u)=>u.systemRole.startsWith('staff_') || u.systemRole === 'ceo').length,
            investors: userRows.filter((u)=>u.entities.some((e)=>e.type === 'investor')).length,
            partners: userRows.filter((u)=>u.entities.some((e)=>e.type === 'partner')).length,
            lawyers: userRows.filter((u)=>u.entities.some((e)=>e.type === 'lawyer')).length,
            introducers: userRows.filter((u)=>u.entities.some((e)=>e.type === 'introducer')).length,
            arrangers: userRows.filter((u)=>u.entities.some((e)=>e.type === 'arranger')).length,
            pendingKyc: userRows.filter((u)=>u.kyc?.status === 'pending' || u.kyc?.status === 'submitted').length,
            superAdmins: userRows.filter((u)=>u.isSuperAdmin).length
        };
        // 7. Apply sorting
        userRows.sort((a, b)=>{
            let aVal, bVal;
            switch(sortBy){
                case 'displayName':
                    aVal = a.displayName.toLowerCase();
                    bVal = b.displayName.toLowerCase();
                    break;
                case 'email':
                    aVal = a.email.toLowerCase();
                    bVal = b.email.toLowerCase();
                    break;
                case 'systemRole':
                    aVal = a.systemRole;
                    bVal = b.systemRole;
                    break;
                case 'entityCount':
                    aVal = a.entityCount;
                    bVal = b.entityCount;
                    break;
                case 'lastLoginAt':
                    aVal = a.lastLoginAt ? new Date(a.lastLoginAt).getTime() : 0;
                    bVal = b.lastLoginAt ? new Date(b.lastLoginAt).getTime() : 0;
                    break;
                case 'createdAt':
                default:
                    aVal = new Date(a.createdAt).getTime();
                    bVal = new Date(b.createdAt).getTime();
            }
            if (sortOrder === 'asc') {
                return aVal < bVal ? -1 : aVal > bVal ? 1 : 0;
            } else {
                return aVal > bVal ? -1 : aVal < bVal ? 1 : 0;
            }
        });
        // 8. Apply pagination
        const totalCount = userRows.length;
        const totalPages = Math.ceil(totalCount / pageSize);
        const offset = (page - 1) * pageSize;
        const paginatedUsers = userRows.slice(offset, offset + pageSize);
        return __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: true,
            data: paginatedUsers,
            stats,
            pagination: {
                page,
                pageSize,
                totalPages,
                totalCount
            }
        });
    } catch (error) {
        console.error('[admin/users] Error:', error);
        const errorMessage = error instanceof Error ? error.message : 'Failed to fetch users';
        return __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: false,
            error: errorMessage
        }, {
            status: 500
        });
    }
}
}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__4210247d._.js.map