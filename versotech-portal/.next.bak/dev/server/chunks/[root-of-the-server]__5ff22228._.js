module.exports = [
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/stream [external] (stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}),
"[externals]/http [external] (http, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}),
"[externals]/url [external] (url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}),
"[externals]/punycode [external] (punycode, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("punycode", () => require("punycode"));

module.exports = mod;
}),
"[externals]/https [external] (https, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}),
"[externals]/zlib [external] (zlib, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}),
"[project]/versotech-portal/src/lib/supabase/server.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createClient",
    ()=>createClient,
    "createServiceClient",
    ()=>createServiceClient
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f40$supabase$2f$ssr$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/versotech-portal/node_modules/@supabase/ssr/dist/module/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f40$supabase$2f$ssr$2f$dist$2f$module$2f$createServerClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/versotech-portal/node_modules/@supabase/ssr/dist/module/createServerClient.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/versotech-portal/node_modules/@supabase/supabase-js/dist/module/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/versotech-portal/node_modules/next/headers.js [app-route] (ecmascript)");
;
;
;
const createClient = async ()=>{
    const cookieStore = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["cookies"])();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f40$supabase$2f$ssr$2f$dist$2f$module$2f$createServerClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createServerClient"])(("TURBOPACK compile-time value", "https://ipguxdssecfexudnvtia.supabase.co"), ("TURBOPACK compile-time value", "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImlwZ3V4ZHNzZWNmZXh1ZG52dGlhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgzNjE4MzcsImV4cCI6MjA3MzkzNzgzN30.AGxM_YW9hfxuu7xDpi_4xhOoRhYM7iGTS1vJ0z2FByE"), {
        cookies: {
            getAll () {
                return cookieStore.getAll();
            },
            setAll (cookiesToSet) {
                try {
                    cookiesToSet.forEach(({ name, value, options })=>{
                        cookieStore.set(name, value, options);
                    });
                } catch (error) {
                // The `setAll` method was called from a Server Component.
                // This can be ignored if you have middleware refreshing
                // user sessions.
                }
            }
        }
    });
};
const createServiceClient = ()=>{
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createClient"])(("TURBOPACK compile-time value", "https://ipguxdssecfexudnvtia.supabase.co"), process.env.SUPABASE_SERVICE_ROLE_KEY, {
        auth: {
            autoRefreshToken: false,
            persistSession: false
        }
    });
};
}),
"[externals]/next/dist/server/app-render/action-async-storage.external.js [external] (next/dist/server/app-render/action-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/action-async-storage.external.js", () => require("next/dist/server/app-render/action-async-storage.external.js"));

module.exports = mod;
}),
"[project]/versotech-portal/src/lib/auth.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AuthError",
    ()=>AuthError,
    "STAFF_ROLES",
    ()=>STAFF_ROLES,
    "checkCeoAccess",
    ()=>checkCeoAccess,
    "checkStaffAccess",
    ()=>checkStaffAccess,
    "getCurrentSession",
    ()=>getCurrentSession,
    "getCurrentUser",
    ()=>getCurrentUser,
    "getProfile",
    ()=>getProfile,
    "requireAuth",
    ()=>requireAuth,
    "requireInvestorAuth",
    ()=>requireInvestorAuth,
    "requireStaffAuth",
    ()=>requireStaffAuth
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f40$supabase$2f$ssr$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/versotech-portal/node_modules/@supabase/ssr/dist/module/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f40$supabase$2f$ssr$2f$dist$2f$module$2f$createServerClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/versotech-portal/node_modules/@supabase/ssr/dist/module/createServerClient.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/versotech-portal/node_modules/next/headers.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$dist$2f$api$2f$navigation$2e$react$2d$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/versotech-portal/node_modules/next/dist/api/navigation.react-server.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$navigation$2e$react$2d$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/versotech-portal/node_modules/next/dist/client/components/navigation.react-server.js [app-route] (ecmascript)");
;
;
;
const STAFF_ROLES = [
    'staff_admin',
    'staff_ops',
    'staff_rm',
    'ceo'
];
class AuthError extends Error {
    code;
    constructor(message, code){
        super(message), this.code = code;
        this.name = 'AuthError';
    }
}
// Server-side Supabase client
const createServerSupabaseClient = async ()=>{
    const cookieStore = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["cookies"])();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f40$supabase$2f$ssr$2f$dist$2f$module$2f$createServerClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createServerClient"])(("TURBOPACK compile-time value", "https://ipguxdssecfexudnvtia.supabase.co"), ("TURBOPACK compile-time value", "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImlwZ3V4ZHNzZWNmZXh1ZG52dGlhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgzNjE4MzcsImV4cCI6MjA3MzkzNzgzN30.AGxM_YW9hfxuu7xDpi_4xhOoRhYM7iGTS1vJ0z2FByE"), {
        cookies: {
            getAll () {
                return cookieStore.getAll();
            },
            setAll (cookiesToSet) {
                try {
                    cookiesToSet.forEach(({ name, value, options })=>cookieStore.set(name, value, options));
                } catch  {
                // The `setAll` method was called from a Server Component.
                // This can be ignored if you have middleware refreshing
                // user sessions.
                }
            }
        }
    });
};
async function getCurrentUser() {
    try {
        const supabase = await createServerSupabaseClient();
        // Get current auth user
        const { data: { user }, error: userError } = await supabase.auth.getUser();
        if (userError || !user) {
            return null;
        }
        // Get profile data from database
        const { data: profile, error: profileError } = await supabase.from('profiles').select('*').eq('id', user.id).single();
        if (profileError || !profile) {
            console.error('[auth] Profile not found for user:', user.id, profileError);
            return null;
        }
        // Fetch permissions for staff users
        let permissions = [];
        const isStaffRole = STAFF_ROLES.includes(profile.role);
        if (isStaffRole) {
            const { data: permissionsData } = await supabase.from('staff_permissions').select('permission').eq('user_id', user.id);
            permissions = permissionsData?.map((p)=>p.permission) || [];
        }
        return {
            id: profile.id,
            email: profile.email,
            displayName: profile.display_name || profile.email?.split('@')[0] || 'User',
            avatar: profile.avatar_url,
            role: profile.role,
            title: profile.title,
            created_at: profile.created_at,
            permissions
        };
    } catch (error) {
        console.error('Error getting current user:', error);
        return null;
    }
}
async function getCurrentSession() {
    try {
        const supabase = await createServerSupabaseClient();
        const { data: { session }, error } = await supabase.auth.getSession();
        if (error) {
            console.error('Error getting session:', error);
            return null;
        }
        return session;
    } catch (error) {
        console.error('Error getting session:', error);
        return null;
    }
}
async function getProfile() {
    const user = await getCurrentUser();
    if (user) {
        console.log('[auth] Profile retrieved:', user.email, user.role);
    } else {
        console.log('[auth] No profile found');
    }
    return user;
}
async function requireAuth(allowedRoles) {
    const user = await getCurrentUser();
    if (!user) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$navigation$2e$react$2d$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["redirect"])('/versotech_main/login');
    }
    if (allowedRoles && !allowedRoles.includes(user.role)) {
        throw new Error('Insufficient permissions');
    }
    return user;
}
async function requireInvestorAuth() {
    const user = await getCurrentUser();
    if (!user) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$navigation$2e$react$2d$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["redirect"])('/versotech_main/login');
    }
    if (user.role !== 'investor') {
        throw new Error('Investor access required');
    }
    return user;
}
async function requireStaffAuth() {
    const user = await getCurrentUser();
    if (!user) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$navigation$2e$react$2d$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["redirect"])('/versotech_main/login');
    }
    if (!STAFF_ROLES.includes(user.role)) {
        throw new Error('Staff access required');
    }
    return user;
}
async function checkStaffAccess(userId) {
    const supabase = await createServerSupabaseClient();
    // Check profile role first (handles synthetic staff personas)
    const { data: profile, error: profileError } = await supabase.from('profiles').select('role').eq('id', userId).single();
    if (!profileError && profile && STAFF_ROLES.includes(profile.role)) {
        return true;
    }
    // Fallback: check database personas (for edge cases)
    const { data: personas } = await supabase.rpc('get_user_personas', {
        p_user_id: userId
    });
    return personas?.some((p)=>p.persona_type === 'staff' || p.persona_type === 'ceo') || false;
}
async function checkCeoAccess(userId) {
    const supabase = await createServerSupabaseClient();
    const { data: profile } = await supabase.from('profiles').select('role').eq('id', userId).single();
    return profile?.role === 'ceo' || profile?.role === 'staff_admin';
}
;
}),
"[project]/versotech-portal/src/app/api/admin/metrics/dashboard/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GET",
    ()=>GET
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/versotech-portal/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$src$2f$lib$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/versotech-portal/src/lib/supabase/server.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$src$2f$lib$2f$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/versotech-portal/src/lib/auth.ts [app-route] (ecmascript)");
;
;
;
async function GET(request) {
    try {
        const user = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$src$2f$lib$2f$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getCurrentUser"])();
        if (!user) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Unauthorized'
            }, {
                status: 401
            });
        }
        // Parse query parameters
        const { searchParams } = new URL(request.url);
        const days = Math.min(Math.max(parseInt(searchParams.get('days') || '30', 10), 7), 90);
        const supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$src$2f$lib$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createServiceClient"])();
        // Check if user is super admin
        const { data: permission } = await supabase.from('staff_permissions').select('permission').eq('user_id', user.id).eq('permission', 'super_admin').single();
        if (!permission) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Forbidden'
            }, {
                status: 403
            });
        }
        // Fetch all data in parallel
        const [subscriptionsResult, investorResult, dealResult, pendingResult, feeEventsResult, pipelineResult, investorDistResult, alertsResult, // Admin-only metrics
        securityMetrics, staffActivityResult, approvalQueueResult, workflowTrendResult, complianceForecastResult, userActivityTrendResult] = await Promise.all([
            // Subscriptions for AUM and Revenue metrics (limit to prevent billing spikes)
            supabase.from('subscriptions').select('id, commitment, funded_amount, current_nav, spread_fee_amount, subscription_fee_amount, management_fee_amount, status, subscription_date').in('status', [
                'active',
                'committed',
                'funded'
            ]).limit(50000),
            // Investor stats (limit to prevent billing spikes)
            supabase.from('investors').select('id, status, created_at, kyc_status, type, country', {
                count: 'exact'
            }).eq('status', 'active').limit(50000),
            // Deal pipeline (limit to prevent billing spikes)
            supabase.from('deals').select('id, status, target_amount, raised_amount').limit(5000),
            // Pending items
            Promise.all([
                supabase.from('approvals').select('id', {
                    count: 'exact'
                }).eq('status', 'pending'),
                supabase.from('tasks').select('id', {
                    count: 'exact'
                }).in('status', [
                    'pending',
                    'overdue'
                ]),
                supabase.from('investors').select('id', {
                    count: 'exact'
                }).eq('kyc_status', 'pending')
            ]),
            // Fee events for revenue by month chart (limit to prevent billing spikes)
            supabase.from('fee_events').select('id, fee_type, computed_amount, created_at').gte('created_at', new Date(Date.now() - 365 * 24 * 60 * 60 * 1000).toISOString()).limit(10000),
            // Subscription pipeline
            Promise.all([
                supabase.from('investor_deal_interest').select('id', {
                    count: 'exact',
                    head: true
                }),
                supabase.from('deal_data_room_access').select('id', {
                    count: 'exact',
                    head: true
                }).is('revoked_at', null),
                supabase.from('deal_subscription_submissions').select('id', {
                    count: 'exact',
                    head: true
                }).in('status', [
                    'pending_review',
                    'approved',
                    'pending'
                ]),
                supabase.from('subscriptions').select('id', {
                    count: 'exact',
                    head: true
                }).gt('funded_amount', 0)
            ]),
            // Investor distribution (limit to prevent billing spikes)
            supabase.from('investors').select('type, kyc_status, country').eq('status', 'active').limit(50000),
            // Compliance alerts
            supabase.from('investors').select('id, legal_name, kyc_expiry_date, kyc_status').eq('status', 'active').not('kyc_expiry_date', 'is', null).gte('kyc_expiry_date', new Date().toISOString().split('T')[0]).lte('kyc_expiry_date', new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]),
            // Admin-only: Security metrics (failed logins, new accounts)
            fetchSecurityMetrics(supabase),
            // Admin-only: Staff activity from audit_logs
            fetchStaffActivity(supabase),
            // Admin-only: Approval queue age distribution
            fetchApprovalQueueHealth(supabase),
            // Admin-only: Workflow success trend over past 30 days
            fetchWorkflowTrend(supabase),
            // Admin-only: KYC expiry forecast
            fetchComplianceForecast(supabase),
            // Admin-only: User activity trend for the specified time period
            fetchUserActivityTrend(supabase, days)
        ]);
        // Calculate AUM and Revenue from ACTUAL subscription data
        const subscriptions = subscriptionsResult.data || [];
        const totalAum = subscriptions.reduce((sum, s)=>sum + (s.current_nav || s.commitment || 0), 0);
        const totalCommitment = subscriptions.reduce((sum, s)=>sum + (s.commitment || 0), 0);
        const totalFunded = subscriptions.reduce((sum, s)=>sum + (s.funded_amount || 0), 0);
        const fundingRate = totalCommitment > 0 ? Math.round(totalFunded / totalCommitment * 100) : 0;
        // VERSO's PRIMARY REVENUE - Spread fees
        const spreadFeeRevenue = subscriptions.reduce((sum, s)=>sum + (s.spread_fee_amount || 0), 0);
        const subscriptionFeeRevenue = subscriptions.reduce((sum, s)=>sum + (s.subscription_fee_amount || 0), 0);
        const managementFeeRevenue = subscriptions.reduce((sum, s)=>sum + (s.management_fee_amount || 0), 0);
        const totalRevenue = spreadFeeRevenue + subscriptionFeeRevenue + managementFeeRevenue;
        // Calculate investor metrics
        const investors = investorResult.data || [];
        const totalInvestors = investorResult.count || 0;
        const newInvestorsMtd = investors.filter((i)=>{
            const createdDate = new Date(i.created_at);
            const now = new Date();
            return createdDate.getMonth() === now.getMonth() && createdDate.getFullYear() === now.getFullYear();
        }).length;
        // Calculate deal metrics
        const deals = dealResult.data || [];
        const openDeals = deals.filter((d)=>d.status === 'open' || d.status === 'allocation_pending').length;
        const pipelineValue = deals.filter((d)=>d.status === 'open' || d.status === 'allocation_pending').reduce((sum, d)=>sum + (d.target_amount || 0), 0);
        // Pending items
        const [approvalsRes, tasksRes, kycRes] = pendingResult;
        const pendingApprovals = approvalsRes.count || 0;
        const pendingTasks = tasksRes.count || 0;
        const pendingKyc = kycRes.count || 0;
        // Revenue by month from fee_events
        const feeEvents = feeEventsResult.data || [];
        const revenueByMonth = {};
        feeEvents.forEach((fe)=>{
            const date = new Date(fe.created_at);
            const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
            if (!revenueByMonth[monthKey]) {
                revenueByMonth[monthKey] = {
                    month: monthKey,
                    subscription_fees: 0,
                    management_fees: 0,
                    performance_fees: 0,
                    spread_fees: 0,
                    total: 0
                };
            }
            const amount = fe.computed_amount || 0;
            if (fe.fee_type === 'subscription') revenueByMonth[monthKey].subscription_fees += amount;
            else if (fe.fee_type === 'management') revenueByMonth[monthKey].management_fees += amount;
            else if (fe.fee_type === 'performance') revenueByMonth[monthKey].performance_fees += amount;
            else if (fe.fee_type === 'spread') revenueByMonth[monthKey].spread_fees += amount;
            revenueByMonth[monthKey].total += amount;
        });
        const revenueByMonthArray = Object.values(revenueByMonth).sort((a, b)=>a.month.localeCompare(b.month));
        // Subscription pipeline
        const [interestRes, ndaRes, submittedRes, fundedRes] = pipelineResult;
        const subscriptionPipeline = {
            interest: interestRes.count || 0,
            nda_signed: ndaRes.count || 0,
            submitted: submittedRes.count || 0,
            funded: fundedRes.count || 0
        };
        // Deal pipeline by status
        const dealsByStatus = {
            draft: {
                count: 0,
                value: 0
            },
            open: {
                count: 0,
                value: 0
            },
            allocation_pending: {
                count: 0,
                value: 0
            },
            closed: {
                count: 0,
                value: 0
            },
            cancelled: {
                count: 0,
                value: 0
            }
        };
        deals.forEach((d)=>{
            const status = d.status;
            if (dealsByStatus[status]) {
                dealsByStatus[status].count++;
                dealsByStatus[status].value += d.target_amount || 0;
            }
        });
        // Investor distribution
        const investorDist = investorDistResult.data || [];
        const byType = {};
        const byKyc = {};
        const byCountry = {};
        investorDist.forEach((i)=>{
            const type = i.type || 'Unknown';
            byType[type] = (byType[type] || 0) + 1;
            const kyc = i.kyc_status || 'not_started';
            byKyc[kyc] = (byKyc[kyc] || 0) + 1;
            const country = i.country || 'Unknown';
            byCountry[country] = (byCountry[country] || 0) + 1;
        });
        // Format investor distribution for charts
        const investorsByType = Object.entries(byType).map(([type, count])=>({
                type,
                count
            }));
        const investorsByKyc = Object.entries(byKyc).map(([status, count])=>({
                status,
                count
            }));
        const investorsByCountry = Object.entries(byCountry).map(([country, count])=>({
                country,
                count
            })).sort((a, b)=>b.count - a.count).slice(0, 5);
        // Compliance alerts
        const kycAlerts = (alertsResult.data || []).map((i)=>{
            const expiryDate = new Date(i.kyc_expiry_date);
            const today = new Date();
            const daysUntil = Math.ceil((expiryDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));
            let severity = 'medium';
            if (daysUntil <= 7) severity = 'critical';
            else if (daysUntil <= 30) severity = 'high';
            return {
                id: i.id,
                type: 'kyc_expiry',
                severity,
                investor_id: i.id,
                investor_name: i.legal_name,
                details: `KYC expires in ${daysUntil} days`,
                due_date: i.kyc_expiry_date,
                days_until_due: daysUntil,
                created_at: new Date().toISOString()
            };
        });
        // Build action items from alerts
        const criticalAlerts = kycAlerts.filter((a)=>a.severity === 'critical');
        const highAlerts = kycAlerts.filter((a)=>a.severity === 'high');
        const mediumAlerts = kycAlerts.filter((a)=>a.severity === 'medium');
        const actionItems = {
            critical: criticalAlerts.length > 0 ? [
                {
                    id: 'kyc-critical',
                    category: 'kyc',
                    title: 'KYC Expiring (Critical)',
                    description: `${criticalAlerts.length} investors with KYC expiring within 7 days`,
                    count: criticalAlerts.length,
                    link: '/versotech/staff/investors?kyc_status=expiring'
                }
            ] : [],
            high: [
                ...pendingApprovals > 0 ? [
                    {
                        id: 'approvals',
                        category: 'approval',
                        title: 'Pending Approvals',
                        description: `${pendingApprovals} approvals waiting for review`,
                        count: pendingApprovals,
                        link: '/versotech/staff/approvals'
                    }
                ] : [],
                ...highAlerts.length > 0 ? [
                    {
                        id: 'kyc-high',
                        category: 'kyc',
                        title: 'KYC Expiring Soon',
                        description: `${highAlerts.length} investors with KYC expiring within 30 days`,
                        count: highAlerts.length,
                        link: '/versotech/staff/investors?kyc_status=expiring'
                    }
                ] : []
            ],
            medium: [
                ...pendingTasks > 0 ? [
                    {
                        id: 'tasks',
                        category: 'task',
                        title: 'Pending Tasks',
                        description: `${pendingTasks} tasks requiring attention`,
                        count: pendingTasks,
                        link: '/versotech/staff/tasks'
                    }
                ] : [],
                ...mediumAlerts.length > 0 ? [
                    {
                        id: 'kyc-medium',
                        category: 'kyc',
                        title: 'KYC Expiring (90 days)',
                        description: `${mediumAlerts.length} investors with KYC expiring within 90 days`,
                        count: mediumAlerts.length,
                        link: '/versotech/staff/investors?kyc_status=expiring'
                    }
                ] : []
            ]
        };
        return __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: true,
            data: {
                kpis: {
                    aum: {
                        value: totalAum,
                        commitment: totalCommitment,
                        funded: totalFunded,
                        funding_rate: fundingRate,
                        change_mtd: null,
                        trend: null
                    },
                    revenue: {
                        total: totalRevenue,
                        spread_fees: spreadFeeRevenue,
                        subscription_fees: subscriptionFeeRevenue,
                        management_fees: managementFeeRevenue
                    },
                    investors: {
                        active: totalInvestors,
                        new_mtd: newInvestorsMtd,
                        trend: newInvestorsMtd > 0 ? 'up' : null
                    },
                    deals: {
                        open: openDeals,
                        pipeline_value: pipelineValue,
                        trend: null
                    },
                    pending: {
                        approvals: pendingApprovals,
                        tasks: pendingTasks,
                        kyc: pendingKyc
                    }
                },
                charts: {
                    revenueByMonth: revenueByMonthArray,
                    subscriptionPipeline,
                    dealsByStatus,
                    investorsByType,
                    investorsByKyc,
                    investorsByCountry
                },
                alerts: actionItems,
                // Admin-only metrics
                adminMetrics: {
                    security: securityMetrics,
                    staffActivity: staffActivityResult,
                    approvalQueue: approvalQueueResult,
                    workflowTrend: workflowTrendResult,
                    complianceForecast: complianceForecastResult,
                    userActivityTrend: userActivityTrendResult
                }
            }
        });
    } catch (error) {
        console.error('Dashboard metrics error:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Failed to fetch dashboard metrics'
        }, {
            status: 500
        });
    }
}
// Helper functions for admin-only metrics
async function fetchSecurityMetrics(supabase) {
    const now = new Date();
    const day24h = new Date(now.getTime() - 24 * 60 * 60 * 1000).toISOString();
    const day7d = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000).toISOString();
    // Failed logins from audit_logs (limit to prevent billing spikes during attacks)
    const { data: loginAttempts } = await supabase.from('audit_logs').select('created_at').eq('action', 'failed_login_attempt').gte('created_at', day7d).limit(10000);
    const failed24h = loginAttempts?.filter((l)=>new Date(l.created_at) >= new Date(day24h)).length || 0;
    const failed7d = loginAttempts?.length || 0;
    // New accounts created in past 7 days
    const { count: newAccounts } = await supabase.from('profiles').select('*', {
        count: 'exact',
        head: true
    }).gte('created_at', day7d);
    // Pending approvals count
    const { count: pendingApprovals } = await supabase.from('approvals').select('*', {
        count: 'exact',
        head: true
    }).eq('status', 'pending');
    return {
        failed_logins_24h: failed24h,
        failed_logins_7d: failed7d,
        new_accounts_7d: newAccounts || 0,
        pending_approvals: pendingApprovals || 0
    };
}
async function fetchStaffActivity(supabase) {
    const day7d = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString();
    // Get staff profiles first
    const { data: staffProfiles } = await supabase.from('profiles').select('id, display_name, email').in('role', [
        'staff_admin',
        'staff_ops',
        'staff_rm',
        'ceo'
    ]);
    if (!staffProfiles?.length) {
        return [];
    }
    const staffIds = staffProfiles.map((p)=>p.id);
    // Get audit log counts grouped by staff (limit to prevent billing spikes)
    const { data: activityLogs } = await supabase.from('audit_logs').select('actor_id, action, created_at').in('actor_id', staffIds).gte('created_at', day7d).limit(50000);
    // Aggregate by staff
    const activityMap = {};
    staffIds.forEach((id)=>{
        activityMap[id] = {
            count: 0,
            lastAction: null
        };
    });
    activityLogs?.forEach((log)=>{
        const entry = activityMap[log.actor_id];
        if (entry) {
            entry.count++;
            if (!entry.lastAction || log.created_at > entry.lastAction) {
                entry.lastAction = log.created_at;
            }
        }
    });
    // Map to staff with names
    const staffActivity = staffProfiles.map((staff)=>({
            staff_id: staff.id,
            name: staff.display_name || staff.email?.split('@')[0] || 'Unknown',
            action_count: activityMap[staff.id]?.count || 0,
            last_action: activityMap[staff.id]?.lastAction
        }));
    // Sort by action count descending
    return staffActivity.sort((a, b)=>b.action_count - a.action_count);
}
async function fetchApprovalQueueHealth(supabase) {
    const now = new Date();
    const day1 = new Date(now.getTime() - 1 * 24 * 60 * 60 * 1000);
    const day3 = new Date(now.getTime() - 3 * 24 * 60 * 60 * 1000);
    const day7 = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
    const { data: pendingApprovals } = await supabase.from('approvals').select('created_at').eq('status', 'pending').limit(10000);
    let under_1_day = 0;
    let days_1_to_3 = 0;
    let days_3_to_7 = 0;
    let over_7_days = 0;
    pendingApprovals?.forEach((approval)=>{
        const createdAt = new Date(approval.created_at);
        if (createdAt >= day1) {
            under_1_day++;
        } else if (createdAt >= day3) {
            days_1_to_3++;
        } else if (createdAt >= day7) {
            days_3_to_7++;
        } else {
            over_7_days++;
        }
    });
    return {
        under_1_day,
        days_1_to_3,
        days_3_to_7,
        over_7_days,
        total: pendingApprovals?.length || 0
    };
}
async function fetchWorkflowTrend(supabase) {
    const day30 = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString();
    const { data: runs } = await supabase.from('workflow_runs').select('status, created_at').gte('created_at', day30).order('created_at', {
        ascending: true
    }).limit(50000);
    // Group by date
    const byDate = {};
    runs?.forEach((run)=>{
        const date = run.created_at.split('T')[0];
        if (!byDate[date]) {
            byDate[date] = {
                total: 0,
                completed: 0,
                failed: 0
            };
        }
        byDate[date].total++;
        if (run.status === 'completed') {
            byDate[date].completed++;
        } else if (run.status === 'failed') {
            byDate[date].failed++;
        }
    });
    // Convert to array with success rate
    return Object.entries(byDate).map(([date, stats])=>({
            date,
            total_runs: stats.total,
            completed: stats.completed,
            failed: stats.failed,
            success_rate: stats.total > 0 ? Math.round(stats.completed / stats.total * 100) : 0
        }));
}
async function fetchComplianceForecast(supabase) {
    const now = new Date();
    const day7 = new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000).toISOString();
    const day30 = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000).toISOString();
    const day90 = new Date(now.getTime() + 90 * 24 * 60 * 60 * 1000).toISOString();
    const { data: investors } = await supabase.from('investors').select('kyc_expiry_date').not('kyc_expiry_date', 'is', null).gte('kyc_expiry_date', now.toISOString()).lte('kyc_expiry_date', day90);
    let next_7_days = 0;
    let next_30_days = 0;
    let next_90_days = 0;
    investors?.forEach((inv)=>{
        const expiry = new Date(inv.kyc_expiry_date);
        if (expiry <= new Date(day7)) {
            next_7_days++;
        } else if (expiry <= new Date(day30)) {
            next_30_days++;
        } else {
            next_90_days++;
        }
    });
    return {
        next_7_days,
        next_30_days,
        next_90_days,
        total: investors?.length || 0
    };
}
async function fetchUserActivityTrend(supabase, days) {
    const startDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000).toISOString();
    // Get audit logs grouped by date and count unique users per day
    const { data: activityLogs } = await supabase.from('audit_logs').select('actor_id, created_at').gte('created_at', startDate).not('actor_id', 'is', null).order('created_at', {
        ascending: true
    }).limit(100000);
    // Group by date and count unique users
    const byDate = {};
    // Initialize all dates in range with empty sets
    for(let i = 0; i < days; i++){
        const date = new Date(Date.now() - (days - 1 - i) * 24 * 60 * 60 * 1000);
        const dateKey = date.toISOString().split('T')[0];
        byDate[dateKey] = new Set();
    }
    // Populate with actual data
    activityLogs?.forEach((log)=>{
        const dateKey = log.created_at.split('T')[0];
        if (byDate[dateKey] && log.actor_id) {
            byDate[dateKey].add(log.actor_id);
        }
    });
    // Convert to array format for the chart
    return Object.entries(byDate).map(([date, userSet])=>({
            date,
            activeUsers: userSet.size,
            // Format date for display (e.g., "Jan 15")
            label: new Date(date).toLocaleDateString('en-US', {
                month: 'short',
                day: 'numeric'
            })
        }));
}
}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__5ff22228._.js.map