{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 82, "column": 0}, "map": {"version":3,"sources":["file:///Users/ghilesmoussaoui/Desktop/Versotech/versotech-portal/src/lib/supabase/server.ts"],"sourcesContent":["import { createServerClient } from '@supabase/ssr'\nimport { createClient as createSupabaseClient } from '@supabase/supabase-js'\nimport { cookies } from 'next/headers'\n\nexport const createClient = async () => {\n  const cookieStore = await cookies()\n\n  return createServerClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n    {\n      cookies: {\n        getAll() {\n          return cookieStore.getAll()\n        },\n        setAll(cookiesToSet) {\n          try {\n            cookiesToSet.forEach(({ name, value, options }) => {\n              cookieStore.set(name, value, options)\n            })\n          } catch (error) {\n            // The `setAll` method was called from a Server Component.\n            // This can be ignored if you have middleware refreshing\n            // user sessions.\n          }\n        },\n      },\n    }\n  )\n}\n\n// Server client with service role for admin operations\n// Uses raw supabase-js client which properly bypasses RLS with service role\nexport const createServiceClient = () => {\n  return createSupabaseClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.SUPABASE_SERVICE_ROLE_KEY!,\n    {\n      auth: {\n        autoRefreshToken: false,\n        persistSession: false,\n      },\n    }\n  )\n}\n"],"names":[],"mappings":";;;;;;AAAA;AAAA;AACA;AACA;;;;AAEO,MAAM,eAAe;IAC1B,MAAM,cAAc,MAAM,IAAA,mKAAO;IAEjC,OAAO,IAAA,wNAAkB,sUAGvB;QACE,SAAS;YACP;gBACE,OAAO,YAAY,MAAM;YAC3B;YACA,QAAO,YAAY;gBACjB,IAAI;oBACF,aAAa,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE;wBAC5C,YAAY,GAAG,CAAC,MAAM,OAAO;oBAC/B;gBACF,EAAE,OAAO,OAAO;gBACd,0DAA0D;gBAC1D,wDAAwD;gBACxD,iBAAiB;gBACnB;YACF;QACF;IACF;AAEJ;AAIO,MAAM,sBAAsB;IACjC,OAAO,IAAA,gOAAoB,gFAEzB,QAAQ,GAAG,CAAC,yBAAyB,EACrC;QACE,MAAM;YACJ,kBAAkB;YAClB,gBAAgB;QAClB;IACF;AAEJ"}},
    {"offset": {"line": 134, "column": 0}, "map": {"version":3,"sources":["file:///Users/ghilesmoussaoui/Desktop/Versotech/versotech-portal/src/lib/auth.ts"],"sourcesContent":["import { createServerClient } from '@supabase/ssr'\r\nimport { cookies } from 'next/headers'\r\nimport { redirect } from 'next/navigation'\r\nimport type { User, Session } from '@supabase/supabase-js'\r\n\r\n// Profile roles (stored in profiles.role)\r\nexport type ProfileRole =\r\n  | 'investor'\r\n  | 'staff_admin'\r\n  | 'staff_ops'\r\n  | 'staff_rm'\r\n  | 'arranger'\r\n  | 'introducer'\r\n  | 'partner'\r\n  | 'commercial_partner'\r\n  | 'lawyer'\r\n  | 'ceo'\r\n\r\n// All persona types (from get_user_personas())\r\nexport type PersonaType = 'staff' | 'investor' | 'arranger' | 'introducer' | 'partner' | 'commercial_partner' | 'lawyer'\r\n\r\n// UserRole = ProfileRole for backward compatibility\r\nexport type UserRole = ProfileRole\r\n\r\nconst STAFF_ROLES: ProfileRole[] = ['staff_admin', 'staff_ops', 'staff_rm', 'ceo']\r\n\r\nexport interface AuthUser {\r\n  id: string\r\n  email: string\r\n  displayName: string\r\n  avatar?: string\r\n  role: UserRole\r\n  title?: string\r\n  created_at: string\r\n  permissions?: string[]\r\n}\r\n\r\n// Alias for backward compatibility\r\nexport type Profile = AuthUser\r\n\r\nexport interface AuthSession {\r\n  user: AuthUser\r\n  session: Session\r\n}\r\n\r\nexport class AuthError extends Error {\r\n  constructor(message: string, public code?: string) {\r\n    super(message)\r\n    this.name = 'AuthError'\r\n  }\r\n}\r\n\r\n// Server-side Supabase client\r\nconst createServerSupabaseClient = async () => {\r\n  const cookieStore = await cookies()\r\n\r\n  return createServerClient(\r\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\r\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\r\n    {\r\n      cookies: {\r\n        getAll() {\r\n          return cookieStore.getAll()\r\n        },\r\n        setAll(cookiesToSet) {\r\n          try {\r\n            cookiesToSet.forEach(({ name, value, options }) =>\r\n              cookieStore.set(name, value, options)\r\n            )\r\n          } catch {\r\n            // The `setAll` method was called from a Server Component.\r\n            // This can be ignored if you have middleware refreshing\r\n            // user sessions.\r\n          }\r\n        },\r\n      },\r\n    }\r\n  )\r\n}\r\n\r\n// Get current user with profile data\r\nexport async function getCurrentUser(): Promise<AuthUser | null> {\r\n  try {\r\n    const supabase = await createServerSupabaseClient()\r\n\r\n    // Get current auth user\r\n    const { data: { user }, error: userError } = await supabase.auth.getUser()\r\n\r\n    if (userError || !user) {\r\n      return null\r\n    }\r\n\r\n    // Get profile data from database\r\n    const { data: profile, error: profileError } = await supabase\r\n      .from('profiles')\r\n      .select('*')\r\n      .eq('id', user.id)\r\n      .single()\r\n\r\n    if (profileError || !profile) {\r\n      console.error('[auth] Profile not found for user:', user.id, profileError)\r\n      return null\r\n    }\r\n\r\n    // Fetch permissions for staff users\r\n    let permissions: string[] = []\r\n    const isStaffRole = STAFF_ROLES.includes(profile.role)\r\n\r\n    if (isStaffRole) {\r\n      const { data: permissionsData } = await supabase\r\n        .from('staff_permissions')\r\n        .select('permission')\r\n        .eq('user_id', user.id)\r\n\r\n      permissions = permissionsData?.map(p => p.permission) || []\r\n    }\r\n\r\n    return {\r\n      id: profile.id,\r\n      email: profile.email,\r\n      displayName: profile.display_name || profile.email?.split('@')[0] || 'User',\r\n      avatar: profile.avatar_url,\r\n      role: profile.role as UserRole,\r\n      title: profile.title,\r\n      created_at: profile.created_at,\r\n      permissions\r\n    }\r\n  } catch (error) {\r\n    console.error('Error getting current user:', error)\r\n    return null\r\n  }\r\n}\r\n\r\n// Get current session\r\nexport async function getCurrentSession(): Promise<Session | null> {\r\n  try {\r\n    const supabase = await createServerSupabaseClient()\r\n\r\n    const { data: { session }, error } = await supabase.auth.getSession()\r\n\r\n    if (error) {\r\n      console.error('Error getting session:', error)\r\n      return null\r\n    }\r\n\r\n    return session\r\n  } catch (error) {\r\n    console.error('Error getting session:', error)\r\n    return null\r\n  }\r\n}\r\n\r\n// Get profile (alias for getCurrentUser for backward compatibility)\r\nexport async function getProfile(): Promise<AuthUser | null> {\r\n  const user = await getCurrentUser()\r\n  if (user) {\r\n    console.log('[auth] Profile retrieved:', user.email, user.role)\r\n  } else {\r\n    console.log('[auth] No profile found')\r\n  }\r\n  return user\r\n}\r\n\r\n// Require authentication\r\nexport async function requireAuth(allowedRoles?: UserRole[]) {\r\n  const user = await getCurrentUser()\r\n\r\n  if (!user) {\r\n    redirect('/versotech_main/login')\r\n  }\r\n\r\n  if (allowedRoles && !allowedRoles.includes(user.role)) {\r\n    throw new Error('Insufficient permissions')\r\n  }\r\n\r\n  return user\r\n}\r\n\r\n// Require investor auth\r\nexport async function requireInvestorAuth() {\r\n  const user = await getCurrentUser()\r\n\r\n  if (!user) {\r\n    redirect('/versotech_main/login')\r\n  }\r\n\r\n  if (user.role !== 'investor') {\r\n    throw new Error('Investor access required')\r\n  }\r\n\r\n  return user\r\n}\r\n\r\n// Require staff auth\r\nexport async function requireStaffAuth() {\r\n  const user = await getCurrentUser()\r\n\r\n  if (!user) {\r\n    redirect('/versotech_main/login')\r\n  }\r\n\r\n  if (!STAFF_ROLES.includes(user.role)) {\r\n    throw new Error('Staff access required')\r\n  }\r\n\r\n  return user\r\n}\r\n\r\n/**\r\n * Check if a user has staff-level access for page authorization.\r\n *\r\n * IMPORTANT: Staff users (staff_admin, ceo, staff_ops, staff_rm) don't have\r\n * traditional database persona entries. Their \"personas\" are created synthetically\r\n * in the layout. This function checks BOTH:\r\n * 1. Profile role (for staff users without persona entries)\r\n * 2. Database personas (for users with explicit staff/ceo persona entries)\r\n *\r\n * @param userId - The user's ID\r\n * @returns true if user has staff access (via role OR persona)\r\n */\r\nexport async function checkStaffAccess(userId: string): Promise<boolean> {\r\n  const supabase = await createServerSupabaseClient()\r\n\r\n  // Check profile role first (handles synthetic staff personas)\r\n  const { data: profile, error: profileError } = await supabase\r\n    .from('profiles')\r\n    .select('role')\r\n    .eq('id', userId)\r\n    .single()\r\n\r\n  if (!profileError && profile && STAFF_ROLES.includes(profile.role as ProfileRole)) {\r\n    return true\r\n  }\r\n\r\n  // Fallback: check database personas (for edge cases)\r\n  const { data: personas } = await supabase.rpc('get_user_personas', {\r\n    p_user_id: userId\r\n  })\r\n\r\n  return personas?.some(\r\n    (p: { persona_type: string }) => p.persona_type === 'staff' || p.persona_type === 'ceo'\r\n  ) || false\r\n}\r\n\r\n/**\r\n * Check if a user has CEO-level access (full admin access).\r\n * CEO access is granted to users with 'ceo' or 'staff_admin' profile roles.\r\n */\r\nexport async function checkCeoAccess(userId: string): Promise<boolean> {\r\n  const supabase = await createServerSupabaseClient()\r\n\r\n  const { data: profile } = await supabase\r\n    .from('profiles')\r\n    .select('role')\r\n    .eq('id', userId)\r\n    .single()\r\n\r\n  return profile?.role === 'ceo' || profile?.role === 'staff_admin'\r\n}\r\n\r\n// Export STAFF_ROLES for use in pages\r\nexport { STAFF_ROLES }\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 309, "column": 0}, "map": {"version":3,"sources":["file:///Users/ghilesmoussaoui/Desktop/Versotech/versotech-portal/src/lib/fees/subscription-fee-calculator.ts"],"sourcesContent":["/**\r\n * Subscription Fee Calculator\r\n * Calculates fee events from subscription data\r\n *\r\n * Source of Truth: Subscription table (amounts)\r\n * Frequency Source: Fee plan (if linked)\r\n */\r\n\r\nimport { SupabaseClient } from '@supabase/supabase-js';\r\n\r\ninterface SubscriptionFees {\r\n  subscription_fee_percent?: number | null;\r\n  subscription_fee_amount?: number | null;\r\n  spread_fee_amount?: number | null;\r\n  bd_fee_percent?: number | null;\r\n  bd_fee_amount?: number | null;\r\n  finra_fee_amount?: number | null;\r\n  management_fee_percent?: number | null;\r\n  management_fee_amount?: number | null;\r\n  management_fee_frequency?: string | null;\r\n  performance_fee_tier1_percent?: number | null;\r\n  performance_fee_tier1_threshold?: number | null;\r\n  performance_fee_tier2_percent?: number | null;\r\n  performance_fee_tier2_threshold?: number | null;\r\n}\r\n\r\ninterface FeeEvent {\r\n  fee_type: 'subscription' | 'management' | 'performance' | 'spread_markup' | 'bd_fee' | 'finra_fee' | 'flat' | 'other';\r\n  base_amount: number;\r\n  computed_amount: number;\r\n  rate_bps?: number | null;\r\n  frequency: 'one_time' | 'quarterly' | 'annual' | 'monthly' | 'on_exit';\r\n  payment_schedule: 'upfront' | 'recurring' | 'on_demand';\r\n  description: string;\r\n}\r\n\r\n/**\r\n * Calculate fee events for a subscription\r\n * @param supabase - Supabase client\r\n * @param subscriptionId - Subscription ID\r\n * @returns Array of fee events to be created\r\n */\r\nexport async function calculateSubscriptionFeeEvents(\r\n  supabase: SupabaseClient,\r\n  subscriptionId: string\r\n): Promise<{ success: boolean; feeEvents?: FeeEvent[]; error?: string }> {\r\n  try {\r\n    // Fetch subscription with fee plan and vehicle\r\n    const { data: subscription, error: subError } = await supabase\r\n      .from('subscriptions')\r\n      .select(`\r\n        *,\r\n        vehicle:vehicles (\r\n          id,\r\n          name\r\n        ),\r\n        fee_plan:fee_plans (\r\n          id,\r\n          components:fee_components (\r\n            kind,\r\n            frequency,\r\n            payment_schedule\r\n          )\r\n        )\r\n      `)\r\n      .eq('id', subscriptionId)\r\n      .single();\r\n\r\n    if (subError || !subscription) {\r\n      return { success: false, error: subError?.message || 'Subscription not found' };\r\n    }\r\n\r\n    const feeEvents: FeeEvent[] = [];\r\n    const fees = subscription as SubscriptionFees;\r\n    const feePlan = (subscription as any).fee_plan;\r\n\r\n    // Helper to get frequency/payment_schedule from fee plan\r\n    const getFrequencyInfo = (kind: string) => {\r\n      if (!feePlan || !feePlan.components) {\r\n        // No fee plan: default to one_time/upfront\r\n        return { frequency: 'one_time' as const, payment_schedule: 'upfront' as const };\r\n      }\r\n\r\n      const component = feePlan.components.find((c: any) => c.kind === kind);\r\n      return {\r\n        frequency: component?.frequency || 'one_time' as const,\r\n        payment_schedule: component?.payment_schedule || 'upfront' as const,\r\n      };\r\n    };\r\n\r\n    // 0. COMMITMENT AMOUNT (the investment itself)\r\n    // This is the primary payment - the investor's actual commitment to the vehicle\r\n    const commitmentAmount = subscription.commitment || 0;\r\n    if (commitmentAmount > 0) {\r\n      feeEvents.push({\r\n        fee_type: 'flat',\r\n        base_amount: commitmentAmount,\r\n        computed_amount: commitmentAmount,\r\n        rate_bps: null,\r\n        frequency: 'one_time',\r\n        payment_schedule: 'upfront',\r\n        description: `Investment commitment - ${(subscription as any).vehicle?.name || 'vehicle'}`,\r\n      });\r\n    }\r\n\r\n    // 1. Subscription Fee\r\n    // Note: Check for != null to properly handle explicit 0 values (0 means \"no fee\")\r\n    if (fees.subscription_fee_percent != null || fees.subscription_fee_amount != null) {\r\n      const baseAmount = subscription.commitment || 0;\r\n      const { frequency, payment_schedule } = getFrequencyInfo('subscription');\r\n\r\n      // Use explicit amount if provided (even if 0), otherwise calculate from percent\r\n      const computedAmount = fees.subscription_fee_amount != null\r\n        ? fees.subscription_fee_amount\r\n        : (baseAmount * (fees.subscription_fee_percent || 0) / 100);\r\n\r\n      feeEvents.push({\r\n        fee_type: 'subscription',\r\n        base_amount: baseAmount,\r\n        computed_amount: computedAmount,\r\n        rate_bps: fees.subscription_fee_percent ? Math.round(fees.subscription_fee_percent * 100) : null,\r\n        frequency,\r\n        payment_schedule,\r\n        description: `Subscription fee for ${subscription.commitment || 0} commitment`,\r\n      });\r\n    }\r\n\r\n    // 2. Management Fee\r\n    // Note: Check for != null to properly handle explicit 0 values (0 means \"no fee\")\r\n    if (fees.management_fee_percent != null || fees.management_fee_amount != null) {\r\n      const baseAmount = subscription.commitment || 0;\r\n      const { frequency, payment_schedule } = getFrequencyInfo('management');\r\n\r\n      // Use subscription's frequency if specified, otherwise use fee plan\r\n      const finalFrequency = fees.management_fee_frequency || frequency;\r\n\r\n      // Use explicit amount if provided (even if 0), otherwise calculate from percent\r\n      const computedAmount = fees.management_fee_amount != null\r\n        ? fees.management_fee_amount\r\n        : (baseAmount * (fees.management_fee_percent || 0) / 100);\r\n\r\n      feeEvents.push({\r\n        fee_type: 'management',\r\n        base_amount: baseAmount,\r\n        computed_amount: computedAmount,\r\n        rate_bps: fees.management_fee_percent ? Math.round(fees.management_fee_percent * 100) : null,\r\n        frequency: finalFrequency as any,\r\n        payment_schedule,\r\n        description: `Management fee for ${subscription.commitment || 0} commitment`,\r\n      });\r\n    }\r\n\r\n    // 3. BD Fee (Broker-Dealer)\r\n    // Note: Check for != null to properly handle explicit 0 values (0 means \"no fee\")\r\n    if (fees.bd_fee_percent != null || fees.bd_fee_amount != null) {\r\n      const baseAmount = subscription.commitment || 0;\r\n      const { frequency, payment_schedule } = getFrequencyInfo('bd_fee');\r\n\r\n      // Use explicit amount if provided (even if 0), otherwise calculate from percent\r\n      const computedAmount = fees.bd_fee_amount != null\r\n        ? fees.bd_fee_amount\r\n        : (baseAmount * (fees.bd_fee_percent || 0) / 100);\r\n\r\n      feeEvents.push({\r\n        fee_type: 'bd_fee',\r\n        base_amount: baseAmount,\r\n        computed_amount: computedAmount,\r\n        rate_bps: fees.bd_fee_percent ? Math.round(fees.bd_fee_percent * 100) : null,\r\n        frequency,\r\n        payment_schedule,\r\n        description: `Broker-dealer fee for ${subscription.commitment || 0} commitment`,\r\n      });\r\n    }\r\n\r\n    // 4. FINRA Fee\r\n    if (fees.finra_fee_amount) {\r\n      const { frequency, payment_schedule } = getFrequencyInfo('finra_fee');\r\n\r\n      feeEvents.push({\r\n        fee_type: 'finra_fee',\r\n        base_amount: fees.finra_fee_amount,\r\n        computed_amount: fees.finra_fee_amount,\r\n        rate_bps: null,\r\n        frequency,\r\n        payment_schedule,\r\n        description: 'FINRA regulatory fee',\r\n      });\r\n    }\r\n\r\n    // 5. Spread Fee\r\n    if (fees.spread_fee_amount) {\r\n      const { frequency, payment_schedule } = getFrequencyInfo('spread_markup');\r\n\r\n      feeEvents.push({\r\n        fee_type: 'spread_markup',\r\n        base_amount: fees.spread_fee_amount,\r\n        computed_amount: fees.spread_fee_amount,\r\n        rate_bps: null,\r\n        frequency,\r\n        payment_schedule,\r\n        description: 'Spread markup fee',\r\n      });\r\n    }\r\n\r\n    // 6. Performance Fee (Tier 1 and Tier 2)\r\n    if (fees.performance_fee_tier1_percent || fees.performance_fee_tier2_percent) {\r\n      const { frequency, payment_schedule } = getFrequencyInfo('performance');\r\n\r\n      // Calculate actual performance fee if NAV exists\r\n      const commitment = subscription.commitment || 0;\r\n      const nav = (subscription as any).current_nav || 0;\r\n      let performanceFee = 0;\r\n      const tier1Threshold = fees.performance_fee_tier1_threshold || 0;\r\n      const tier2Threshold = fees.performance_fee_tier2_threshold || 0;\r\n      const tier1Percent = fees.performance_fee_tier1_percent || 0;\r\n      const tier2Percent = fees.performance_fee_tier2_percent || 0;\r\n\r\n      // Calculate returns-based performance fee (same logic as overview page)\r\n      if (nav > 0 && commitment > 0) {\r\n        const returns = nav - commitment;\r\n        if (returns > 0) {\r\n          if (tier2Percent > 0 && returns > tier2Threshold) {\r\n            performanceFee = returns * (tier2Percent / 100);\r\n          } else if (tier1Percent > 0 && returns > tier1Threshold) {\r\n            performanceFee = returns * (tier1Percent / 100);\r\n          }\r\n        }\r\n      }\r\n\r\n      // Create description based on which tier applies\r\n      let description = 'Performance fee';\r\n      if (tier2Percent > 0 && tier2Threshold > 0) {\r\n        description = `Performance fee (Tier 2: ${tier2Percent}% above ${tier2Threshold} returns)`;\r\n      } else if (tier1Percent > 0) {\r\n        description = `Performance fee (Tier 1: ${tier1Percent}% above ${tier1Threshold || 0} returns)`;\r\n      }\r\n\r\n      feeEvents.push({\r\n        fee_type: 'performance',\r\n        base_amount: nav > 0 ? nav - commitment : 0,\r\n        computed_amount: performanceFee,\r\n        rate_bps: tier2Percent > 0 ? Math.round(tier2Percent * 100) : Math.round(tier1Percent * 100),\r\n        frequency,\r\n        payment_schedule,\r\n        description,\r\n      });\r\n    }\r\n\r\n    return { success: true, feeEvents };\r\n  } catch (error) {\r\n    console.error('Error calculating subscription fee events:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Unknown error',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Create fee event records in database\r\n * @param supabase - Supabase client\r\n * @param subscriptionId - Subscription ID\r\n * @param feeEvents - Calculated fee events\r\n * @returns Created fee event IDs\r\n */\r\nexport async function createFeeEvents(\r\n  supabase: SupabaseClient,\r\n  subscriptionId: string,\r\n  investorId: string,\r\n  dealId: string | null,\r\n  feePlanId: string | null,\r\n  feeEvents: FeeEvent[],\r\n  options?: { skipDeduplication?: boolean }\r\n): Promise<{ success: boolean; feeEventIds?: string[]; error?: string; skipped?: boolean }> {\r\n  try {\r\n    // Deduplication check: Skip if fee events already exist for this subscription\r\n    // This prevents double-charging if createFeeEvents is called multiple times\r\n    if (!options?.skipDeduplication) {\r\n      const { data: existingEvents, error: checkError } = await supabase\r\n        .from('fee_events')\r\n        .select('id')\r\n        .eq('allocation_id', subscriptionId)\r\n        .limit(1);\r\n\r\n      if (checkError) {\r\n        console.warn('[FEE EVENTS] Error checking existing fee events:', checkError.message);\r\n        // Continue anyway - better to risk duplicates than fail silently\r\n      } else if (existingEvents && existingEvents.length > 0) {\r\n        console.log(`[FEE EVENTS] Fee events already exist for subscription ${subscriptionId}, skipping creation`);\r\n        return { success: true, feeEventIds: [], skipped: true };\r\n      }\r\n    }\r\n\r\n    // Fetch subscription to get currency\r\n    const { data: subscription } = await supabase\r\n      .from('subscriptions')\r\n      .select('currency')\r\n      .eq('id', subscriptionId)\r\n      .single();\r\n\r\n    const currency = subscription?.currency || 'USD';\r\n\r\n    // Determine payee_arranger_id - first check fee_plan, then deal\r\n    let payeeArrangerId: string | null = null;\r\n\r\n    // Check if fee_plan was created by an arranger\r\n    if (feePlanId) {\r\n      const { data: feePlan } = await supabase\r\n        .from('fee_plans')\r\n        .select('created_by_arranger_id')\r\n        .eq('id', feePlanId)\r\n        .single();\r\n\r\n      if (feePlan?.created_by_arranger_id) {\r\n        payeeArrangerId = feePlan.created_by_arranger_id;\r\n      }\r\n    }\r\n\r\n    // If no arranger from fee_plan, check deal\r\n    if (!payeeArrangerId && dealId) {\r\n      const { data: deal } = await supabase\r\n        .from('deals')\r\n        .select('arranger_entity_id')\r\n        .eq('id', dealId)\r\n        .single();\r\n\r\n      if (deal?.arranger_entity_id) {\r\n        payeeArrangerId = deal.arranger_entity_id;\r\n      }\r\n    }\r\n\r\n    // If we have a fee plan, fetch its components to link properly\r\n    const componentMap: Record<string, string> = {};\r\n    if (feePlanId) {\r\n      const { data: components } = await supabase\r\n        .from('fee_components')\r\n        .select('id, kind')\r\n        .eq('fee_plan_id', feePlanId);\r\n\r\n      if (components) {\r\n        // Map fee_type to component_id\r\n        components.forEach((comp: any) => {\r\n          componentMap[comp.kind] = comp.id;\r\n        });\r\n      }\r\n    }\r\n\r\n    const inserts = feeEvents.map((fe) => {\r\n      // Match fee_type to fee_component_id\r\n      // fee_type 'flat' (commitment) doesn't get a component_id\r\n      const feeComponentId = fe.fee_type === 'flat' ? null : componentMap[fe.fee_type] || null;\r\n\r\n      // Warn if fee type expected a component but none found\r\n      if (fe.fee_type !== 'flat' && !feeComponentId && feePlanId) {\r\n        console.warn(\r\n          `⚠️ [FEE EVENTS] No component found for fee_type '${fe.fee_type}' in fee plan ${feePlanId}. ` +\r\n          `Fee event will be created without component link.`\r\n        );\r\n      }\r\n\r\n      return {\r\n        investor_id: investorId,\r\n        deal_id: dealId,\r\n        allocation_id: subscriptionId, // Link to subscription\r\n        fee_component_id: feeComponentId, // NOW PROPERLY LINKED!\r\n        fee_type: fe.fee_type,\r\n        event_date: new Date().toISOString(),\r\n        base_amount: fe.base_amount,\r\n        computed_amount: fe.computed_amount,\r\n        rate_bps: fe.rate_bps,\r\n        currency: currency, // Use subscription currency\r\n        status: 'accrued', // Ready to be invoiced\r\n        notes: fe.description,\r\n        payee_arranger_id: payeeArrangerId, // Link to arranger for payment requests\r\n      };\r\n    });\r\n\r\n    const { data, error } = await supabase\r\n      .from('fee_events')\r\n      .insert(inserts)\r\n      .select('id');\r\n\r\n    if (error) {\r\n      return { success: false, error: error.message };\r\n    }\r\n\r\n    return {\r\n      success: true,\r\n      feeEventIds: data?.map((d) => d.id) || [],\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating fee events:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Unknown error',\r\n    };\r\n  }\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 602, "column": 0}, "map": {"version":3,"sources":["file:///Users/ghilesmoussaoui/Desktop/Versotech/versotech-portal/src/app/api/subscriptions/route.ts"],"sourcesContent":["import { createClient, createServiceClient } from '@/lib/supabase/server'\r\nimport { requireStaffAuth } from '@/lib/auth'\r\nimport { NextRequest, NextResponse } from 'next/server'\r\nimport { calculateSubscriptionFeeEvents, createFeeEvents } from '@/lib/fees/subscription-fee-calculator'\r\n\r\nexport const dynamic = 'force-dynamic'\r\n\r\nexport async function GET(request: NextRequest) {\r\n  try {\r\n    await requireStaffAuth()\r\n    const supabase = await createClient()\r\n\r\n    const { searchParams } = new URL(request.url)\r\n    const vehicleId = searchParams.get('vehicle')\r\n    const investorId = searchParams.get('investor_id')\r\n    const status = searchParams.get('status')\r\n    const search = searchParams.get('q')\r\n    // Default to fetching ALL subscriptions (no pagination by default)\r\n    const limit = searchParams.get('limit') ? parseInt(searchParams.get('limit')!) : null\r\n    const page = limit ? parseInt(searchParams.get('page') || '1') : null\r\n    const offset = limit && page ? (page - 1) * limit : null\r\n\r\n    // Build query\r\n    let query = supabase\r\n      .from('subscriptions')\r\n      .select(\r\n        `\r\n          *,\r\n          investor:investors (\r\n            id,\r\n            legal_name,\r\n            type,\r\n            country,\r\n            kyc_status\r\n          ),\r\n          vehicle:vehicles (\r\n            id,\r\n            name,\r\n            type,\r\n            currency,\r\n            status,\r\n            entity_code,\r\n            investment_name\r\n          ),\r\n          introducer:introducers (\r\n            id,\r\n            legal_name\r\n          ),\r\n          deal:deals (\r\n            id,\r\n            name\r\n          )\r\n        `,\r\n        { count: 'exact' }\r\n      )\r\n      .order('subscription_number', { ascending: false })\r\n\r\n    // Apply filters\r\n    if (vehicleId) {\r\n      query = query.eq('vehicle_id', vehicleId)\r\n    }\r\n\r\n    if (investorId) {\r\n      query = query.eq('investor_id', investorId)\r\n    }\r\n\r\n    if (status) {\r\n      query = query.eq('status', status)\r\n    }\r\n\r\n    if (search) {\r\n      // Search by subscription number or investor name\r\n      const searchNum = parseInt(search)\r\n      if (!isNaN(searchNum)) {\r\n        query = query.eq('subscription_number', searchNum)\r\n      } else {\r\n        // This requires a join query - we'll handle it differently\r\n        query = query.or(`investor.legal_name.ilike.%${search}%`)\r\n      }\r\n    }\r\n\r\n    // Apply pagination only if limit is specified\r\n    if (offset !== null && limit !== null) {\r\n      query = query.range(offset, offset + limit - 1)\r\n    }\r\n\r\n    const { data: subscriptions, error, count } = await query\r\n\r\n    if (error) {\r\n      console.error('[Subscriptions API] Error:', error)\r\n      return NextResponse.json(\r\n        { error: 'Failed to fetch subscriptions', details: error.message },\r\n        { status: 500 }\r\n      )\r\n    }\r\n\r\n    // Calculate summary statistics\r\n    const allSubscriptionsQuery = await supabase\r\n      .from('subscriptions')\r\n      .select('status, commitment, currency, funding_due_at')\r\n\r\n    const allSubs = allSubscriptionsQuery.data || []\r\n\r\n    const summary = {\r\n      total: count || 0,\r\n      by_status: allSubs.reduce((acc, sub) => {\r\n        acc[sub.status] = (acc[sub.status] || 0) + 1\r\n        return acc\r\n      }, {} as Record<string, number>),\r\n      by_currency: allSubs.reduce((acc, sub) => {\r\n        acc[sub.currency || 'USD'] = (acc[sub.currency || 'USD'] || 0) + (sub.commitment || 0)\r\n        return acc\r\n      }, {} as Record<string, number>),\r\n      total_commitment: allSubs.reduce((sum, sub) => sum + (sub.commitment || 0), 0),\r\n      overdue_count: allSubs.filter(\r\n        (sub) =>\r\n          sub.status === 'committed' &&\r\n          sub.funding_due_at &&\r\n          new Date(sub.funding_due_at) < new Date()\r\n      ).length,\r\n      overdue_amount: allSubs\r\n        .filter(\r\n          (sub) =>\r\n            sub.status === 'committed' &&\r\n            sub.funding_due_at &&\r\n            new Date(sub.funding_due_at) < new Date()\r\n        )\r\n        .reduce((sum, sub) => sum + (sub.commitment || 0), 0),\r\n    }\r\n\r\n    return NextResponse.json({\r\n      data: subscriptions || [],\r\n      subscriptions: subscriptions || [],\r\n      summary,\r\n      pagination: limit ? {\r\n        page: page || 1,\r\n        limit,\r\n        total: count || 0,\r\n        totalPages: Math.ceil((count || 0) / limit),\r\n      } : null,\r\n    })\r\n  } catch (error) {\r\n    console.error('[Subscriptions API] Exception:', error)\r\n    return NextResponse.json(\r\n      { error: 'Internal server error' },\r\n      { status: 500 }\r\n    )\r\n  }\r\n}\r\n\r\n// Bulk update endpoint\r\nexport async function PATCH(request: NextRequest) {\r\n  try {\r\n    await requireStaffAuth()\r\n    const supabase = await createClient()\r\n    const serviceSupabase = createServiceClient()\r\n\r\n    const body = await request.json()\r\n    const { subscription_ids, updates } = body\r\n\r\n    if (!subscription_ids || !Array.isArray(subscription_ids) || subscription_ids.length === 0) {\r\n      return NextResponse.json(\r\n        { error: 'subscription_ids array is required' },\r\n        { status: 400 }\r\n      )\r\n    }\r\n\r\n    if (!updates || typeof updates !== 'object') {\r\n      return NextResponse.json(\r\n        { error: 'updates object is required' },\r\n        { status: 400 }\r\n      )\r\n    }\r\n\r\n    // Validate allowed fields\r\n    const allowedFields = ['status', 'effective_date', 'funding_due_at', 'acknowledgement_notes']\r\n    const updateFields = Object.keys(updates)\r\n    const invalidFields = updateFields.filter((field) => !allowedFields.includes(field))\r\n\r\n    if (invalidFields.length > 0) {\r\n      return NextResponse.json(\r\n        { error: `Invalid fields: ${invalidFields.join(', ')}` },\r\n        { status: 400 }\r\n      )\r\n    }\r\n\r\n    // If status is being changed to 'committed', fetch subscriptions to check old status\r\n    let subsToAutoCalculateFees: string[] = []\r\n    if (updates.status === 'committed') {\r\n      const { data: existingSubs } = await serviceSupabase\r\n        .from('subscriptions')\r\n        .select('id, status')\r\n        .in('id', subscription_ids)\r\n\r\n      // Only auto-calculate fees for subscriptions that are NOT already committed\r\n      subsToAutoCalculateFees = (existingSubs || [])\r\n        .filter((sub) => sub.status !== 'committed')\r\n        .map((sub) => sub.id)\r\n    }\r\n\r\n    const { error } = await supabase\r\n      .from('subscriptions')\r\n      .update({\r\n        ...updates,\r\n        updated_at: new Date().toISOString(),\r\n      })\r\n      .in('id', subscription_ids)\r\n\r\n    if (error) {\r\n      console.error('[Subscriptions API] Bulk update error:', error)\r\n      return NextResponse.json(\r\n        { error: 'Failed to update subscriptions', details: error.message },\r\n        { status: 500 }\r\n      )\r\n    }\r\n\r\n    // AUTO-CALCULATE FEE EVENTS for subscriptions that became 'committed'\r\n    let feeEventsCreatedCount = 0\r\n    if (subsToAutoCalculateFees.length > 0) {\r\n      console.log(`[Subscriptions API] Auto-calculating fee events for ${subsToAutoCalculateFees.length} subscription(s)`)\r\n\r\n      for (const subId of subsToAutoCalculateFees) {\r\n        // Check if fee events already exist\r\n        const { data: existingFeeEvents } = await serviceSupabase\r\n          .from('fee_events')\r\n          .select('id')\r\n          .eq('allocation_id', subId)\r\n          .limit(1)\r\n\r\n        if (!existingFeeEvents || existingFeeEvents.length === 0) {\r\n          // Get subscription details\r\n          const { data: sub } = await serviceSupabase\r\n            .from('subscriptions')\r\n            .select('investor_id, vehicle_id, fee_plan_id')\r\n            .eq('id', subId)\r\n            .single()\r\n\r\n          if (sub) {\r\n            // Calculate fee events\r\n            const calculationResult = await calculateSubscriptionFeeEvents(serviceSupabase, subId)\r\n\r\n            if (calculationResult.success && calculationResult.feeEvents && calculationResult.feeEvents.length > 0) {\r\n              // Create fee events (subscriptions don't have deal_id)\r\n              const creationResult = await createFeeEvents(\r\n                serviceSupabase,\r\n                subId,\r\n                sub.investor_id,\r\n                null, // subscriptions are linked to vehicles, not deals\r\n                sub.fee_plan_id || null,\r\n                calculationResult.feeEvents\r\n              )\r\n\r\n              if (creationResult.success) {\r\n                feeEventsCreatedCount++\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      message: `Successfully updated ${subscription_ids.length} subscription(s)`,\r\n      updated_count: subscription_ids.length,\r\n      fee_events_created_for: feeEventsCreatedCount,\r\n    })\r\n  } catch (error) {\r\n    console.error('[Subscriptions API] PATCH exception:', error)\r\n    return NextResponse.json(\r\n      { error: 'Internal server error' },\r\n      { status: 500 }\r\n    )\r\n  }\r\n}\r\n\r\n// Export subscriptions\r\nexport async function POST(request: NextRequest) {\r\n  try {\r\n    await requireStaffAuth()\r\n    const supabase = await createClient()\r\n\r\n    const body = await request.json()\r\n    const { subscription_ids, format = 'csv' } = body\r\n\r\n    let query = supabase\r\n      .from('subscriptions')\r\n      .select(\r\n        `\r\n          *,\r\n          investor:investors (\r\n            legal_name,\r\n            type,\r\n            country\r\n          ),\r\n          vehicle:vehicles (\r\n            name,\r\n            type,\r\n            currency\r\n          )\r\n        `\r\n      )\r\n      .order('subscription_number', { ascending: true })\r\n\r\n    if (subscription_ids && Array.isArray(subscription_ids) && subscription_ids.length > 0) {\r\n      query = query.in('id', subscription_ids)\r\n    }\r\n\r\n    const { data, error } = await query\r\n\r\n    if (error) {\r\n      return NextResponse.json(\r\n        { error: 'Failed to fetch subscriptions for export' },\r\n        { status: 500 }\r\n      )\r\n    }\r\n\r\n    // For now, return JSON - CSV formatting can be added later\r\n    return NextResponse.json({\r\n      data,\r\n      count: data?.length || 0,\r\n      format,\r\n    })\r\n  } catch (error) {\r\n    console.error('[Subscriptions API] Export exception:', error)\r\n    return NextResponse.json(\r\n      { error: 'Internal server error' },\r\n      { status: 500 }\r\n    )\r\n  }\r\n}\r\n"],"names":[],"mappings":"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"}}]
}