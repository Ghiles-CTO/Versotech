module.exports = [
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/stream [external] (stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}),
"[externals]/http [external] (http, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}),
"[externals]/url [external] (url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}),
"[externals]/punycode [external] (punycode, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("punycode", () => require("punycode"));

module.exports = mod;
}),
"[externals]/https [external] (https, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}),
"[externals]/zlib [external] (zlib, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}),
"[project]/versotech-portal/src/lib/supabase/server.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createClient",
    ()=>createClient,
    "createServiceClient",
    ()=>createServiceClient
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f40$supabase$2f$ssr$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/versotech-portal/node_modules/@supabase/ssr/dist/module/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f40$supabase$2f$ssr$2f$dist$2f$module$2f$createServerClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/versotech-portal/node_modules/@supabase/ssr/dist/module/createServerClient.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/versotech-portal/node_modules/@supabase/supabase-js/dist/module/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/versotech-portal/node_modules/next/headers.js [app-route] (ecmascript)");
;
;
;
const createClient = async ()=>{
    const cookieStore = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["cookies"])();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f40$supabase$2f$ssr$2f$dist$2f$module$2f$createServerClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createServerClient"])(("TURBOPACK compile-time value", "https://ipguxdssecfexudnvtia.supabase.co"), ("TURBOPACK compile-time value", "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImlwZ3V4ZHNzZWNmZXh1ZG52dGlhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgzNjE4MzcsImV4cCI6MjA3MzkzNzgzN30.AGxM_YW9hfxuu7xDpi_4xhOoRhYM7iGTS1vJ0z2FByE"), {
        cookies: {
            getAll () {
                return cookieStore.getAll();
            },
            setAll (cookiesToSet) {
                try {
                    cookiesToSet.forEach(({ name, value, options })=>{
                        cookieStore.set(name, value, options);
                    });
                } catch (error) {
                // The `setAll` method was called from a Server Component.
                // This can be ignored if you have middleware refreshing
                // user sessions.
                }
            }
        }
    });
};
const createServiceClient = ()=>{
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createClient"])(("TURBOPACK compile-time value", "https://ipguxdssecfexudnvtia.supabase.co"), process.env.SUPABASE_SERVICE_ROLE_KEY, {
        auth: {
            autoRefreshToken: false,
            persistSession: false
        }
    });
};
}),
"[project]/versotech-portal/src/lib/audit.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AuditActions",
    ()=>AuditActions,
    "AuditEntities",
    ()=>AuditEntities,
    "auditLogger",
    ()=>auditLogger
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$src$2f$lib$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/versotech-portal/src/lib/supabase/server.ts [app-route] (ecmascript)");
;
class AuditLogger {
    static instance;
    static getInstance() {
        if (!AuditLogger.instance) {
            AuditLogger.instance = new AuditLogger();
        }
        return AuditLogger.instance;
    }
    async log(entry) {
        try {
            const supabase = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$src$2f$lib$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
            // Insert into audit_logs with correct column names
            await supabase.from('audit_logs').insert({
                event_type: 'system',
                actor_id: entry.actor_user_id || null,
                action: entry.action,
                entity_type: entry.entity,
                entity_id: entry.entity_id || null,
                action_details: entry.metadata || null,
                timestamp: new Date().toISOString()
            });
        } catch (error) {
            console.error('Audit logging failed:', error);
        // Don't throw to avoid breaking the main operation
        }
    }
    async logMany(entries) {
        for (const entry of entries){
            await this.log(entry);
        }
    }
}
const auditLogger = AuditLogger.getInstance();
const AuditActions = {
    // Authentication
    LOGIN: 'login',
    LOGOUT: 'logout',
    PASSWORD_CHANGE: 'password_change',
    // Data operations
    CREATE: 'create',
    READ: 'read',
    UPDATE: 'update',
    DELETE: 'delete',
    // Documents
    DOCUMENT_UPLOAD: 'document_upload',
    DOCUMENT_DOWNLOAD: 'document_download',
    DOCUMENT_DELETE: 'document_delete',
    // Workflows
    WORKFLOW_TRIGGER: 'workflow_trigger',
    WORKFLOW_COMPLETED: 'workflow_completed',
    WORKFLOW_FAILED: 'workflow_failed',
    // System operations
    USER_CREATED: 'user_created',
    PROFILE_UPDATED: 'profile_updated',
    ROLE_CHANGED: 'role_changed',
    // Business operations
    SUBSCRIPTION_CREATED: 'subscription_created',
    CAPITAL_CALL_CREATED: 'capital_call_created',
    DISTRIBUTION_CREATED: 'distribution_created',
    REPORT_REQUESTED: 'report_requested',
    MESSAGE_SENT: 'message_sent',
    // Commission lifecycle (GAP-7)
    COMMISSION_CREATED: 'commission_created',
    COMMISSION_ACCRUED: 'commission_accrued',
    COMMISSION_INVOICE_REQUESTED: 'commission_invoice_requested',
    COMMISSION_INVOICED: 'commission_invoiced',
    COMMISSION_PAID: 'commission_paid',
    COMMISSION_CANCELLED: 'commission_cancelled',
    // Agreement events (GAP-8)
    AGREEMENT_CREATED: 'agreement_created',
    AGREEMENT_SENT: 'agreement_sent',
    AGREEMENT_APPROVED: 'agreement_approved',
    AGREEMENT_SIGNED: 'agreement_signed',
    AGREEMENT_ACTIVATED: 'agreement_activated',
    AGREEMENT_REJECTED: 'agreement_rejected',
    AGREEMENT_EXPIRED: 'agreement_expired'
};
const AuditEntities = {
    USERS: 'users',
    PROFILES: 'profiles',
    INVESTORS: 'investors',
    VEHICLES: 'vehicles',
    SUBSCRIPTIONS: 'subscriptions',
    POSITIONS: 'positions',
    DOCUMENTS: 'documents',
    WORKFLOWS: 'workflows',
    WORKFLOW_RUNS: 'workflow_runs',
    CONVERSATIONS: 'conversations',
    MESSAGES: 'messages',
    REQUEST_TICKETS: 'request_tickets',
    CAPITAL_CALLS: 'capital_calls',
    DISTRIBUTIONS: 'distributions',
    DEALS: 'deals',
    // RESERVATIONS: 'reservations', // Deprecated - removed from workflow
    ALLOCATIONS: 'allocations',
    FEE_EVENTS: 'fee_events',
    INVOICES: 'invoices',
    BANK_TRANSACTIONS: 'bank_transactions',
    PAYMENTS: 'payments',
    ARRANGER: 'arranger_entities',
    INTRODUCER: 'introducers',
    PARTNER: 'partners',
    COMMERCIAL_PARTNER: 'commercial_partners',
    FEE_PLANS: 'arranger_fee_plans',
    CEO_ENTITY: 'ceo_entity',
    CEO_USERS: 'ceo_users',
    // Commission entities (GAP-7)
    INTRODUCER_COMMISSIONS: 'introducer_commissions',
    PARTNER_COMMISSIONS: 'partner_commissions',
    COMMERCIAL_PARTNER_COMMISSIONS: 'commercial_partner_commissions',
    // Agreement entities (GAP-8)
    INTRODUCER_AGREEMENTS: 'introducer_agreements',
    PARTNER_AGREEMENTS: 'partner_agreements',
    COMMERCIAL_PARTNER_AGREEMENTS: 'commercial_partner_agreements',
    // Introductions
    INTRODUCTIONS: 'introductions'
};
}),
"[project]/versotech-portal/src/lib/analytics.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "trackDealEvent",
    ()=>trackDealEvent
]);
async function trackDealEvent({ supabase, dealId, eventType, investorId, payload }) {
    try {
        await supabase.from('deal_activity_events').insert({
            deal_id: dealId,
            investor_id: investorId ?? null,
            event_type: eventType,
            payload: payload ?? {},
            occurred_at: new Date().toISOString()
        });
    } catch (error) {
        console.error('Failed to track deal analytics event', {
            eventType,
            dealId,
            error
        });
    }
}
}),
"[project]/versotech-portal/src/lib/entities/entity-investment-eligibility.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Entity Investment Eligibility Check
 *
 * Determines if an entity can invest based on:
 * 1. Entity KYC status (must be approved/completed)
 * 2. All signatory members must have:
 *    - CEO approval (ceo_approval_status = 'approved')
 *    - Individual KYC approved (kyc_status = 'approved' or 'completed')
 */ __turbopack_context__.s([
    "canEntityInvest",
    ()=>canEntityInvest,
    "getEligibilityBlockersSummary",
    ()=>getEligibilityBlockersSummary
]);
// Entity type to table mapping
const ENTITY_TABLES = {
    investor: 'investors',
    partner: 'partners',
    introducer: 'introducers',
    commercial_partner: 'commercial_partners',
    lawyer: 'lawyers',
    arranger: 'arranger_entities'
};
// User junction table mapping
const USER_TABLES = {
    investor: 'investor_users',
    partner: 'partner_users',
    introducer: 'introducer_users',
    commercial_partner: 'commercial_partner_users',
    lawyer: 'lawyer_users',
    arranger: 'arranger_users'
};
// Entity ID column in junction tables
const ENTITY_ID_COLUMNS = {
    investor: 'investor_id',
    partner: 'partner_id',
    introducer: 'introducer_id',
    commercial_partner: 'commercial_partner_id',
    lawyer: 'lawyer_id',
    arranger: 'arranger_id'
};
async function canEntityInvest(supabase, entityId, entityType) {
    const blockers = [];
    let entityKycStatus;
    let signatoryCount = 0;
    let approvedSignatoryCount = 0;
    // Validate entity type
    const entityTable = ENTITY_TABLES[entityType];
    const userTable = USER_TABLES[entityType];
    const entityIdColumn = ENTITY_ID_COLUMNS[entityType];
    if (!entityTable || !userTable || !entityIdColumn) {
        return {
            canInvest: false,
            blockers: [
                {
                    type: 'entity_kyc',
                    message: `Unknown entity type: ${entityType}`
                }
            ],
            signatoryCount: 0,
            approvedSignatoryCount: 0
        };
    }
    // 1. Check entity KYC status
    const { data: entity, error: entityError } = await supabase.from(entityTable).select('id, kyc_status').eq('id', entityId).single();
    if (entityError || !entity) {
        return {
            canInvest: false,
            blockers: [
                {
                    type: 'entity_kyc',
                    message: 'Entity not found'
                }
            ],
            signatoryCount: 0,
            approvedSignatoryCount: 0
        };
    }
    entityKycStatus = entity.kyc_status;
    // Entity KYC must be approved or completed
    const validEntityKycStatuses = [
        'approved',
        'completed',
        'verified'
    ];
    if (!entity.kyc_status || !validEntityKycStatuses.includes(entity.kyc_status.toLowerCase())) {
        blockers.push({
            type: 'entity_kyc',
            message: `Entity KYC is ${entity.kyc_status || 'not started'}. KYC must be approved before investing.`,
            details: {
                status: entity.kyc_status
            }
        });
    }
    // 2. Get all signatory members and check their CEO approval status
    // We need to check members where can_sign = true OR is_signatory = true
    const { data: members, error: membersError } = await supabase.from(userTable).select(`
      user_id,
      role,
      can_sign,
      ceo_approval_status,
      ceo_approved_at,
      profiles:user_id(
        id,
        display_name,
        email
      )
    `).eq(entityIdColumn, entityId).or('can_sign.eq.true,role.eq.admin,role.eq.owner') // Check signatories
    ;
    if (membersError) {
        console.error('Error fetching members:', membersError);
        return {
            canInvest: false,
            blockers: [
                {
                    type: 'member_approval',
                    message: 'Failed to verify member status'
                }
            ],
            entityKycStatus,
            signatoryCount: 0,
            approvedSignatoryCount: 0
        };
    }
    // Filter to actual signatories (can_sign = true)
    const signatories = members?.filter((m)=>m.can_sign === true) || [];
    signatoryCount = signatories.length;
    // If no explicit signatories, check admin/owner members
    const signatoriesToCheck = signatoryCount > 0 ? signatories : members?.filter((m)=>[
            'admin',
            'owner'
        ].includes(m.role)) || [];
    if (signatoriesToCheck.length === 0) {
        blockers.push({
            type: 'member_approval',
            message: 'No authorized signatories found for this entity'
        });
    }
    // 3. Get member KYC status
    // We need to check investor_members table since kyc_submissions.investor_member_id
    // references investor_members.id (not user_id from investor_users)
    // Get investor_members to map user emails to member IDs
    const { data: investorMembers } = await supabase.from('investor_members').select('id, email, kyc_status, is_signatory, can_sign').eq('investor_id', entityId).eq('is_active', true);
    // Create email -> member mapping for lookup
    const emailToMember = new Map();
    for (const im of investorMembers || []){
        if (im.email) {
            emailToMember.set(im.email.toLowerCase(), {
                id: im.id,
                kyc_status: im.kyc_status
            });
        }
    }
    // Get member IDs for KYC submission lookup (mapped via email)
    const memberIdsByEmail = [];
    for (const m of signatoriesToCheck){
        const profile = m.profiles;
        if (profile?.email) {
            const member = emailToMember.get(profile.email.toLowerCase());
            if (member) memberIdsByEmail.push(member.id);
        }
    }
    // Query KYC submissions with correct member IDs
    const { data: kycSubmissions } = await supabase.from('kyc_submissions').select('investor_member_id, status').eq('investor_id', entityId).in('investor_member_id', memberIdsByEmail).eq('status', 'approved');
    // Build a set of members with approved KYC (by member_id)
    const memberIdsWithApprovedKycSubmission = new Set(kycSubmissions?.map((k)=>k.investor_member_id) || []);
    // Check each signatory
    for (const member of signatoriesToCheck){
        const profile = member.profiles;
        const memberName = profile?.display_name || profile?.email || 'Unknown member';
        // Get the investor_member record for this user (via email)
        const investorMember = profile?.email ? emailToMember.get(profile.email.toLowerCase()) : null;
        // Check KYC: either has approved kyc_status OR has approved kyc_submission
        const hasApprovedKycStatus = investorMember?.kyc_status?.toLowerCase() === 'approved' || investorMember?.kyc_status?.toLowerCase() === 'completed';
        const hasApprovedKycSubmission = investorMember ? memberIdsWithApprovedKycSubmission.has(investorMember.id) : false;
        const hasApprovedKyc = hasApprovedKycStatus || hasApprovedKycSubmission;
        // Check CEO approval status
        if (member.ceo_approval_status !== 'approved') {
            blockers.push({
                type: 'member_approval',
                message: `Member "${memberName}" is not CEO-approved`,
                details: {
                    member_name: memberName,
                    member_id: member.user_id,
                    status: member.ceo_approval_status || 'pending'
                }
            });
        }
        // Check individual KYC status via kyc_submissions
        if (!hasApprovedKyc) {
            blockers.push({
                type: 'member_kyc',
                message: `Member "${memberName}" KYC is not approved`,
                details: {
                    member_name: memberName,
                    member_id: member.user_id,
                    status: 'not_approved'
                }
            });
        }
        // Count approved signatories
        if (member.ceo_approval_status === 'approved' && hasApprovedKyc) {
            approvedSignatoryCount++;
        }
    }
    return {
        canInvest: blockers.length === 0,
        blockers,
        entityKycStatus,
        signatoryCount: signatoriesToCheck.length,
        approvedSignatoryCount
    };
}
function getEligibilityBlockersSummary(blockers) {
    if (blockers.length === 0) return 'Entity is eligible to invest';
    const entityKycBlockers = blockers.filter((b)=>b.type === 'entity_kyc');
    const memberKycBlockers = blockers.filter((b)=>b.type === 'member_kyc');
    const memberApprovalBlockers = blockers.filter((b)=>b.type === 'member_approval');
    const parts = [];
    if (entityKycBlockers.length > 0) {
        parts.push('Entity KYC not approved');
    }
    if (memberApprovalBlockers.length > 0) {
        const count = memberApprovalBlockers.length;
        parts.push(`${count} member${count > 1 ? 's' : ''} not CEO-approved`);
    }
    if (memberKycBlockers.length > 0) {
        const count = memberKycBlockers.length;
        parts.push(`${count} member${count > 1 ? 's' : ''} with incomplete KYC`);
    }
    return parts.join(', ');
}
}),
"[project]/versotech-portal/src/app/api/deals/[id]/subscriptions/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GET",
    ()=>GET,
    "POST",
    ()=>POST
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/versotech-portal/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__ = __turbopack_context__.i("[project]/versotech-portal/node_modules/zod/v4/classic/external.js [app-route] (ecmascript) <export * as z>");
var __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$src$2f$lib$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/versotech-portal/src/lib/supabase/server.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$src$2f$lib$2f$audit$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/versotech-portal/src/lib/audit.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$src$2f$lib$2f$analytics$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/versotech-portal/src/lib/analytics.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$src$2f$lib$2f$entities$2f$entity$2d$investment$2d$eligibility$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/versotech-portal/src/lib/entities/entity-investment-eligibility.ts [app-route] (ecmascript)");
;
;
;
;
;
;
const submissionSchema = __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    investor_id: __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().uuid().optional(),
    payload: __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(), __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any()).optional().default({}),
    notes: __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().max(4000).optional().nullable(),
    subscription_type: __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].enum([
        'personal',
        'entity'
    ]).optional(),
    counterparty_entity_id: __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().uuid().optional().nullable()
});
async function GET(request, { params }) {
    const { id: dealId } = await params;
    const supabase = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$src$2f$lib$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
    const serviceSupabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$src$2f$lib$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createServiceClient"])();
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Unauthorized'
        }, {
            status: 401
        });
    }
    const { data: profile } = await supabase.from('profiles').select('role').eq('id', user.id).single();
    const isStaff = profile?.role?.startsWith('staff_') || profile?.role === 'ceo';
    const { data: investorLinks } = await supabase.from('investor_users').select('investor_id').eq('user_id', user.id);
    const investorIds = investorLinks?.map((link)=>link.investor_id) ?? [];
    if (!isStaff && investorIds.length === 0) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'No investor profile associated with this account'
        }, {
            status: 403
        });
    }
    const query = serviceSupabase.from('deal_subscription_submissions').select(`
        *,
        investors (
          id,
          legal_name
        ),
        documents!subscription_submission_id (
          id,
          name,
          type,
          status,
          file_key,
          mime_type,
          file_size_bytes,
          created_at,
          created_by
        )
      `).eq('deal_id', dealId).order('submitted_at', {
        ascending: false
    });
    if (!isStaff) {
        query.in('investor_id', investorIds);
    }
    const { data, error } = await query;
    if (error) {
        console.error('Failed to fetch subscription submissions:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Failed to fetch submissions'
        }, {
            status: 500
        });
    }
    // Enrich each submission with pack status derived from documents
    const enrichedSubmissions = (data ?? []).map((submission)=>{
        const documents = submission.documents || [];
        let packStatus = 'no_pack';
        let packDocumentId;
        if (documents.length > 0) {
            // Sort by created_at DESC to get most recent document
            const sortedDocs = [
                ...documents
            ].sort((a, b)=>new Date(b.created_at).getTime() - new Date(a.created_at).getTime());
            const latestDoc = sortedDocs[0];
            packDocumentId = latestDoc.id;
            // Determine pack status based on document status
            if (latestDoc.status === 'signed' || latestDoc.status === 'executed') {
                packStatus = 'signed';
            } else if (latestDoc.status === 'pending_signature' || latestDoc.status === 'awaiting_signature') {
                packStatus = 'pending_signature';
            } else if (latestDoc.status === 'final') {
                packStatus = 'final';
            } else if (latestDoc.status === 'draft') {
                packStatus = 'draft';
            }
        }
        return {
            ...submission,
            pack_status: packStatus,
            pack_document_id: packDocumentId,
            document_count: documents.length,
            subscription_id: submission.formal_subscription_id || null
        };
    });
    return __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
        submissions: enrichedSubmissions
    });
}
async function POST(request, { params }) {
    const { id: dealId } = await params;
    const supabase = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$src$2f$lib$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
    const serviceSupabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$src$2f$lib$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createServiceClient"])();
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Unauthorized'
        }, {
            status: 401
        });
    }
    const body = await request.json().catch(()=>null);
    const parsed = submissionSchema.safeParse(body ?? {});
    if (!parsed.success) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Invalid request data',
            details: parsed.error.errors
        }, {
            status: 400
        });
    }
    const { investor_id, payload, notes, subscription_type, counterparty_entity_id } = parsed.data;
    // Validate entity selection
    if (subscription_type === 'entity' && !counterparty_entity_id) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Counterparty entity ID is required when subscription type is "entity"'
        }, {
            status: 400
        });
    }
    const { data: profile } = await supabase.from('profiles').select('role, display_name').eq('id', user.id).single();
    const isStaff = profile?.role?.startsWith('staff_') || profile?.role === 'ceo';
    const { data: investorLinks } = await supabase.from('investor_users').select('investor_id').eq('user_id', user.id);
    const investorIds = investorLinks?.map((link)=>link.investor_id) ?? [];
    if (!isStaff && investorIds.length === 0) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'No investor profile associated with this account'
        }, {
            status: 403
        });
    }
    const resolvedInvestorId = investor_id ?? investorIds[0];
    if (investor_id && !isStaff && !investorIds.includes(investor_id)) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Not authorized to submit for the specified investor'
        }, {
            status: 403
        });
    }
    if (!resolvedInvestorId) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Investor ID is required'
        }, {
            status: 400
        });
    }
    // Validate counterparty entity ownership if provided
    if (counterparty_entity_id) {
        const { data: entity, error: entityError } = await serviceSupabase.from('investor_counterparty').select('id').eq('id', counterparty_entity_id).eq('investor_id', resolvedInvestorId).eq('is_active', true).maybeSingle();
        if (entityError || !entity) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Invalid counterparty entity or entity does not belong to this investor'
            }, {
                status: 403
            });
        }
    }
    // Entity Investment Eligibility Gate
    // Check if the investor entity meets all requirements:
    // 1. Entity KYC must be approved
    // 2. All signatory members must be CEO-approved with completed KYC
    const eligibility = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$src$2f$lib$2f$entities$2f$entity$2d$investment$2d$eligibility$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["canEntityInvest"])(serviceSupabase, resolvedInvestorId, 'investor');
    if (!eligibility.canInvest) {
        const summary = (0, __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$src$2f$lib$2f$entities$2f$entity$2d$investment$2d$eligibility$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getEligibilityBlockersSummary"])(eligibility.blockers);
        console.log('[Subscription] Entity not eligible to invest:', {
            investor_id: resolvedInvestorId,
            blockers: eligibility.blockers
        });
        return __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'This entity is not eligible to invest at this time',
            eligibility_error: true,
            blockers: eligibility.blockers,
            summary: summary,
            details: `Unable to submit subscription: ${summary}. Please ensure all KYC requirements are met and signatory members are approved.`
        }, {
            status: 403
        });
    }
    // Note: Data room access check removed - investors can now subscribe directly
    // without requiring data room access first (per client request Dec 2025)
    // Auto-cancel any existing pending submissions before creating new one
    // This prevents duplicate pending submissions and maintains clean workflow state
    await serviceSupabase.from('deal_subscription_submissions').update({
        status: 'cancelled'
    }).eq('deal_id', dealId).eq('investor_id', resolvedInvestorId).eq('status', 'pending_review');
    const { data: submission, error: insertError } = await serviceSupabase.from('deal_subscription_submissions').insert({
        deal_id: dealId,
        investor_id: resolvedInvestorId,
        payload_json: payload ?? {},
        status: 'pending_review',
        created_by: user.id,
        subscription_type: subscription_type || 'personal',
        counterparty_entity_id: counterparty_entity_id || null
    }).select(`
        *,
        investors (
          id,
          legal_name
        )
      `).single();
    if (insertError || !submission) {
        console.error('Failed to create subscription submission:', insertError);
        return __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Failed to submit subscription'
        }, {
            status: 500
        });
    }
    await (0, __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$src$2f$lib$2f$analytics$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["trackDealEvent"])({
        supabase: serviceSupabase,
        dealId,
        investorId: resolvedInvestorId,
        eventType: 'data_room_submit',
        payload: {
            submission_id: submission.id,
            amount: payload?.amount ?? payload?.subscription_amount ?? null,
            currency: payload?.currency ?? null
        }
    });
    await __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$src$2f$lib$2f$audit$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["auditLogger"].log({
        actor_user_id: user.id,
        action: __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$src$2f$lib$2f$audit$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AuditActions"].CREATE,
        entity: __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$src$2f$lib$2f$audit$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AuditEntities"].DEALS,
        entity_id: submission.id,
        metadata: {
            type: 'subscription_submission',
            deal_id: dealId,
            investor_id: resolvedInvestorId,
            notes,
            payload
        }
    });
    // NOTE: Approval is automatically created by database trigger 'create_deal_subscription_approval'
    // when status = 'pending_review'. See migration 20251102093000_deal_workflow_phase1_finish.sql
    return __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
        success: true,
        submission
    });
}
}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__9054c1d0._.js.map