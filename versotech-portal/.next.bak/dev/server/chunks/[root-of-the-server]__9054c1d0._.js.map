{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 82, "column": 0}, "map": {"version":3,"sources":["file:///Users/ghilesmoussaoui/Desktop/Versotech/versotech-portal/src/lib/supabase/server.ts"],"sourcesContent":["import { createServerClient } from '@supabase/ssr'\nimport { createClient as createSupabaseClient } from '@supabase/supabase-js'\nimport { cookies } from 'next/headers'\n\nexport const createClient = async () => {\n  const cookieStore = await cookies()\n\n  return createServerClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n    {\n      cookies: {\n        getAll() {\n          return cookieStore.getAll()\n        },\n        setAll(cookiesToSet) {\n          try {\n            cookiesToSet.forEach(({ name, value, options }) => {\n              cookieStore.set(name, value, options)\n            })\n          } catch (error) {\n            // The `setAll` method was called from a Server Component.\n            // This can be ignored if you have middleware refreshing\n            // user sessions.\n          }\n        },\n      },\n    }\n  )\n}\n\n// Server client with service role for admin operations\n// Uses raw supabase-js client which properly bypasses RLS with service role\nexport const createServiceClient = () => {\n  return createSupabaseClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.SUPABASE_SERVICE_ROLE_KEY!,\n    {\n      auth: {\n        autoRefreshToken: false,\n        persistSession: false,\n      },\n    }\n  )\n}\n"],"names":[],"mappings":";;;;;;AAAA;AAAA;AACA;AACA;;;;AAEO,MAAM,eAAe;IAC1B,MAAM,cAAc,MAAM,IAAA,mKAAO;IAEjC,OAAO,IAAA,wNAAkB,sUAGvB;QACE,SAAS;YACP;gBACE,OAAO,YAAY,MAAM;YAC3B;YACA,QAAO,YAAY;gBACjB,IAAI;oBACF,aAAa,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE;wBAC5C,YAAY,GAAG,CAAC,MAAM,OAAO;oBAC/B;gBACF,EAAE,OAAO,OAAO;gBACd,0DAA0D;gBAC1D,wDAAwD;gBACxD,iBAAiB;gBACnB;YACF;QACF;IACF;AAEJ;AAIO,MAAM,sBAAsB;IACjC,OAAO,IAAA,gOAAoB,gFAEzB,QAAQ,GAAG,CAAC,yBAAyB,EACrC;QACE,MAAM;YACJ,kBAAkB;YAClB,gBAAgB;QAClB;IACF;AAEJ"}},
    {"offset": {"line": 128, "column": 0}, "map": {"version":3,"sources":["file:///Users/ghilesmoussaoui/Desktop/Versotech/versotech-portal/src/lib/audit.ts"],"sourcesContent":["import { createClient } from './supabase/server'\r\n\r\nexport interface AuditLogEntry {\r\n  actor_user_id?: string\r\n  action: string\r\n  entity: string\r\n  entity_id?: string\r\n  metadata?: Record<string, any>\r\n}\r\n\r\nclass AuditLogger {\r\n  private static instance: AuditLogger\r\n\r\n  static getInstance(): AuditLogger {\r\n    if (!AuditLogger.instance) {\r\n      AuditLogger.instance = new AuditLogger()\r\n    }\r\n    return AuditLogger.instance\r\n  }\r\n\r\n  async log(entry: AuditLogEntry): Promise<void> {\r\n    try {\r\n      const supabase = await createClient()\r\n\r\n      // Insert into audit_logs with correct column names\r\n      await supabase.from('audit_logs').insert({\r\n        event_type: 'system',\r\n        actor_id: entry.actor_user_id || null,\r\n        action: entry.action,\r\n        entity_type: entry.entity,\r\n        entity_id: entry.entity_id || null,\r\n        action_details: entry.metadata || null,\r\n        timestamp: new Date().toISOString()\r\n      })\r\n\r\n    } catch (error) {\r\n      console.error('Audit logging failed:', error)\r\n      // Don't throw to avoid breaking the main operation\r\n    }\r\n  }\r\n\r\n  async logMany(entries: AuditLogEntry[]): Promise<void> {\r\n    for (const entry of entries) {\r\n      await this.log(entry)\r\n    }\r\n  }\r\n}\r\n\r\nexport const auditLogger = AuditLogger.getInstance()\r\n\r\n// Common audit actions as constants\r\nexport const AuditActions = {\r\n  // Authentication\r\n  LOGIN: 'login',\r\n  LOGOUT: 'logout',\r\n  PASSWORD_CHANGE: 'password_change',\r\n\r\n  // Data operations\r\n  CREATE: 'create',\r\n  READ: 'read', \r\n  UPDATE: 'update',\r\n  DELETE: 'delete',\r\n\r\n  // Documents\r\n  DOCUMENT_UPLOAD: 'document_upload',\r\n  DOCUMENT_DOWNLOAD: 'document_download',\r\n  DOCUMENT_DELETE: 'document_delete',\r\n\r\n  // Workflows\r\n  WORKFLOW_TRIGGER: 'workflow_trigger',\r\n  WORKFLOW_COMPLETED: 'workflow_completed',\r\n  WORKFLOW_FAILED: 'workflow_failed',\r\n\r\n  // System operations\r\n  USER_CREATED: 'user_created',\r\n  PROFILE_UPDATED: 'profile_updated',\r\n  ROLE_CHANGED: 'role_changed',\r\n\r\n  // Business operations\r\n  SUBSCRIPTION_CREATED: 'subscription_created',\r\n  CAPITAL_CALL_CREATED: 'capital_call_created',\r\n  DISTRIBUTION_CREATED: 'distribution_created',\r\n  REPORT_REQUESTED: 'report_requested',\r\n  MESSAGE_SENT: 'message_sent',\r\n\r\n  // Commission lifecycle (GAP-7)\r\n  COMMISSION_CREATED: 'commission_created',\r\n  COMMISSION_ACCRUED: 'commission_accrued',\r\n  COMMISSION_INVOICE_REQUESTED: 'commission_invoice_requested',\r\n  COMMISSION_INVOICED: 'commission_invoiced',\r\n  COMMISSION_PAID: 'commission_paid',\r\n  COMMISSION_CANCELLED: 'commission_cancelled',\r\n\r\n  // Agreement events (GAP-8)\r\n  AGREEMENT_CREATED: 'agreement_created',\r\n  AGREEMENT_SENT: 'agreement_sent',\r\n  AGREEMENT_APPROVED: 'agreement_approved',\r\n  AGREEMENT_SIGNED: 'agreement_signed',\r\n  AGREEMENT_ACTIVATED: 'agreement_activated',\r\n  AGREEMENT_REJECTED: 'agreement_rejected',\r\n  AGREEMENT_EXPIRED: 'agreement_expired'\r\n} as const\r\n\r\n// Entity types\r\nexport const AuditEntities = {\r\n  USERS: 'users',\r\n  PROFILES: 'profiles',\r\n  INVESTORS: 'investors',\r\n  VEHICLES: 'vehicles',\r\n  SUBSCRIPTIONS: 'subscriptions',\r\n  POSITIONS: 'positions',\r\n  DOCUMENTS: 'documents',\r\n  WORKFLOWS: 'workflows',\r\n  WORKFLOW_RUNS: 'workflow_runs',\r\n  CONVERSATIONS: 'conversations',\r\n  MESSAGES: 'messages',\r\n  REQUEST_TICKETS: 'request_tickets',\r\n  CAPITAL_CALLS: 'capital_calls',\r\n  DISTRIBUTIONS: 'distributions',\r\n  DEALS: 'deals',\r\n  // RESERVATIONS: 'reservations', // Deprecated - removed from workflow\r\n  ALLOCATIONS: 'allocations',\r\n  FEE_EVENTS: 'fee_events',\r\n  INVOICES: 'invoices',\r\n  BANK_TRANSACTIONS: 'bank_transactions',\r\n  PAYMENTS: 'payments',\r\n  ARRANGER: 'arranger_entities',\r\n  INTRODUCER: 'introducers',\r\n  PARTNER: 'partners',\r\n  COMMERCIAL_PARTNER: 'commercial_partners',\r\n  FEE_PLANS: 'arranger_fee_plans',\r\n  CEO_ENTITY: 'ceo_entity',\r\n  CEO_USERS: 'ceo_users',\r\n  // Commission entities (GAP-7)\r\n  INTRODUCER_COMMISSIONS: 'introducer_commissions',\r\n  PARTNER_COMMISSIONS: 'partner_commissions',\r\n  COMMERCIAL_PARTNER_COMMISSIONS: 'commercial_partner_commissions',\r\n  // Agreement entities (GAP-8)\r\n  INTRODUCER_AGREEMENTS: 'introducer_agreements',\r\n  PARTNER_AGREEMENTS: 'partner_agreements',\r\n  COMMERCIAL_PARTNER_AGREEMENTS: 'commercial_partner_agreements',\r\n  // Introductions\r\n  INTRODUCTIONS: 'introductions',\r\n} as const\r\n\r\n"],"names":[],"mappings":";;;;;;;;AAAA;;AAUA,MAAM;IACJ,OAAe,SAAqB;IAEpC,OAAO,cAA2B;QAChC,IAAI,CAAC,YAAY,QAAQ,EAAE;YACzB,YAAY,QAAQ,GAAG,IAAI;QAC7B;QACA,OAAO,YAAY,QAAQ;IAC7B;IAEA,MAAM,IAAI,KAAoB,EAAiB;QAC7C,IAAI;YACF,MAAM,WAAW,MAAM,IAAA,yKAAY;YAEnC,mDAAmD;YACnD,MAAM,SAAS,IAAI,CAAC,cAAc,MAAM,CAAC;gBACvC,YAAY;gBACZ,UAAU,MAAM,aAAa,IAAI;gBACjC,QAAQ,MAAM,MAAM;gBACpB,aAAa,MAAM,MAAM;gBACzB,WAAW,MAAM,SAAS,IAAI;gBAC9B,gBAAgB,MAAM,QAAQ,IAAI;gBAClC,WAAW,IAAI,OAAO,WAAW;YACnC;QAEF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,yBAAyB;QACvC,mDAAmD;QACrD;IACF;IAEA,MAAM,QAAQ,OAAwB,EAAiB;QACrD,KAAK,MAAM,SAAS,QAAS;YAC3B,MAAM,IAAI,CAAC,GAAG,CAAC;QACjB;IACF;AACF;AAEO,MAAM,cAAc,YAAY,WAAW;AAG3C,MAAM,eAAe;IAC1B,iBAAiB;IACjB,OAAO;IACP,QAAQ;IACR,iBAAiB;IAEjB,kBAAkB;IAClB,QAAQ;IACR,MAAM;IACN,QAAQ;IACR,QAAQ;IAER,YAAY;IACZ,iBAAiB;IACjB,mBAAmB;IACnB,iBAAiB;IAEjB,YAAY;IACZ,kBAAkB;IAClB,oBAAoB;IACpB,iBAAiB;IAEjB,oBAAoB;IACpB,cAAc;IACd,iBAAiB;IACjB,cAAc;IAEd,sBAAsB;IACtB,sBAAsB;IACtB,sBAAsB;IACtB,sBAAsB;IACtB,kBAAkB;IAClB,cAAc;IAEd,+BAA+B;IAC/B,oBAAoB;IACpB,oBAAoB;IACpB,8BAA8B;IAC9B,qBAAqB;IACrB,iBAAiB;IACjB,sBAAsB;IAEtB,2BAA2B;IAC3B,mBAAmB;IACnB,gBAAgB;IAChB,oBAAoB;IACpB,kBAAkB;IAClB,qBAAqB;IACrB,oBAAoB;IACpB,mBAAmB;AACrB;AAGO,MAAM,gBAAgB;IAC3B,OAAO;IACP,UAAU;IACV,WAAW;IACX,UAAU;IACV,eAAe;IACf,WAAW;IACX,WAAW;IACX,WAAW;IACX,eAAe;IACf,eAAe;IACf,UAAU;IACV,iBAAiB;IACjB,eAAe;IACf,eAAe;IACf,OAAO;IACP,sEAAsE;IACtE,aAAa;IACb,YAAY;IACZ,UAAU;IACV,mBAAmB;IACnB,UAAU;IACV,UAAU;IACV,YAAY;IACZ,SAAS;IACT,oBAAoB;IACpB,WAAW;IACX,YAAY;IACZ,WAAW;IACX,8BAA8B;IAC9B,wBAAwB;IACxB,qBAAqB;IACrB,gCAAgC;IAChC,6BAA6B;IAC7B,uBAAuB;IACvB,oBAAoB;IACpB,+BAA+B;IAC/B,gBAAgB;IAChB,eAAe;AACjB"}},
    {"offset": {"line": 259, "column": 0}, "map": {"version":3,"sources":["file:///Users/ghilesmoussaoui/Desktop/Versotech/versotech-portal/src/lib/analytics.ts"],"sourcesContent":["import type { SupabaseClient } from '@supabase/supabase-js'\n\nexport type DealAnalyticsEvent =\n  | 'im_interested'\n  | 'closed_deal_interest'\n  | 'data_room_submit'\n  | 'deal_interest_approved'\n  | 'deal_subscription_approved'\n  | 'nda_completed'\n  | 'subscription_completed'\n  | 'deal_interest_submitted'\n\ninterface TrackDealEventInput {\n  supabase: SupabaseClient\n  dealId: string\n  eventType: DealAnalyticsEvent\n  investorId?: string | null\n  payload?: Record<string, unknown>\n}\n\n/**\n * Stores analytics / telemetry events for deal workflow milestones.\n * Wraps the shared insert logic so event names stay consistent.\n */\nexport async function trackDealEvent({\n  supabase,\n  dealId,\n  eventType,\n  investorId,\n  payload\n}: TrackDealEventInput) {\n  try {\n    await supabase.from('deal_activity_events').insert({\n      deal_id: dealId,\n      investor_id: investorId ?? null,\n      event_type: eventType,\n      payload: payload ?? {},\n      occurred_at: new Date().toISOString()\n    })\n  } catch (error) {\n    console.error('Failed to track deal analytics event', { eventType, dealId, error })\n  }\n}\n"],"names":[],"mappings":";;;;AAwBO,eAAe,eAAe,EACnC,QAAQ,EACR,MAAM,EACN,SAAS,EACT,UAAU,EACV,OAAO,EACa;IACpB,IAAI;QACF,MAAM,SAAS,IAAI,CAAC,wBAAwB,MAAM,CAAC;YACjD,SAAS;YACT,aAAa,cAAc;YAC3B,YAAY;YACZ,SAAS,WAAW,CAAC;YACrB,aAAa,IAAI,OAAO,WAAW;QACrC;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,wCAAwC;YAAE;YAAW;YAAQ;QAAM;IACnF;AACF"}},
    {"offset": {"line": 284, "column": 0}, "map": {"version":3,"sources":["file:///Users/ghilesmoussaoui/Desktop/Versotech/versotech-portal/src/lib/entities/entity-investment-eligibility.ts"],"sourcesContent":["/**\n * Entity Investment Eligibility Check\n *\n * Determines if an entity can invest based on:\n * 1. Entity KYC status (must be approved/completed)\n * 2. All signatory members must have:\n *    - CEO approval (ceo_approval_status = 'approved')\n *    - Individual KYC approved (kyc_status = 'approved' or 'completed')\n */\n\nimport { SupabaseClient } from '@supabase/supabase-js'\n\nexport interface EligibilityBlocker {\n  type: 'entity_kyc' | 'member_kyc' | 'member_approval'\n  message: string\n  details?: {\n    member_name?: string\n    member_id?: string\n    status?: string\n  }\n}\n\nexport interface EntityInvestmentEligibility {\n  canInvest: boolean\n  blockers: EligibilityBlocker[]\n  entityKycStatus?: string\n  signatoryCount: number\n  approvedSignatoryCount: number\n}\n\n// Entity type to table mapping\nconst ENTITY_TABLES: Record<string, string> = {\n  investor: 'investors',\n  partner: 'partners',\n  introducer: 'introducers',\n  commercial_partner: 'commercial_partners',\n  lawyer: 'lawyers',\n  arranger: 'arranger_entities'\n}\n\n// User junction table mapping\nconst USER_TABLES: Record<string, string> = {\n  investor: 'investor_users',\n  partner: 'partner_users',\n  introducer: 'introducer_users',\n  commercial_partner: 'commercial_partner_users',\n  lawyer: 'lawyer_users',\n  arranger: 'arranger_users'\n}\n\n// Entity ID column in junction tables\nconst ENTITY_ID_COLUMNS: Record<string, string> = {\n  investor: 'investor_id',\n  partner: 'partner_id',\n  introducer: 'introducer_id',\n  commercial_partner: 'commercial_partner_id',\n  lawyer: 'lawyer_id',\n  arranger: 'arranger_id'\n}\n\n/**\n * Check if an entity can invest based on KYC and member approval requirements\n *\n * @param supabase - Supabase client (service client recommended for full access)\n * @param entityId - The ID of the entity\n * @param entityType - The type of entity (investor, partner, etc.)\n * @returns Eligibility result with blockers if any\n */\nexport async function canEntityInvest(\n  supabase: SupabaseClient,\n  entityId: string,\n  entityType: string\n): Promise<EntityInvestmentEligibility> {\n  const blockers: EligibilityBlocker[] = []\n  let entityKycStatus: string | undefined\n  let signatoryCount = 0\n  let approvedSignatoryCount = 0\n\n  // Validate entity type\n  const entityTable = ENTITY_TABLES[entityType]\n  const userTable = USER_TABLES[entityType]\n  const entityIdColumn = ENTITY_ID_COLUMNS[entityType]\n\n  if (!entityTable || !userTable || !entityIdColumn) {\n    return {\n      canInvest: false,\n      blockers: [{\n        type: 'entity_kyc',\n        message: `Unknown entity type: ${entityType}`\n      }],\n      signatoryCount: 0,\n      approvedSignatoryCount: 0\n    }\n  }\n\n  // 1. Check entity KYC status\n  const { data: entity, error: entityError } = await supabase\n    .from(entityTable)\n    .select('id, kyc_status')\n    .eq('id', entityId)\n    .single()\n\n  if (entityError || !entity) {\n    return {\n      canInvest: false,\n      blockers: [{\n        type: 'entity_kyc',\n        message: 'Entity not found'\n      }],\n      signatoryCount: 0,\n      approvedSignatoryCount: 0\n    }\n  }\n\n  entityKycStatus = entity.kyc_status\n\n  // Entity KYC must be approved or completed\n  const validEntityKycStatuses = ['approved', 'completed', 'verified']\n  if (!entity.kyc_status || !validEntityKycStatuses.includes(entity.kyc_status.toLowerCase())) {\n    blockers.push({\n      type: 'entity_kyc',\n      message: `Entity KYC is ${entity.kyc_status || 'not started'}. KYC must be approved before investing.`,\n      details: {\n        status: entity.kyc_status\n      }\n    })\n  }\n\n  // 2. Get all signatory members and check their CEO approval status\n  // We need to check members where can_sign = true OR is_signatory = true\n  const { data: members, error: membersError } = await supabase\n    .from(userTable)\n    .select(`\n      user_id,\n      role,\n      can_sign,\n      ceo_approval_status,\n      ceo_approved_at,\n      profiles:user_id(\n        id,\n        display_name,\n        email\n      )\n    `)\n    .eq(entityIdColumn, entityId)\n    .or('can_sign.eq.true,role.eq.admin,role.eq.owner')  // Check signatories\n\n  if (membersError) {\n    console.error('Error fetching members:', membersError)\n    return {\n      canInvest: false,\n      blockers: [{\n        type: 'member_approval',\n        message: 'Failed to verify member status'\n      }],\n      entityKycStatus,\n      signatoryCount: 0,\n      approvedSignatoryCount: 0\n    }\n  }\n\n  // Filter to actual signatories (can_sign = true)\n  const signatories = members?.filter(m => m.can_sign === true) || []\n  signatoryCount = signatories.length\n\n  // If no explicit signatories, check admin/owner members\n  const signatoriesToCheck = signatoryCount > 0\n    ? signatories\n    : (members?.filter(m => ['admin', 'owner'].includes(m.role)) || [])\n\n  if (signatoriesToCheck.length === 0) {\n    blockers.push({\n      type: 'member_approval',\n      message: 'No authorized signatories found for this entity'\n    })\n  }\n\n  // 3. Get member KYC status\n  // We need to check investor_members table since kyc_submissions.investor_member_id\n  // references investor_members.id (not user_id from investor_users)\n\n  // Get investor_members to map user emails to member IDs\n  const { data: investorMembers } = await supabase\n    .from('investor_members')\n    .select('id, email, kyc_status, is_signatory, can_sign')\n    .eq('investor_id', entityId)\n    .eq('is_active', true)\n\n  // Create email -> member mapping for lookup\n  const emailToMember = new Map<string, { id: string; kyc_status: string | null }>()\n  for (const im of investorMembers || []) {\n    if (im.email) {\n      emailToMember.set(im.email.toLowerCase(), { id: im.id, kyc_status: im.kyc_status })\n    }\n  }\n\n  // Get member IDs for KYC submission lookup (mapped via email)\n  const memberIdsByEmail: string[] = []\n  for (const m of signatoriesToCheck) {\n    const profile = m.profiles as unknown as { email?: string } | null\n    if (profile?.email) {\n      const member = emailToMember.get(profile.email.toLowerCase())\n      if (member) memberIdsByEmail.push(member.id)\n    }\n  }\n\n  // Query KYC submissions with correct member IDs\n  const { data: kycSubmissions } = await supabase\n    .from('kyc_submissions')\n    .select('investor_member_id, status')\n    .eq('investor_id', entityId)\n    .in('investor_member_id', memberIdsByEmail)\n    .eq('status', 'approved')\n\n  // Build a set of members with approved KYC (by member_id)\n  const memberIdsWithApprovedKycSubmission = new Set(\n    kycSubmissions?.map(k => k.investor_member_id) || []\n  )\n\n  // Check each signatory\n  for (const member of signatoriesToCheck) {\n    const profile = member.profiles as unknown as {\n      id: string\n      display_name?: string\n      email?: string\n    } | null\n\n    const memberName = profile?.display_name || profile?.email || 'Unknown member'\n\n    // Get the investor_member record for this user (via email)\n    const investorMember = profile?.email\n      ? emailToMember.get(profile.email.toLowerCase())\n      : null\n\n    // Check KYC: either has approved kyc_status OR has approved kyc_submission\n    const hasApprovedKycStatus = investorMember?.kyc_status?.toLowerCase() === 'approved' ||\n                                  investorMember?.kyc_status?.toLowerCase() === 'completed'\n    const hasApprovedKycSubmission = investorMember\n      ? memberIdsWithApprovedKycSubmission.has(investorMember.id)\n      : false\n    const hasApprovedKyc = hasApprovedKycStatus || hasApprovedKycSubmission\n\n    // Check CEO approval status\n    if (member.ceo_approval_status !== 'approved') {\n      blockers.push({\n        type: 'member_approval',\n        message: `Member \"${memberName}\" is not CEO-approved`,\n        details: {\n          member_name: memberName,\n          member_id: member.user_id,\n          status: member.ceo_approval_status || 'pending'\n        }\n      })\n    }\n\n    // Check individual KYC status via kyc_submissions\n    if (!hasApprovedKyc) {\n      blockers.push({\n        type: 'member_kyc',\n        message: `Member \"${memberName}\" KYC is not approved`,\n        details: {\n          member_name: memberName,\n          member_id: member.user_id,\n          status: 'not_approved'\n        }\n      })\n    }\n\n    // Count approved signatories\n    if (member.ceo_approval_status === 'approved' && hasApprovedKyc) {\n      approvedSignatoryCount++\n    }\n  }\n\n  return {\n    canInvest: blockers.length === 0,\n    blockers,\n    entityKycStatus,\n    signatoryCount: signatoriesToCheck.length,\n    approvedSignatoryCount\n  }\n}\n\n/**\n * Get a human-readable summary of eligibility blockers\n */\nexport function getEligibilityBlockersSummary(blockers: EligibilityBlocker[]): string {\n  if (blockers.length === 0) return 'Entity is eligible to invest'\n\n  const entityKycBlockers = blockers.filter(b => b.type === 'entity_kyc')\n  const memberKycBlockers = blockers.filter(b => b.type === 'member_kyc')\n  const memberApprovalBlockers = blockers.filter(b => b.type === 'member_approval')\n\n  const parts: string[] = []\n\n  if (entityKycBlockers.length > 0) {\n    parts.push('Entity KYC not approved')\n  }\n\n  if (memberApprovalBlockers.length > 0) {\n    const count = memberApprovalBlockers.length\n    parts.push(`${count} member${count > 1 ? 's' : ''} not CEO-approved`)\n  }\n\n  if (memberKycBlockers.length > 0) {\n    const count = memberKycBlockers.length\n    parts.push(`${count} member${count > 1 ? 's' : ''} with incomplete KYC`)\n  }\n\n  return parts.join(', ')\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 520, "column": 0}, "map": {"version":3,"sources":["file:///Users/ghilesmoussaoui/Desktop/Versotech/versotech-portal/src/app/api/deals/%5Bid%5D/subscriptions/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server'\nimport { z } from 'zod'\nimport { createClient, createServiceClient } from '@/lib/supabase/server'\nimport { auditLogger, AuditActions, AuditEntities } from '@/lib/audit'\nimport { trackDealEvent } from '@/lib/analytics'\nimport { canEntityInvest, getEligibilityBlockersSummary } from '@/lib/entities/entity-investment-eligibility'\n\nconst submissionSchema = z.object({\n  investor_id: z.string().uuid().optional(),\n  payload: z.record(z.string(), z.any()).optional().default({}),\n  notes: z.string().max(4000).optional().nullable(),\n  subscription_type: z.enum(['personal', 'entity']).optional(),\n  counterparty_entity_id: z.string().uuid().optional().nullable()\n})\n\nexport async function GET(\n  request: NextRequest,\n  { params }: { params: Promise<{ id: string }> }\n) {\n  const { id: dealId } = await params\n  const supabase = await createClient()\n  const serviceSupabase = createServiceClient()\n\n  const { data: { user }, error: authError } = await supabase.auth.getUser()\n  if (authError || !user) {\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  }\n\n  const { data: profile } = await supabase\n    .from('profiles')\n    .select('role')\n    .eq('id', user.id)\n    .single()\n\n  const isStaff = profile?.role?.startsWith('staff_') || profile?.role === 'ceo'\n\n  const { data: investorLinks } = await supabase\n    .from('investor_users')\n    .select('investor_id')\n    .eq('user_id', user.id)\n\n  const investorIds = investorLinks?.map(link => link.investor_id) ?? []\n\n  if (!isStaff && investorIds.length === 0) {\n    return NextResponse.json(\n      { error: 'No investor profile associated with this account' },\n      { status: 403 }\n    )\n  }\n\n  const query = serviceSupabase\n    .from('deal_subscription_submissions')\n    .select(\n      `\n        *,\n        investors (\n          id,\n          legal_name\n        ),\n        documents!subscription_submission_id (\n          id,\n          name,\n          type,\n          status,\n          file_key,\n          mime_type,\n          file_size_bytes,\n          created_at,\n          created_by\n        )\n      `\n    )\n    .eq('deal_id', dealId)\n    .order('submitted_at', { ascending: false })\n\n  if (!isStaff) {\n    query.in('investor_id', investorIds)\n  }\n\n  const { data, error } = await query\n  if (error) {\n    console.error('Failed to fetch subscription submissions:', error)\n    return NextResponse.json({ error: 'Failed to fetch submissions' }, { status: 500 })\n  }\n\n  // Enrich each submission with pack status derived from documents\n  const enrichedSubmissions = (data ?? []).map((submission: any) => {\n    const documents = submission.documents || []\n    let packStatus: 'no_pack' | 'draft' | 'final' | 'pending_signature' | 'signed' = 'no_pack'\n    let packDocumentId: string | undefined\n\n    if (documents.length > 0) {\n      // Sort by created_at DESC to get most recent document\n      const sortedDocs = [...documents].sort((a, b) =>\n        new Date(b.created_at).getTime() - new Date(a.created_at).getTime()\n      )\n      const latestDoc = sortedDocs[0]\n      packDocumentId = latestDoc.id\n\n      // Determine pack status based on document status\n      if (latestDoc.status === 'signed' || latestDoc.status === 'executed') {\n        packStatus = 'signed'\n      } else if (latestDoc.status === 'pending_signature' || latestDoc.status === 'awaiting_signature') {\n        packStatus = 'pending_signature'\n      } else if (latestDoc.status === 'final') {\n        packStatus = 'final'\n      } else if (latestDoc.status === 'draft') {\n        packStatus = 'draft'\n      }\n    }\n\n    return {\n      ...submission,\n      pack_status: packStatus,\n      pack_document_id: packDocumentId,\n      document_count: documents.length,\n      subscription_id: submission.formal_subscription_id || null\n    }\n  })\n\n  return NextResponse.json({ submissions: enrichedSubmissions })\n}\n\nexport async function POST(\n  request: NextRequest,\n  { params }: { params: Promise<{ id: string }> }\n) {\n  const { id: dealId } = await params\n  const supabase = await createClient()\n  const serviceSupabase = createServiceClient()\n\n  const { data: { user }, error: authError } = await supabase.auth.getUser()\n  if (authError || !user) {\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  }\n\n  const body = await request.json().catch(() => null)\n  const parsed = submissionSchema.safeParse(body ?? {})\n\n  if (!parsed.success) {\n    return NextResponse.json(\n      { error: 'Invalid request data', details: (parsed.error as any).errors },\n      { status: 400 }\n    )\n  }\n\n  const { investor_id, payload, notes, subscription_type, counterparty_entity_id } = parsed.data\n\n  // Validate entity selection\n  if (subscription_type === 'entity' && !counterparty_entity_id) {\n    return NextResponse.json(\n      { error: 'Counterparty entity ID is required when subscription type is \"entity\"' },\n      { status: 400 }\n    )\n  }\n\n  const { data: profile } = await supabase\n    .from('profiles')\n    .select('role, display_name')\n    .eq('id', user.id)\n    .single()\n\n  const isStaff = profile?.role?.startsWith('staff_') || profile?.role === 'ceo'\n\n  const { data: investorLinks } = await supabase\n    .from('investor_users')\n    .select('investor_id')\n    .eq('user_id', user.id)\n\n  const investorIds = investorLinks?.map(link => link.investor_id) ?? []\n\n  if (!isStaff && investorIds.length === 0) {\n    return NextResponse.json(\n      { error: 'No investor profile associated with this account' },\n      { status: 403 }\n    )\n  }\n\n  const resolvedInvestorId = investor_id ?? investorIds[0]\n\n  if (investor_id && !isStaff && !investorIds.includes(investor_id)) {\n    return NextResponse.json(\n      { error: 'Not authorized to submit for the specified investor' },\n      { status: 403 }\n    )\n  }\n\n  if (!resolvedInvestorId) {\n    return NextResponse.json(\n      { error: 'Investor ID is required' },\n      { status: 400 }\n    )\n  }\n\n  // Validate counterparty entity ownership if provided\n  if (counterparty_entity_id) {\n    const { data: entity, error: entityError } = await serviceSupabase\n      .from('investor_counterparty')\n      .select('id')\n      .eq('id', counterparty_entity_id)\n      .eq('investor_id', resolvedInvestorId)\n      .eq('is_active', true)\n      .maybeSingle()\n\n    if (entityError || !entity) {\n      return NextResponse.json(\n        { error: 'Invalid counterparty entity or entity does not belong to this investor' },\n        { status: 403 }\n      )\n    }\n  }\n\n  // Entity Investment Eligibility Gate\n  // Check if the investor entity meets all requirements:\n  // 1. Entity KYC must be approved\n  // 2. All signatory members must be CEO-approved with completed KYC\n  const eligibility = await canEntityInvest(serviceSupabase, resolvedInvestorId, 'investor')\n\n  if (!eligibility.canInvest) {\n    const summary = getEligibilityBlockersSummary(eligibility.blockers)\n    console.log('[Subscription] Entity not eligible to invest:', {\n      investor_id: resolvedInvestorId,\n      blockers: eligibility.blockers\n    })\n\n    return NextResponse.json(\n      {\n        error: 'This entity is not eligible to invest at this time',\n        eligibility_error: true,\n        blockers: eligibility.blockers,\n        summary: summary,\n        details: `Unable to submit subscription: ${summary}. Please ensure all KYC requirements are met and signatory members are approved.`\n      },\n      { status: 403 }\n    )\n  }\n\n  // Note: Data room access check removed - investors can now subscribe directly\n  // without requiring data room access first (per client request Dec 2025)\n\n  // Auto-cancel any existing pending submissions before creating new one\n  // This prevents duplicate pending submissions and maintains clean workflow state\n  await serviceSupabase\n    .from('deal_subscription_submissions')\n    .update({ status: 'cancelled' })\n    .eq('deal_id', dealId)\n    .eq('investor_id', resolvedInvestorId)\n    .eq('status', 'pending_review')\n\n  const { data: submission, error: insertError } = await serviceSupabase\n    .from('deal_subscription_submissions')\n    .insert({\n      deal_id: dealId,\n      investor_id: resolvedInvestorId,\n      payload_json: payload ?? {},\n      status: 'pending_review',\n      created_by: user.id,\n      subscription_type: subscription_type || 'personal',\n      counterparty_entity_id: counterparty_entity_id || null\n    })\n    .select(\n      `\n        *,\n        investors (\n          id,\n          legal_name\n        )\n      `\n    )\n    .single()\n\n  if (insertError || !submission) {\n    console.error('Failed to create subscription submission:', insertError)\n    return NextResponse.json({ error: 'Failed to submit subscription' }, { status: 500 })\n  }\n\n  await trackDealEvent({\n    supabase: serviceSupabase,\n    dealId,\n    investorId: resolvedInvestorId,\n    eventType: 'data_room_submit',\n    payload: {\n      submission_id: submission.id,\n      amount: payload?.amount ?? payload?.subscription_amount ?? null,\n      currency: payload?.currency ?? null\n    }\n  })\n\n  await auditLogger.log({\n    actor_user_id: user.id,\n    action: AuditActions.CREATE,\n    entity: AuditEntities.DEALS,\n    entity_id: submission.id,\n    metadata: {\n      type: 'subscription_submission',\n      deal_id: dealId,\n      investor_id: resolvedInvestorId,\n      notes,\n      payload\n    }\n  })\n\n  // NOTE: Approval is automatically created by database trigger 'create_deal_subscription_approval'\n  // when status = 'pending_review'. See migration 20251102093000_deal_workflow_phase1_finish.sql\n\n  return NextResponse.json({\n    success: true,\n    submission\n  })\n}\n"],"names":[],"mappings":"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"}}]
}