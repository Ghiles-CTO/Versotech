module.exports = [
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/stream [external] (stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}),
"[externals]/http [external] (http, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}),
"[externals]/url [external] (url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}),
"[externals]/punycode [external] (punycode, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("punycode", () => require("punycode"));

module.exports = mod;
}),
"[externals]/https [external] (https, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}),
"[externals]/zlib [external] (zlib, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}),
"[project]/versotech-portal/src/lib/supabase/server.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createClient",
    ()=>createClient,
    "createServiceClient",
    ()=>createServiceClient
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f40$supabase$2f$ssr$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/versotech-portal/node_modules/@supabase/ssr/dist/module/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f40$supabase$2f$ssr$2f$dist$2f$module$2f$createServerClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/versotech-portal/node_modules/@supabase/ssr/dist/module/createServerClient.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/versotech-portal/node_modules/@supabase/supabase-js/dist/module/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/versotech-portal/node_modules/next/headers.js [app-route] (ecmascript)");
;
;
;
const createClient = async ()=>{
    const cookieStore = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["cookies"])();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f40$supabase$2f$ssr$2f$dist$2f$module$2f$createServerClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createServerClient"])(("TURBOPACK compile-time value", "https://ipguxdssecfexudnvtia.supabase.co"), ("TURBOPACK compile-time value", "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImlwZ3V4ZHNzZWNmZXh1ZG52dGlhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgzNjE4MzcsImV4cCI6MjA3MzkzNzgzN30.AGxM_YW9hfxuu7xDpi_4xhOoRhYM7iGTS1vJ0z2FByE"), {
        cookies: {
            getAll () {
                return cookieStore.getAll();
            },
            setAll (cookiesToSet) {
                try {
                    cookiesToSet.forEach(({ name, value, options })=>{
                        cookieStore.set(name, value, options);
                    });
                } catch (error) {
                // The `setAll` method was called from a Server Component.
                // This can be ignored if you have middleware refreshing
                // user sessions.
                }
            }
        }
    });
};
const createServiceClient = ()=>{
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createClient"])(("TURBOPACK compile-time value", "https://ipguxdssecfexudnvtia.supabase.co"), process.env.SUPABASE_SERVICE_ROLE_KEY, {
        auth: {
            autoRefreshToken: false,
            persistSession: false
        }
    });
};
}),
"[project]/versotech-portal/src/app/api/deals/[id]/activity/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GET",
    ()=>GET
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/versotech-portal/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$src$2f$lib$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/versotech-portal/src/lib/supabase/server.ts [app-route] (ecmascript)");
;
;
async function GET(request, { params }) {
    const { id: dealId } = await params;
    const supabase = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$src$2f$lib$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
    const serviceSupabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$src$2f$lib$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createServiceClient"])();
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Unauthorized'
        }, {
            status: 401
        });
    }
    const { data: profile } = await supabase.from('profiles').select('role').eq('id', user.id).single();
    if (!profile || !(profile.role.startsWith('staff_') || profile.role === 'ceo')) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Staff access required'
        }, {
            status: 403
        });
    }
    const since = request.nextUrl.searchParams.get('since') ?? new Date(Date.now() - 90 * 24 * 60 * 60 * 1000).toISOString();
    const limit = parseInt(request.nextUrl.searchParams.get('limit') ?? '50');
    const offset = parseInt(request.nextUrl.searchParams.get('offset') ?? '0');
    try {
        // Fetch deal activity events (conversion events)
        const { data: activityEvents, error: activityError } = await serviceSupabase.from('deal_activity_events').select(`
        id,
        event_type,
        payload,
        occurred_at,
        investor_id,
        investors (
          legal_name,
          display_name
        )
      `).eq('deal_id', dealId).gte('occurred_at', since);
        if (activityError) {
            console.error('Failed to fetch deal activity events', activityError);
            return __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Failed to load activity events',
                details: activityError.message
            }, {
                status: 500
            });
        }
        // Fetch audit logs for this deal
        const { data: auditLogs, error: auditError } = await serviceSupabase.from('audit_logs').select('*').eq('entity_type', 'deals').eq('entity_id', dealId).gte('timestamp', since);
        if (auditError) {
            console.error('Failed to fetch audit logs', auditError);
        }
        // Fetch interest workflow events
        const { data: interests, error: interestsError } = await serviceSupabase.from('investor_deal_interest').select(`
        id,
        submitted_at,
        approved_at,
        updated_at,
        status,
        indicative_amount,
        investor_id,
        investors (
          legal_name,
          display_name
        )
      `).eq('deal_id', dealId).gte('submitted_at', since);
        if (interestsError) {
            console.error('Failed to fetch interests', interestsError);
        }
        // Fetch subscription workflow events
        const { data: subscriptions, error: subscriptionsError } = await serviceSupabase.from('deal_subscription_submissions').select(`
        id,
        submitted_at,
        decided_at,
        status,
        payload_json,
        investor_id,
        investors (
          legal_name,
          display_name
        ),
        decided_by_profile:profiles!deal_subscription_submissions_decided_by_fkey (
          display_name,
          email,
          role
        )
      `).eq('deal_id', dealId).gte('submitted_at', since);
        if (subscriptionsError) {
            console.error('Failed to fetch subscriptions', subscriptionsError);
        }
        // Fetch data room access events
        const { data: dataRoomAccess, error: dataRoomError } = await serviceSupabase.from('deal_data_room_access').select(`
        id,
        granted_at,
        revoked_at,
        auto_granted,
        investor_id,
        investors (
          legal_name,
          display_name
        ),
        granted_by_profile:profiles!deal_data_room_access_granted_by_fkey (
          display_name,
          email,
          role
        ),
        revoked_by_profile:profiles!deal_data_room_access_revoked_by_fkey (
          display_name,
          email,
          role
        )
      `).eq('deal_id', dealId).gte('granted_at', since);
        if (dataRoomError) {
            console.error('Failed to fetch data room access', dataRoomError);
        }
        // Fetch team member events
        const { data: members, error: membersError } = await serviceSupabase.from('deal_memberships').select(`
        id,
        invited_at,
        accepted_at,
        role,
        user_id,
        member_profile:profiles!deal_memberships_user_id_fkey (
          display_name,
          email,
          role
        ),
        invited_by_profile:profiles!deal_memberships_invited_by_fkey (
          display_name,
          email,
          role
        )
      `).eq('deal_id', dealId).gte('invited_at', since);
        if (membersError) {
            console.error('Failed to fetch members', membersError);
        }
        // Combine and format all events
        const allEvents = [];
        // Add activity events (basic conversion events)
        activityEvents?.forEach((event)=>{
            const investor = Array.isArray(event.investors) ? event.investors[0] : event.investors;
            const investorName = investor?.legal_name || investor?.display_name || 'Unknown Investor';
            allEvents.push({
                id: event.id,
                timestamp: event.occurred_at,
                type: event.event_type,
                category: 'conversion',
                actor: {
                    name: investorName,
                    email: null,
                    role: 'investor'
                },
                description: formatActivityEventDescription(event.event_type, investorName),
                details: event.payload
            });
        });
        // Add interest workflow events
        interests?.forEach((interest)=>{
            const investor = Array.isArray(interest.investors) ? interest.investors[0] : interest.investors;
            const investorName = investor?.legal_name || investor?.display_name || 'Unknown Investor';
            // Interest submitted
            if (interest.submitted_at) {
                allEvents.push({
                    id: `interest-submitted-${interest.id}`,
                    timestamp: interest.submitted_at,
                    type: 'interest_submitted',
                    category: 'interest',
                    actor: {
                        name: investorName,
                        email: null,
                        role: 'investor'
                    },
                    description: `${investorName} submitted interest${interest.indicative_amount ? ` for ${formatAmount(interest.indicative_amount)}` : ''}`,
                    details: {
                        interest_id: interest.id,
                        indicative_amount: interest.indicative_amount,
                        status: interest.status
                    }
                });
            }
            // Interest approved
            if (interest.approved_at && interest.status === 'approved') {
                allEvents.push({
                    id: `interest-approved-${interest.id}`,
                    timestamp: interest.approved_at,
                    type: 'interest_approved',
                    category: 'interest',
                    actor: {
                        name: 'Staff',
                        email: null,
                        role: 'staff'
                    },
                    description: `Approved interest from ${investorName}${interest.indicative_amount ? ` (${formatAmount(interest.indicative_amount)})` : ''}`,
                    details: {
                        interest_id: interest.id,
                        investor_name: investorName,
                        indicative_amount: interest.indicative_amount
                    }
                });
            }
            // Interest rejected (use updated_at as timestamp since rejected_at doesn't exist)
            if (interest.status === 'rejected' && interest.updated_at) {
                allEvents.push({
                    id: `interest-rejected-${interest.id}`,
                    timestamp: interest.updated_at,
                    type: 'interest_rejected',
                    category: 'interest',
                    actor: {
                        name: 'Staff',
                        email: null,
                        role: 'staff'
                    },
                    description: `Rejected interest from ${investorName}`,
                    details: {
                        interest_id: interest.id,
                        investor_name: investorName
                    }
                });
            }
        });
        // Add subscription workflow events
        subscriptions?.forEach((sub)=>{
            const investor = Array.isArray(sub.investors) ? sub.investors[0] : sub.investors;
            const investorName = investor?.legal_name || investor?.display_name || 'Unknown Investor';
            // Extract subscription amount from payload_json if available
            const payload = sub.payload_json;
            const subscriptionAmount = payload?.commitment_amount || payload?.subscription_amount || null;
            // Subscription submitted
            if (sub.submitted_at) {
                allEvents.push({
                    id: `subscription-submitted-${sub.id}`,
                    timestamp: sub.submitted_at,
                    type: 'subscription_submitted',
                    category: 'subscription',
                    actor: {
                        name: investorName,
                        email: null,
                        role: 'investor'
                    },
                    description: `${investorName} submitted subscription${subscriptionAmount ? ` for ${formatAmount(subscriptionAmount)}` : ''}`,
                    details: {
                        subscription_id: sub.id,
                        subscription_amount: subscriptionAmount,
                        status: sub.status
                    }
                });
            }
            // Subscription approved/rejected
            if (sub.decided_at) {
                const decider = Array.isArray(sub.decided_by_profile) ? sub.decided_by_profile[0] : sub.decided_by_profile;
                const isApproved = sub.status === 'approved';
                allEvents.push({
                    id: `subscription-${sub.status}-${sub.id}`,
                    timestamp: sub.decided_at,
                    type: `subscription_${sub.status}`,
                    category: 'subscription',
                    actor: {
                        name: decider?.display_name || 'Staff',
                        email: decider?.email || null,
                        role: decider?.role || 'staff'
                    },
                    description: `${isApproved ? 'Approved' : 'Rejected'} subscription from ${investorName}${subscriptionAmount ? ` (${formatAmount(subscriptionAmount)})` : ''}`,
                    details: {
                        subscription_id: sub.id,
                        investor_name: investorName,
                        subscription_amount: subscriptionAmount
                    }
                });
            }
        });
        // Add data room access events
        dataRoomAccess?.forEach((access)=>{
            const investor = Array.isArray(access.investors) ? access.investors[0] : access.investors;
            const investorName = investor?.legal_name || investor?.display_name || 'Unknown Investor';
            // Access granted
            if (access.granted_at) {
                const granter = Array.isArray(access.granted_by_profile) ? access.granted_by_profile[0] : access.granted_by_profile;
                const isAutoGranted = access.auto_granted === true;
                allEvents.push({
                    id: `access-granted-${access.id}`,
                    timestamp: access.granted_at,
                    type: 'data_room_granted',
                    category: 'access',
                    actor: {
                        name: granter?.display_name || (isAutoGranted ? 'System' : 'Staff'),
                        email: granter?.email || null,
                        role: granter?.role || (isAutoGranted ? 'system' : 'staff')
                    },
                    description: `${isAutoGranted ? 'Auto-granted' : 'Manually granted'} data room access to ${investorName}`,
                    details: {
                        access_id: access.id,
                        auto_granted: access.auto_granted,
                        investor_name: investorName
                    }
                });
            }
            // Access revoked
            if (access.revoked_at) {
                const revoker = Array.isArray(access.revoked_by_profile) ? access.revoked_by_profile[0] : access.revoked_by_profile;
                allEvents.push({
                    id: `access-revoked-${access.id}`,
                    timestamp: access.revoked_at,
                    type: 'data_room_revoked',
                    category: 'access',
                    actor: {
                        name: revoker?.display_name || 'Staff',
                        email: revoker?.email || null,
                        role: revoker?.role || 'staff'
                    },
                    description: `Revoked data room access from ${investorName}`,
                    details: {
                        access_id: access.id,
                        investor_name: investorName
                    }
                });
            }
        });
        // Add team member events
        members?.forEach((member)=>{
            const memberProfile = Array.isArray(member.member_profile) ? member.member_profile[0] : member.member_profile;
            const inviter = Array.isArray(member.invited_by_profile) ? member.invited_by_profile[0] : member.invited_by_profile;
            const memberName = memberProfile?.display_name || 'Unknown Member';
            // Member invited/added
            if (member.invited_at) {
                allEvents.push({
                    id: `member-added-${member.id}`,
                    timestamp: member.invited_at,
                    type: 'member_added',
                    category: 'membership',
                    actor: {
                        name: inviter?.display_name || 'System',
                        email: inviter?.email || null,
                        role: inviter?.role || 'staff'
                    },
                    description: `Added ${memberName} as ${member.role || 'team member'}`,
                    details: {
                        membership_id: member.id,
                        member_name: memberName,
                        member_role: member.role
                    }
                });
            }
        });
        // Add audit log events
        auditLogs?.forEach((log)=>{
            allEvents.push({
                id: log.id,
                timestamp: log.timestamp,
                type: `${log.action}_${log.event_type}`,
                category: 'audit',
                actor: {
                    name: log.actor_name,
                    email: log.actor_email,
                    role: log.actor_role
                },
                description: formatAuditLogDescription(log.action, log.event_type, log.actor_name),
                details: log.action_details || {}
            });
        });
        // Sort by timestamp (newest first)
        allEvents.sort((a, b)=>new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());
        // Paginate
        const paginatedEvents = allEvents.slice(offset, offset + limit);
        return __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            deal_id: dealId,
            since,
            events: paginatedEvents,
            total: allEvents.length,
            limit,
            offset
        });
    } catch (error) {
        console.error('Failed to fetch deal activity timeline', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$versotech$2d$portal$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Failed to load activity timeline'
        }, {
            status: 500
        });
    }
}
function formatAmount(amount) {
    if (!amount) return '';
    const num = typeof amount === 'string' ? parseFloat(amount) : amount;
    return `$${num.toLocaleString('en-US', {
        maximumFractionDigits: 0
    })}`;
}
function formatActivityEventDescription(eventType, investorName) {
    const descriptions = {
        // Actual event types in database
        'im_interested': `${investorName} expressed interest in the deal`,
        'data_room_submit': `${investorName} submitted subscription documents to data room`,
        // Legacy/future event types
        'interest_submitted': `${investorName} submitted interest in the deal`,
        'interest_approved': `Interest from ${investorName} was approved`,
        'interest_rejected': `Interest from ${investorName} was rejected`,
        'nda_granted': `${investorName} was granted NDA access`,
        'nda_completed': `${investorName} completed NDA signing`,
        'data_room_granted': `${investorName} was granted data room access`,
        'subscription_started': `${investorName} started subscription process`,
        'subscription_submitted': `${investorName} submitted subscription documents`,
        'subscription_approved': `Subscription from ${investorName} was approved`,
        'allocation_confirmed': `Allocation confirmed for ${investorName}`,
        'capital_called': `Capital call sent to ${investorName}`,
        'capital_funded': `${investorName} funded capital call`
    };
    return descriptions[eventType] || `${investorName} - ${eventType.replace(/_/g, ' ')}`;
}
function formatAuditLogDescription(action, eventType, actorName) {
    const actor = actorName || 'System';
    const descriptions = {
        'create': `${actor} created the deal`,
        'update': `${actor} updated deal information`,
        'delete': `${actor} deleted the deal`,
        'publish': `${actor} published the deal`,
        'archive': `${actor} archived the deal`,
        'member_added': `${actor} added a team member`,
        'member_removed': `${actor} removed a team member`,
        'term_sheet_published': `${actor} published term sheet`,
        'allocation_updated': `${actor} updated allocations`
    };
    const key = eventType ? eventType : action;
    return descriptions[key] || `${actor} performed ${action}`;
}
}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__c1006d8f._.js.map