#!/usr/bin/env python3
"""
Generate PROPERLY AGGREGATED position updates.
Each investor gets ONE update with the SUM of all their tranches.
"""

import json
from collections import defaultdict

def escape_sql(s):
    """Escape single quotes for SQL strings."""
    if s is None:
        return None
    return s.replace("'", "''")

def main():
    # Load extracted data
    with open('position_data_extracted.json', 'r') as f:
        data = json.load(f)

    # Aggregate by (vehicle, investor_key)
    # Key structure: (vehicle_code, key_type, *identifiers)
    aggregated = defaultdict(lambda: {'ownership': 0, 'entity': None, 'first': None, 'last': None})

    for vehicle_code, vehicle_data in data['vehicles'].items():
        for record in vehicle_data.get('records', []):
            ownership = record.get('ownership_position', 0) or 0
            if ownership == 0:
                continue

            entity = record.get('investor_entity')
            first = record.get('investor_first_name')
            last = record.get('investor_last_name')

            # Create unique key - entity takes precedence
            if entity:
                key = (vehicle_code, 'entity', entity)
            elif first and last:
                key = (vehicle_code, 'name', first, last)
            else:
                print(f"SKIPPING: {vehicle_code} - no identifier for record: {record}")
                continue

            aggregated[key]['ownership'] += ownership
            aggregated[key]['entity'] = entity
            aggregated[key]['first'] = first
            aggregated[key]['last'] = last

    # Generate SQL
    sql_lines = []
    sql_lines.append("-- Aggregated position updates generated by fix_aggregated_positions.py")
    sql_lines.append("-- Each investor gets ONE update with the SUM of all their tranches\n")

    for key, vals in sorted(aggregated.items()):
        vehicle_code = key[0]
        ownership = vals['ownership']

        if vals['entity']:
            escaped_entity = escape_sql(vals['entity'])
            where = f"i.legal_name ILIKE '%{escaped_entity}%'"
            investor_desc = vals['entity']
        else:
            escaped_first = escape_sql(vals['first'])
            escaped_last = escape_sql(vals['last'])
            where = f"(i.first_name ILIKE '%{escaped_first}%' AND i.last_name ILIKE '%{escaped_last}%')"
            investor_desc = f"{vals['first']} {vals['last']}"

        sql = f"""-- {vehicle_code}: {investor_desc} = {ownership:,.0f}
UPDATE positions p
SET units = {ownership}
FROM investors i, vehicles v
WHERE p.investor_id = i.id
  AND p.vehicle_id = v.id
  AND v.entity_code = '{vehicle_code}'
  AND {where};
"""
        sql_lines.append(sql)

    # Write output
    with open('fix_aggregated_positions.sql', 'w') as f:
        f.write('\n'.join(sql_lines))

    print(f"Generated {len(aggregated)} aggregated UPDATE statements")
    print(f"Output written to: fix_aggregated_positions.sql")

    # Print summary by vehicle
    vehicle_totals = defaultdict(float)
    for key, vals in aggregated.items():
        vehicle_totals[key[0]] += vals['ownership']

    print("\n=== Vehicle Totals (Expected) ===")
    for vc in sorted(vehicle_totals.keys()):
        print(f"{vc}: {vehicle_totals[vc]:,.0f}")

if __name__ == '__main__':
    main()
